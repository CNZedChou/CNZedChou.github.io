<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Solidity Study | ZedChou&#39;s Blog</title>
<link rel="shortcut icon" href="https://CNZedChou.github.io/favicon.ico?v=1676222959031">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://CNZedChou.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Solidity Study | ZedChou&#39;s Blog - Atom Feed" href="https://CNZedChou.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="@Description:   用于记录WTF-Solidity 学习过程
@Author:    Zed Chou
@LastModified:    Tue 15 Nov 2022

Solidity Study
Solidity是以太..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://CNZedChou.github.io">
  <img class="avatar" src="https://CNZedChou.github.io/images/avatar.png?v=1676222959031" alt="">
  </a>
  <h1 class="site-title">
    ZedChou&#39;s Blog
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Solidity Study
            </h2>
            <div class="post-info">
              <span>
                2022-11-08
              </span>
              <span>
                93 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <p>@Description:   用于记录WTF-Solidity 学习过程<br>
@Author:    Zed Chou<br>
@LastModified:    Tue 15 Nov 2022</p>
<!-- more -->
<h1 id="solidity-study">Solidity Study</h1>
<p><code>Solidity</code>是以太坊虚拟机（<code>EVM</code>）智能合约的语言。同时，我认为<code>solidity</code>是玩链上项目必备的技能：区块链项目大部分是开源的，如果你能读懂代码，就可以规避很多亏钱项目。</p>
<p><code>Solidity</code>具有两个特点：</p>
<ol>
<li>基于对象：学会之后，能帮你挣钱找对象。</li>
<li>高级：不会<code>solidity</code>，在币圈显得很low。</li>
</ol>
<h2 id="solidity-工具">Solidity 工具</h2>
<h3 id="remix">Remix</h3>
<p>官网：【<a href="https://remix.ethereum.org/">remix.ethereum.org</a>】</p>
<h4 id="1-打开remix">1. 打开remix</h4>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221108160622311.png" alt="remix面板" loading="lazy"></figure>
<p>打开官网进入<code>Remix</code>，我们可以看到Remix由四个面板组成：</p>
<ol>
<li>图标面板：上面有代表不同功能的图标，点击后，相应的功能个会显示在侧面版上。</li>
<li>侧面版：各种功能的 <code>GUI</code>。</li>
<li>主面板：代码编辑器。</li>
<li>终端：将显示与 <code>GUI</code> 交互的结果，也可以在此处运行脚本。</li>
</ol>
<h4 id="2-图标面板">2. 图标面板</h4>
<p>图标面板默认有4个图标，其中<code>文件</code>，<code>编译</code>，<code>部署</code>是最常用的。在你添加更多的<code>remix</code>插件后，它们也会显示在图标面板上。</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221108160935992.png" alt="图标面板" loading="lazy"></figure>
<h4 id="3-部署简单合约">3. 部署简单合约</h4>
<p>在<code>contract</code>文件夹下面，有三个<code>remix</code>自带的合约例子，分别是<code>1_Storage.sol</code>, <code>2_Owner.sol</code>和<code>3_Ballot.sol</code>。</p>
<p>点击<code>1_Storage.sol</code>，代码会显示在主面板的代码编辑器上。这个合约非常简单：它一个状态变量<code>number</code>，在链上存储一个<code>uint256</code>类型的数字；它有两个函数，<code>store()</code>函数将一个数字赋值给<code>number</code>变量；<code>retrieve()</code>展示<code>number</code>变量的数值。</p>
<p>接下来，点击<code>编译</code>图标，进入<code>Solidity Compiler</code>。在这里，我们选择<code>Solidity 0.8.7</code>版本，然后点击<code>Compile 1_Storage.sol</code>按钮进行编译。在合约成功编译后，<code>编译</code>图标上会显示绿色对勾。</p>
<h5 id="编译">编译</h5>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221108162510379.png" alt="简单编译" loading="lazy"></figure>
<p>你也可以尝试在优化中选在优化（<code>Enable Optimization</code>），次数设置为<code>200</code>，有时会省<code>gas</code>消耗。</p>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221108162622972.png" alt="编译成功" loading="lazy"></figure>
<h5 id="部署"><strong>部署</strong></h5>
<p>在<code>ENVIRONMENT</code>中，我们可以选择我们部署的环境，默认的是<code>JavaScript VM</code>，所有交易都在本地浏览器的沙盒区块链中执行，使用的是它给你的虚拟钱包地址；你也可以选择<code>Injected Web3</code>，即连接你的<code>metamask</code>钱包，所有交易会在真实的区块链中执行。</p>
<p>这里，我们选择<code>JavaScript VM</code>，你可以在钱包地址（<code>ACCOUNT</code>）栏看到虚拟机给你分配的测试地址。不需要调整<code>Gas</code>，也不用往合约里发送<code>ETH</code>。在<code>CONTRACT</code>栏中选择你要部署的合约<code>Storage</code>。<code>1_Storage.sol</code>文件中只有一个合约，因此默认就是部署它；但当文件包含多个合约时，我们需要手动选择要部署的合约。</p>
<p>点击<code>DEPLOY</code>键，部署完毕！</p>
<p><strong>注意：如果我们选择的是<code>Injected Web3</code>来部署合约，每一笔交易都将上链，需要钱包确认交易并支付<code>gas</code>。</strong></p>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221108162904584.png" alt="部署界面" loading="lazy"></figure>
<h5 id="调用">调用</h5>
<p>在合约部署成功后，我们可以在<code>Deployed Contracts</code>中找到我们部署的合约<code>Storage</code>。展开它，我们看到合约中的外部函数：<code>store</code>和<code>retrieve</code>。</p>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221108163219213.png" alt="已部署的合约" loading="lazy"></figure>
<p>我们在<code>store</code>函数那行的文本框中输入<code>100</code>，并点击函数名调用它。调用成功后，我们可以在终端上看到<code>log</code>信息，点击<code>Debug</code>按钮可以查看交易详情。</p>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221108163435894.png" alt="交易详情" loading="lazy"></figure>
<p>之后，我们调用<code>retrieve</code>函数，显示<code>number</code>变量被成功更新为<code>100</code>。</p>
<figure data-type="image" tabindex="8"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221108163517416.png" alt="调用retrieve" loading="lazy"></figure>
<h2 id="solidity-入门">Solidity 入门</h2>
<p><a href="https://wtf.academy/solidity-start/">Solidity 入门</a></p>
<h3 id="1-helloweb3">1. HelloWeb3</h3>
<p><a href="https://wtf.academy/solidity-start/HelloWeb3">HelloWeb3</a></p>
<h4 id="第一个solidity程序">第一个solidity程序</h4>
<p>很简单，只有1行注释+3行代码：</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;
contract HelloWeb3{
    string public _string = &quot;Hello Web3!&quot;;
}
</code></pre>
<p>我们拆开分析，学习solidity代码源文件的结构：</p>
<ol>
<li>第1行是注释，会写一下这个代码所用的软件许可（license），这里用的是MIT license。如果不写许可，编译时会警告（warning），但程序可以运行。solidity的注释由“//”开头，后面跟注释的内容（不会被程序运行）。</li>
</ol>
<pre><code class="language-solidity">// SPDX-License-Identifier: MIT
</code></pre>
<ol start="2">
<li>第2行声明源文件所用的solidity版本，因为不同版本语法有差别。这行代码意思是源文件将不允许小于 0.8.4 版本或大于等于 0.9.0 版本的编译器编译（第二个条件由<code>^</code>提供）。Solidity 语句以分号（;）结尾。</li>
</ol>
<pre><code class="language-solidity">pragma solidity ^0.8.4;
</code></pre>
<ol start="3">
<li>第3-4行是合约部分，第3行创建合约（contract），并声明合约的名字 HelloWeb3。第4行是合约的内容，我们声明了一个string（字符串）变量_string，并给他赋值 “Hello Web3!”。</li>
</ol>
<pre><code class="language-solidity">contract HelloWeb3{
    string public _string = &quot;Hello Web3!&quot;;
}
</code></pre>
<p>以后我们会更细的介绍solidity中的变量。</p>
<h4 id="编译并部署代码">编译并部署代码</h4>
<p>在编辑代码的页面，按ctrl+S就可以编译代码，非常方便。编译好之后，点击左侧菜单的“部署”按钮，进入部署页面。</p>
<figure data-type="image" tabindex="9"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221108164138102.png" alt="编译通过" loading="lazy"></figure>
<p>在默认情况下，remix会用JS虚拟机来模拟以太坊链，运行智能合约，类似在浏览器里跑一条测试链。并且remix会分配几个测试账户给你，每个里面有100 ETH（测试代币），可劲儿用。你点Deploy（黄色按钮），就可以部署咱们写好的合约了。</p>
<p>部署成功后，你会在下面看到名为<code>HelloWeb3</code>的合约，点击<code>_string</code>，就能看到我们代码中写的 “Hello Web3!” 了。</p>
<figure data-type="image" tabindex="10"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221108164255236.png" alt="调用智能合约" loading="lazy"></figure>
<h3 id="2-数值类型">2. 数值类型</h3>
<p><a href="https://wtf.academy/solidity-start/ValueTypes/">数值类型</a></p>
<h4 id="solidity-中的变量类型">solidity 中的变量类型</h4>
<ol>
<li><strong>数值类型(Value Type)</strong>：包括布尔型，整数型等等，这类变量赋值时候直接传递数值。</li>
<li><strong>引用类型(Reference Type)</strong>：包括数组和结构体，这类变量占空间大，赋值时候直接传递地址（类似指针）。</li>
<li><strong>映射类型(Mapping Type)</strong>： <code>Solidity</code>里的哈希表。</li>
<li><strong>函数类型(Function Type)</strong>：<code>Solidity</code>文档里把函数归到数值类型，但我觉得他跟其他类型差别很大，所以单独分一类。</li>
</ol>
<p>我们只介绍一些常用的类型，不常用的不讲。这篇介绍数值类型，第3讲介绍函数类型，第4讲介绍引用和映射。</p>
<h4 id="1-数值类型value-type">1. 数值类型Value type</h4>
<h5 id="1-布尔型">1. 布尔型</h5>
<p>布尔型是二值变量，取值为<code>true</code>或<code>false</code>。</p>
<pre><code class="language-solidity">// 布尔值
bool public _bool = true;
</code></pre>
<p>布尔值的运算符，包括：</p>
<ul>
<li>! （逻辑非）</li>
<li>&amp;&amp; （逻辑与， &quot;and&quot; ）</li>
<li>|| （逻辑或， &quot;or&quot; ）</li>
<li>== （等于）</li>
<li>!= （不等于）</li>
</ul>
<p>代码：</p>
<pre><code class="language-solidity">// 布尔运算
bool public _bool1 = !_bool; //取非 （false）
bool public _bool2 = _bool &amp;&amp; _bool1; //与 （false）
bool public _bool3 = _bool || _bool1; //或 （true）
bool public _bool4 = _bool == _bool1; //相等 （false）
bool public _bool5 = _bool != _bool1; //不相等 （true）
</code></pre>
<p>上面的代码中：变量<code>_bool</code>的取值是<code>true</code>；<code>_bool1</code>是<code>_bool</code>的非，为<code>false</code>；<code>_bool &amp;&amp; _bool1</code>为<code>false</code>；<code>_bool || _bool1</code>为<code>true</code>；<code>_bool == _bool1</code>为<code>false</code>；<code>_bool != _bool1</code>为<code>true</code>。</p>
<p><strong>值得注意的是：</strong><code>&amp;&amp;</code> 和 <code>||</code>运算符遵循短路规则，这意味着，假如存在<code>f(x) || g(y)</code>的表达式，如果<code>f(x)</code>是<code>true</code>，<code>g(y)</code>不会被计算，即使它和<code>f(x)</code>的结果是相反的</p>
<h5 id="2-整型">2. 整型</h5>
<p>整型是<code>solidity</code>中的整数，最常用的包括</p>
<pre><code class="language-solidity">// 整型
int public _int = -1; // 整数，包括负数
uint public _uint = 1; // 正整数
uint256 public _number = 20220330; // 256位正整数
</code></pre>
<p>常用的整型运算符包括：</p>
<ul>
<li>比较运算符（返回布尔值）： <code>&lt;=</code>， <code>&lt;</code>， <code>==</code>， <code>!=</code>， <code>&gt;=</code>， <code>&gt;</code></li>
<li>算数运算符： <code>+</code>， <code>-</code>， 一元运算 <code>-</code>， <code>+</code>， <code>*</code>， <code>/</code>， <code>%</code>（取余），<code>**</code>（幂）</li>
</ul>
<p>代码：</p>
<pre><code class="language-solidity">// 整数运算
uint256 public _number1 = _number + 1; // +，-，*，/
uint256 public _number2 = 2**2; // 指数
uint256 public _number3 = 7 % 2; // 取余数
bool public _numberbool = _number2 &gt; _number3; // 比大小
</code></pre>
<p>大家可以跑一下代码，看看这4个变量分别是多少。答对奖励个<code>POAP</code>？</p>
<h5 id="3-地址类型">3. 地址类型</h5>
<p>地址类型(address)存储一个 20 字节的值（以太坊地址的大小）。地址类型也有成员变量，并作为所有合约的基础。有普通的地址和可以转账<code>ETH</code>的地址（<code>payable</code>）。<code>payable</code>的地址拥有<code>balance</code>和<code>transfer()</code>两个成员，方便查询<code>ETH</code>余额以及转账。</p>
<p>代码</p>
<pre><code class="language-solidity">// 地址
address public _address = 0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71;
address payable public _address1 = payable(_address); // payable address，可以转账、查余额
// 地址类型的成员
uint256 public balance = _address1.balance; // balance of address
</code></pre>
<p>下一讲介绍函数的时候，会介绍如何使用地址类型。</p>
<h5 id="4-定长字节数组">4. 定长字节数组</h5>
<p>字节数组<code>bytes</code>分两种，一种定长（<code>byte</code>, <code>bytes8</code>, <code>bytes32</code>），另一种不定长。定长的属于数值类型，不定长的是引用类型（之后讲）。 定长<code>bytes</code>可以存一些数据，消耗<code>gas</code>比较少。</p>
<p>代码：</p>
<pre><code class="language-solidity">// 固定长度的字节数组
bytes32 public _byte32 = &quot;MiniSolidity&quot;; 
bytes1 public _byte = _byte32[0]; 
</code></pre>
<pre><code>MiniSolidity`变量以字节的方式存储进变量`_byte32`，转换成`16进制`为：`0x4d696e69536f6c69646974790000000000000000000000000000000000000000
</code></pre>
<p><code>_byte</code>变量存储<code>_byte32</code>的第一个字节，为<code>0x4d</code>。</p>
<h5 id="5-枚举-enum">5. 枚举 enum</h5>
<p>枚举（<code>enum</code>）是<code>solidity</code>中用户定义的数据类型。它主要用于为<code>uint</code>分配名称，使程序易于阅读和维护。它与<code>C语言</code>中的<code>enum</code>类似，使用名称来代替从<code>0</code>开始的<code>uint</code>：</p>
<pre><code class="language-solidity">// 用enum将uint 0， 1， 2表示为Buy, Hold, Sell
enum ActionSet { Buy, Hold, Sell }
// 创建enum变量 action
ActionSet action = ActionSet.Buy;
</code></pre>
<p>它可以显式的和<code>uint</code>相互转换，并会检查转换的正整数是否在枚举的长度内，不然会报错：</p>
<pre><code class="language-solidity">// enum可以和uint显式的转换
function enumToUint() external view returns(uint){
return uint(action);
}
</code></pre>
<p><code>enum</code>的一个比较冷门的变量，几乎没什么人用。</p>
<h5 id="在remix上验证">在remix上验证</h5>
<p>部署合约后可以查看每个类型的变量具体的数值</p>
<figure data-type="image" tabindex="11"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221108170612062.png" alt="验证value types的内容" loading="lazy"></figure>
<h4 id="总结">总结</h4>
<p>在这一讲，我们介绍了<code>solidity</code>中4种变量类型，并详细介绍了数值变量（<code>value type</code>)中的布尔型，整型，地址，定长字节数组和枚举。之后我们会介绍其他几种类型。</p>
<h3 id="3-函数类型">3. 函数类型</h3>
<p><a href="https://wtf.academy/solidity-start/Function/">函数类型</a></p>
<h4 id="solidity中的函数">Solidity中的函数</h4>
<p>solidity官方文档里把函数归到数值类型，但我觉得差别很大，所以单独分一类。我们先看一下solidity中函数的形式：</p>
<pre><code class="language-solidity">function &lt;function name&gt; (&lt;parameter types&gt;) {internal|external|public|private} [pure|view|payable] [returns (&lt;return types&gt;)]
</code></pre>
<p>从前往后（方括号中的是可写可不写的关键字）：</p>
<ol>
<li><code>function</code>：<strong>声明函数时的固定用法</strong>，想写函数，就要以function关键字开头。</li>
<li><code>&lt;function name&gt;</code>：函数名。</li>
<li><code>(&lt;parameter types&gt;)</code>：圆括号里写函数的参数，也就是要输入到函数的变量类型和名字。</li>
<li><code>{internal|external|public|private}</code>：函数可<strong>见性说明符</strong>，一共4种。<strong>没标明函数类型的，默认</strong><code>internal</code>。
<ul>
<li><code>public</code>: 内部外部均可见。(也可用于修饰状态变量，<strong>public变量会自动生成 <code>getter</code>函数</strong>，用于查询数值).</li>
<li><code>private</code>: 只能从本合约内部访问，继承的合约也不能用（也可用于修饰状态变量）。</li>
<li><code>external</code>: 只能从合约外部访问（但是可以用<code>this.f()</code>来调用，<code>f</code>是函数名）</li>
<li><code>internal</code>: 只能从合约内部访问，继承的合约可以用（也可用于修饰状态变量）。</li>
</ul>
</li>
<li><code>[pure|view|payable]</code>：决定函数<strong>权限/功能</strong>的关键字。<code>payable</code>（可支付的）很好理解，带着它的函数，运行的时候可以给合约转入<code>ETH</code>。<code>pure</code>和<code>view</code>的介绍见下一节。</li>
<li><code>[returns ()]</code>：函数返回的变量类型和名称。</li>
</ol>
<p><code>solidity</code>加入这两个关键字，我认为是因为<code>gas fee</code>。合约的状态变量存储在链上，<code>gas fee</code>很贵，如果不改变链上状态，就不用付<code>gas</code>。包含<code>pure</code>跟<code>view</code>关键字的函数是不改写链上状态的，因此用户直接调用他们是不需要付gas的（合约中非<code>pure</code>/<code>view</code>函数调用它们则会改写链上状态，需要付gas）。</p>
<p>在以太坊中，以下语句被视为修改链上状态：</p>
<ol>
<li>写入状态变量。</li>
<li>释放事件。</li>
<li>创建其他合同。</li>
<li>使用<code>selfdestruct</code>.</li>
<li>通过调用发送以太币。</li>
<li>调用任何未标记<code>view</code>或<code>pure</code>的函数。</li>
<li>使用低级调用（low-level calls）。</li>
<li>使用包含某些操作码的内联汇编。</li>
</ol>
<p>我画了一个马里奥插画，帮助大家理解。在插画里，我把合约中的状态变量（存储在链上）比作碧池公主，三种不同的角色代表不同的关键字</p>
<figure data-type="image" tabindex="12"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221108171552704.png" alt="pure view" loading="lazy"></figure>
<ul>
<li><code>pure</code>，中文意思是“纯”，在<code>solidity</code>里理解为“纯纯牛马”。包含<code>pure</code>关键字的函数，不能读取也不能写入存储在链上的状态变量。就像小怪一样，看不到也摸不到碧池公主。</li>
<li><code>view</code>，“看”，在<code>solidity</code>里理解为“看客”。包含<code>view</code>关键字的函数，能读取但也不能写入状态变量。类似马里奥，能看到碧池，但终究是看客，不能入洞房。</li>
<li>不写<code>pure</code>也不写<code>view</code>，函数既可以读取也可以写入状态变量。类似马里奥里的<code>boss</code>，可以对碧池公主为所欲为🐶。</li>
</ul>
<h5 id="1-pure-vs-view">1. pure v.s. view</h5>
<p>我们在合约里定义一个状态变量 <code>number = 5</code>。</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;
contract FunctionTypes{
uint256 public number = 5;
</code></pre>
<p>定义一个<code>add()</code>函数，每次调用，每次给<code>number + 1</code>。</p>
<pre><code class="language-solidity">// 默认
function add() external{
	number = number + 1;
}
</code></pre>
<p>如果<code>add()</code>包含了<code>pure</code>关键字，例如 <code>function add() pure external</code>，就会报错。因为<code>pure</code>（纯纯牛马）是不配读取合约里的状态变量的，更不配改写。那<code>pure</code>函数能做些什么？举个例子，你可以给函数传递一个参数 <code>_number</code>，然后让他返回 <code>_number+1</code>。</p>
<pre><code class="language-solidity">// pure: 纯纯牛马
function addPure(uint256 _number) external pure returns(uint256 new_number){
	new_number = _number+1;
}
</code></pre>
<p>如果<code>add()</code>包含<code>view</code>，比如<code>function add() view external</code>，也会报错。因为<code>view</code>能读取，但不能够改写状态变量。可以稍微改写下方程，让他不改写<code>number</code>，而是返回一个新的变量。</p>
<pre><code class="language-solidity">// view: 看客
function addView() external view returns(uint256 new_number) {
	new_number = number + 1;
}
</code></pre>
<figure data-type="image" tabindex="13"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221108172634601.png" alt="remix 测试" loading="lazy"></figure>
<h5 id="2-internal-vs-external">2. internal v.s. external</h5>
<pre><code class="language-solidity">// internal: 内部
function minus() internal {
	number = number - 1;
}

// 合约内的函数可以调用内部函数
function minusCall() external {
	minus();
}
</code></pre>
<p>我们定义一个<code>internal</code>的<code>minus()</code>函数，每次调用使得<code>number</code>变量减1。由于是<code>internal</code>，只能由合约内部调用，而外部不能。因此，我们必须再定义一个<code>external</code>的<code>minusCall()</code>函数，来间接调用内部的<code>minus()</code>。</p>
<figure data-type="image" tabindex="14"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221108190644289.png" alt="间接调用内部函数" loading="lazy"></figure>
<h5 id="3-payable">3. payable</h5>
<pre><code class="language-solidity">constructor() payable {}

// payable: 递钱，能给合约支付eth的函数
function minusPayable() external payable returns(uint256 balance) {
    minus();    
    balance = address(this).balance;
}
</code></pre>
<p>我们定义一个<code>external payable</code>的<code>minusPayable()</code>函数，间接的调用<code>minus()</code>，并且返回合约里的<code>ETH</code>余额（<code>this</code>关键字可以让我们引用合约地址)。 我们可以在调用<code>minusPayable()</code>时，往合约里转入1个<code>ETH</code>。</p>
<figure data-type="image" tabindex="15"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221108191539090.png" alt="payable 方法定义" loading="lazy"></figure>
<h4 id="总结-2">总结</h4>
<p>在这一讲，我们介绍了<code>solidity</code>中的函数类型，比较难理解的是<code>pure</code>和<code>view</code>，在其他语言中没出现过。<code>solidity</code>引入<code>pure</code>和<code>view</code>关键字主要是为了节省<code>gas</code>和控制函数权限：如果用户直接调用<code>pure</code>/<code>view</code>方程是不消耗<code>gas</code>的（合约中非<code>pure</code>/<code>view</code>函数调用它们则会改写链上状态，需要付gas）</p>
<h3 id="4-函数输出">4. 函数输出</h3>
<p><a href="https://wtf.academy/solidity-start/Return/">函数输出</a></p>
<p><code>Solidity</code>函数输出，包括：返回多种变量，命名式返回，以及利用解构式赋值读取全部和部分返回值。</p>
<h4 id="返回值-return和returns">返回值 return和returns</h4>
<p><code>Solidity</code>有两个关键字与函数输出相关：<code>return</code>和<code>returns</code>，他们的区别在于：</p>
<ul>
<li><code>returns</code>加在函数名后面，用于声明返回的变量类型及变量名；</li>
<li><code>return</code>用于<strong>函数主体中</strong>，返回指定的变量。</li>
</ul>
<p>上面这段代码中，我们声明了<code>returnMultiple()</code>函数将有多个输出：<code>returns(uint256, bool, uint256[3] memory)</code>，接着我们在函数主体中用<code>return(1, true, [uint256(1),2,5])</code>确定了返回值。</p>
<pre><code class="language-solidity">// 返回多个变量
function returnMultiple() public pure returns(uint256, bool, uint256[3] memory){
	return(1, true, [uint256(1),2,5]);
}
</code></pre>
<h4 id="命名式返回">命名式返回</h4>
<p>我们可以在<code>returns</code>中标明返回变量的名称，这样<code>solidity</code>会自动给这些变量初始化，并且自动返回这些函数的值，不需要加<code>return</code>。</p>
<p>在上面的代码中，我们用<code>returns(uint256 _number, bool _bool, uint256[3] memory _array)</code>声明了返回变量类型以及变量名。这样，我们在主体中只需要给变量<code>_number</code>，<code>_bool</code>和<code>_array</code>赋值就可以自动返回了。</p>
<pre><code class="language-solidity">// 命名式返回
function returnNamed() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array){
    _number = 2;
    _bool = false; 
    _array = [uint256(3),2,1];
}
</code></pre>
<p>当然，你也可以在命名式返回中用<code>return</code>来返回变量：</p>
<pre><code class="language-solidity">// 命名式返回，依然支持return
function returnNamed2() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array){
	return(1, true, [uint256(1),2,5]);
}
</code></pre>
<p>如果，命名式返回中，只有一个返回项</p>
<figure data-type="image" tabindex="16"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221108194159024.png" alt="只有一个返回项" loading="lazy"></figure>
<h4 id="解构式赋值">解构式赋值</h4>
<p><code>solidity</code>使用解构式赋值的规则，支持读取函数的全部或部分返回值。</p>
<ul>
<li>读取所有返回值：声明变量，并且将要赋值的变量用<code>,</code>隔开，按顺序排列。</li>
</ul>
<pre><code class="language-solidity">uint256 _number;
bool _bool;
uint256[3] memory _array;
(_number, _bool, _array) = returnNamed();
</code></pre>
<ul>
<li>读取部分返回值：声明要读取的返回值对应的变量，不读取的留空。下面这段代码中，我们只读取<code>_bool</code>，而不读取返回的<code>_number</code>和<code>_array</code>：</li>
</ul>
<pre><code class="language-solidity">(, _bool2, ) = returnNamed();
</code></pre>
<figure data-type="image" tabindex="17"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221108193736398.png" alt="3种return方式的区别" loading="lazy"></figure>
<h3 id="5-变量数据存储和作用域">5. 变量数据存储和作用域</h3>
<p><a href="https://wtf.academy/solidity-start/DataStorage/">变量数据存储与作用域</a></p>
<h4 id="solidity中的引用类型">Solidity中的引用类型</h4>
<p><strong>引用类型(Reference Type)</strong>：包括数组（<code>array</code>），结构体（<code>struct</code>）和映射（<code>mapping</code>），这类变量占空间大，赋值时候直接传递地址（类似指针）。由于这类变量比较复杂，占用存储空间大，我们在使用时必须要声明数据存储的位置。</p>
<h4 id="数据位置">数据位置</h4>
<p>solidity<strong>数据存储位置</strong>有三类：<code>storage</code>，<code>memory</code>和<code>calldata</code>。不同存储位置的<code>gas</code>成本不同。</p>
<p><code>storage</code>类型的数据存在<strong>链上</strong>，类似计算机的硬盘，消耗<code>gas</code><strong>多</strong>；<code>memory</code>和<code>calldata</code>类型的临时存在<strong>内存</strong>里，消耗<code>gas</code>少。</p>
<p>大致用法：</p>
<ol>
<li><code>storage</code>：合约里的<strong>状态变量</strong>默认都是<code>storage</code>，存储在链上。</li>
<li><code>memory</code>：函数里的<strong>参数和临时变量</strong>一般用<code>memory</code>，存储在内存中，不上链。</li>
<li><code>calldata</code>：和<code>memory</code>类似，存储在内存中，不上链。与<code>memory</code>的不同点在于<code>calldata</code>变量<strong>不能修改</strong>（<code>immutable</code>），一般用于函数的参数。例子：</li>
</ol>
<pre><code class="language-solidity">function fCalldata(uint[] calldata _x) public pure returns(uint[] calldata){
    //参数为calldata数组，不能被修改
    // _x[0] = 0 //这样修改会报错
    return(_x);
}
</code></pre>
<figure data-type="image" tabindex="18"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221108194922500.png" alt="calldata 不能修改" loading="lazy"></figure>
<h4 id="数据位置和赋值规则">数据位置和赋值规则</h4>
<p>在不同存储类型相互赋值时候，有时会产生独立的副本（修改新变量不会影响原变量），有时会产生引用（修改新变量会影响原变量）。规则如下：</p>
<ol>
<li><code>storage</code>（合约的状态变量）赋值给本地<code>storage</code>（函数里的）时候，会创建引用，改变新变量会影响原变量。例子：</li>
</ol>
<pre><code class="language-solidity">uint[] x = [1,2,3]; // 状态变量：数组 x

function fStorage() public{
    //声明一个storage的变量 xStorage，指向x。修改xStorage也会影响x
    uint[] storage xStorage = x;
    xStorage[0] = 100;
}
</code></pre>
<figure data-type="image" tabindex="19"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221108202437307.png" alt="修改storage的值会影响x" loading="lazy"></figure>
<ol start="2">
<li><code>storage</code>赋值给<code>memory</code>，会创建独立的复本，修改其中一个不会影响另一个；反之亦然。例子：</li>
</ol>
<pre><code class="language-solidity">uint[] x = [1,2,3]; // 状态变量：数组 x

function fMemory() public view{
    //声明一个Memory的变量xMemory，复制x。修改xMemory不会影响x
    uint[] memory xMemory = x;
    xMemory[0] = 100;
    xMemory[1] = 200;
    uint[] memory xMemory2 = x;
    xMemory2[0] = 300;
}
</code></pre>
<figure data-type="image" tabindex="20"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221108202323798.png" alt="修改memory的值不会影响x" loading="lazy"></figure>
<ol start="3">
<li>
<p><code>memory</code>赋值给<code>memory</code>，会创建引用，改变新变量会影响原变量。</p>
</li>
<li>
<p>其他情况，变量赋值给<code>storage</code>，会创建独立的复本，修改其中一个不会影响另一个。</p>
</li>
</ol>
<h4 id="变量的作用域">变量的作用域</h4>
<p><code>Solidity</code>中变量按作用域划分有三种，分别是状态变量（state variable），局部变量（local variable）和全局变量(global variable)</p>
<h5 id="1-状态变量">1. 状态变量</h5>
<p>状态变量是数据存储在链上的变量，所有合约内函数都可以访问 ，<code>gas</code>消耗高。状态变量在合约内、函数外声明：</p>
<pre><code class="language-solidity">contract Variables {
    uint public x = 1;
    uint public y;
    string public z;
</code></pre>
<p>我们可以在函数里更改状态变量的值：</p>
<pre><code class="language-solidity">function foo() external{
    // 可以在函数里更改状态变量的值
    x = 5;
    y = 2;
    z = &quot;0xAA&quot;;
}
</code></pre>
<h5 id="2-局部变量">2. 局部变量</h5>
<p>局部变量是仅在函数执行过程中有效的变量，函数退出后，变量无效。局部变量的数据存储在内存里，不上链，<code>gas</code>低。局部变量在函数内声明：</p>
<pre><code class="language-solidity">function bar() external pure returns(uint){
    uint xx = 1;
    uint yy = 3;
    uint zz = xx + yy;
    return(zz);
}
</code></pre>
<h5 id="3-全局变量">3. 全局变量</h5>
<p>全局变量是全局范围工作的变量，都是<code>solidity</code>预留关键字。他们可以在函数内不声明直接使用：</p>
<pre><code class="language-solidity">function global() external view returns(address, uint, bytes memory){
    address sender = msg.sender;
    uint blockNum = block.number;
    bytes memory data = msg.data;
    return(sender, blockNum, data);
}
</code></pre>
<p>在上面例子里，我们使用了3个常用的全局变量：<code>msg.sender</code>, <code>block.number</code>和<code>msg.data</code>，他们分别代表请求发起地址，当前区块高度，和请求数据。下面是一些常用的全局变量，更完整的列表请看这个<a href="https://learnblockchain.cn/docs/solidity/units-and-global-variables.html#special-variables-and-functions">链接</a>：</p>
<ul>
<li><code>blockhash(uint blockNumber)</code>: (<code>bytes32</code>)给定区块的哈希值 – 只适用于256最近区块, 不包含当前区块。</li>
<li><code>block.coinbase</code>: (<code>address payable</code>) 当前区块矿工的地址</li>
<li><code>block.gaslimit</code>: (<code>uint</code>) 当前区块的gaslimit</li>
<li><code>block.number</code>: (<code>uint</code>) 当前区块的number</li>
<li><code>block.timestamp</code>: (<code>uint</code>) 当前区块的时间戳，为unix纪元以来的秒</li>
<li><code>gasleft()</code>: (<code>uint256</code>) 剩余 gas</li>
<li><code>msg.data</code>: (<code>bytes calldata</code>) 完整call data</li>
<li><code>msg.sender</code>: (<code>address payable</code>) 消息发送者 (当前 caller)</li>
<li><code>msg.sig</code>: (<code>bytes4</code>) calldata的前四个字节 (function identifier)</li>
<li><code>msg.value</code>: (<code>uint</code>) 当前交易发送的<code>wei</code>值</li>
</ul>
<figure data-type="image" tabindex="21"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221108203818692.png" alt="变量的作用域" loading="lazy"></figure>
<h3 id="6-引用类型">6. 引用类型</h3>
<p><code>solidity</code>中的两个重要变量类型：数组（<code>array</code>）和结构体（<code>struct</code>）。</p>
<h4 id="数组array">数组array</h4>
<p>数组（<code>Array</code>）是<code>solidity</code>常用的一种变量类型，用来存储一组数据（整数，字节，地址等等）。数组分为固定长度数组和可变长度数组两种：</p>
<ul>
<li><strong>固定</strong>长度数组：在<strong>声明时指定数组的长度</strong>。用<code>T[k]</code>的格式声明，其中<code>T</code>是元素的类型，<code>k</code>是长度，例如：</li>
</ul>
<pre><code class="language-solidity">// 固定长度 Array
uint[8] array1;
bytes1[5] array2;
address[100] array3;
</code></pre>
<ul>
<li><strong>可变长度数组（动态数组）</strong>：在声明时不指定数组的长度。用<code>T[]</code>的格式声明，其中<code>T</code>是元素的类型，例如（<code>bytes</code>比较<strong>特殊</strong>，是数组，但是不用加<code>[]</code>）：</li>
</ul>
<pre><code class="language-solidity">// 可变长度 Array
uint[] array4;
bytes1[] array5;
address[] array6;
bytes array7;
</code></pre>
<h5 id="创建数组的规则">创建数组的规则</h5>
<p>在solidity里，创建数组有一些规则：</p>
<ul>
<li>对于<code>memory</code>修饰的<code>动态数组</code>，可以用<code>new</code>操作符来创建，但是<strong>必须声明长度，并且声明后长度不能改变</strong>。例子：</li>
</ul>
<pre><code class="language-solidity">// 初始化可变长度
uint[] array8 = new uint[](5);
bytes array9 = new bytes(9);
</code></pre>
<figure data-type="image" tabindex="22"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221109093509550.png" alt="memory 数组" loading="lazy"></figure>
<ul>
<li>数组字面常数(Array Literals)是写作表达式形式的数组，用方括号包着来初始化array的一种方式，并且里面每一个元素的type是以第一个元素为准的，例如<code>[1,2,3]</code>里面所有的元素都是uint8类型，因为在solidity中如果一个值没有指定type的话，默认就是最小单位的该type，这里int的默认最小单位类型就是uint8。而<code>[uint(1),2,3]</code>里面的元素都是uint类型，因为第一个元素指定了是uint类型了，我们都以第一个元素为准。<strong>下面的合约中，对于f函数里面的调用，如果我们没有显式对第一个元素进行uint强转的话，是会报错的，因为如上所述我们其实是传入了uint8类型的array，可是g函数需要的却是uint类型的array，就会报错了</strong>。</li>
</ul>
<pre><code class="language-solidity">// SPDX-License-Identifier: GPL-3.0
pragma solidity &gt;=0.4.16 &lt;0.9.0;
contract C {
    function f() public pure {
        g([uint(1), 2, 3]);
    }
    function g(uint[3] memory) public pure {
        // ...
    }
}
</code></pre>
<ul>
<li>如果创建的是动态数组，你需要<strong>一个一个元素的赋值</strong>。（在函数内调用）</li>
</ul>
<pre><code class="language-solidity">uint[] memory x = new uint[](3);
x[0] = 1;
x[1] = 3;
x[2] = 4;
</code></pre>
<h5 id="数组成员">数组成员</h5>
<ul>
<li><code>length</code>: 数组有一个包含元素数量的<code>length</code>成员，<code>memory</code>数组的长度在创建后是固定的。</li>
<li><code>push()</code>: <code>动态数组</code>和<code>bytes</code>拥有<code>push()</code>成员，可以在数组最后添加一个<code>0</code>元素。</li>
<li><code>push(x)</code>: <code>动态数组</code>和<code>bytes</code>拥有<code>push(x)</code>成员，可以在数组最后添加一个<code>x</code>元素。</li>
<li><code>pop()</code>: <code>动态数组</code>和<code>bytes</code>拥有<code>pop()</code>成员，可以移除数组最后一个元素。</li>
</ul>
<figure data-type="image" tabindex="23"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221109095151746.png" alt="数组remix验证" loading="lazy"></figure>
<h4 id="结构体struct">结构体struct</h4>
<p><code>Solidity</code>支持通过构造结构体的形式定义新的类型。创建结构体的方法：</p>
<pre><code class="language-solidity">// 结构体
struct Student{
    uint256 id;
    uint256 score; 
}
</code></pre>
<pre><code class="language-solidity">Student student; // 初始一个student结构体
</code></pre>
<p>给结构体赋值的两种方法：</p>
<pre><code class="language-solidity">//  给结构体赋值
// 方法1:在函数中创建一个storage的struct引用
function initStudent1() external{
    Student storage _student = student; // assign a copy of student
    _student.id = 11;
    _student.score = 100;
}
</code></pre>
<figure data-type="image" tabindex="24"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221109100225829.png" alt="结构体赋值方法1" loading="lazy"></figure>
<pre><code class="language-solidity">// 方法2:直接引用状态变量的struct
function initStudent2() external{
    student.id = 1;
    student.score = 80;
}
</code></pre>
<figure data-type="image" tabindex="25"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221109100343565.png" alt="结构体赋值方法2" loading="lazy"></figure>
<h3 id="7-映射类型">7. 映射类型</h3>
<h4 id="映射mapping">映射Mapping</h4>
<p>在映射中，人们可以通过键（<code>Key</code>）来查询对应的值（<code>Value</code>），比如：通过一个人的<code>id</code>来查询他的钱包地址。</p>
<p>声明映射的格式为<code>mapping(_KeyType =&gt; _ValueType)</code>，其中<code>_KeyType</code>和<code>_ValueType</code>分别是<code>Key</code>和<code>Value</code>的变量类型。例子：</p>
<pre><code class="language-solidity">mapping(uint =&gt; address) public idToAddress; // id映射到地址
mapping(address =&gt; address) public swapPair; // 币对的映射，地址到地址
</code></pre>
<h4 id="映射的规则">映射的规则</h4>
<ul>
<li><strong>规则1</strong>：映射的<code>_KeyType</code>只能选择<code>solidity</code>默认的类型，比如<code>uint</code>，<code>address</code>等，不能用自定义的结构体。而<code>_ValueType</code>可以使用自定义的类型。下面这个例子会报错，因为<code>_KeyType</code>使用了我们自定义的结构体：</li>
</ul>
<pre><code class="language-solidity">// 我们定义一个结构体 Struct
struct Student{
    uint256 id;
    uint256 score; 
}
mapping(Student =&gt; uint) public testVar;
</code></pre>
<figure data-type="image" tabindex="26"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221109101316243.png" alt="_KeyType 只能选择solidity的默认类型" loading="lazy"></figure>
<ul>
<li><strong>规则2</strong>：映射的存储位置必须是<code>storage</code>，因此可以用于合约的状态变量，函数中的<code>storage</code>变量，和library函数的参数（见<a href="https://github.com/ethereum/solidity/issues/4635">例子</a>）。不能用于<code>public</code>函数的参数或返回结果中，因为<code>mapping</code>记录的是一种关系 (key - value pair)。</li>
<li><strong>规则3</strong>：如果映射声明为<code>public</code>，那么<code>solidity</code>会自动给你创建一个<code>getter</code>函数，可以通过<code>Key</code>来查询对应的<code>Value</code>。</li>
<li><strong>规则4</strong>：给<strong>映射新增的键值对</strong>的语法为<code>_Var[_Key] = _Value</code>，其中<code>_Var</code>是映射变量名，<code>_Key</code>和<code>_Value</code>对应新增的键值对。例子：</li>
</ul>
<pre><code class="language-solidity">function writeMap (uint _Key, address _Value) public{
	idToAddress[_Key] = _Value;
}
</code></pre>
<h4 id="映射的原理">映射的原理</h4>
<ul>
<li><strong>原理1</strong>: 映射不储存任何键（<code>Key</code>）的资讯，<strong>也没有length的资讯</strong>。</li>
<li><strong>原理2</strong>: 映射使用<code>keccak256(key)</code>当成offset存取value。</li>
<li><strong>原理3</strong>: 因为Ethereum会定义所有未使用的空间为0，所以未赋值（<code>Value</code>）的键（<code>Key</code>）初始值都是0。</li>
</ul>
<figure data-type="image" tabindex="27"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221109101652362.png" alt="未赋值" loading="lazy"></figure>
<figure data-type="image" tabindex="28"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221109101902072.png" alt="writema" loading="lazy"></figure>
<h3 id="8-变量初始值">8. 变量初始值</h3>
<p>在<code>solidity</code>中，声明但没赋值的变量都有它的初始值或默认值。这一讲，我们将介绍常用变量的初始值。</p>
<h4 id="值类型初始值">值类型初始值</h4>
<ul>
<li>
<p><code>boolean</code>: <code>false</code></p>
</li>
<li>
<p><code>string</code>: <code>&quot;&quot;</code></p>
</li>
<li>
<p><code>int</code>: <code>0</code></p>
</li>
<li>
<p><code>uint</code>: <code>0</code></p>
</li>
<li>
<p><code>enum</code>: 枚举中的第一个元素</p>
</li>
<li>
<p><code>address</code>: <code>0x0000000000000000000000000000000000000000</code> (或 <code>address(0)</code>)</p>
</li>
<li>
<pre><code>function
</code></pre>
<ul>
<li><code>internal</code>: 空白方程</li>
<li><code>external</code>: 空白方程</li>
</ul>
</li>
<li>
<p><code>bytes1</code>：<code>0x00</code></p>
</li>
</ul>
<p>可以用<code>public</code>变量的<code>getter</code>函数验证上面写的初始值是否正确：</p>
<pre><code class="language-solidity">bool public _bool; // false
string public _string; // &quot;&quot;
int public _int; // 0
uint public _uint; // 0
address public _address; // 0x0000000000000000000000000000000000000000

enum ActionSet { Buy, Hold, Sell}
ActionSet public _enum; // 第一个元素 0

function fi() internal{} // internal空白方程 
function fe() external{} // external空白方程 
</code></pre>
<figure data-type="image" tabindex="29"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221109102811871.png" alt="值类型初始值" loading="lazy"></figure>
<h4 id="引用类型初始值">引用类型初始值</h4>
<ul>
<li>映射<code>mapping</code>: 所有元素都为其默认值的<code>mapping</code></li>
<li>结构体<code>struct</code>: 所有成员设为其默认值的结构体</li>
<li>数组<code>array</code>
<ul>
<li>动态数组: <code>[]</code></li>
<li>静态数组（定长）: 所有成员设为其默认值的静态数组</li>
</ul>
</li>
</ul>
<p>可以用<code>public</code>变量的<code>getter</code>函数验证上面写的初始值是否正确：</p>
<pre><code class="language-solidity">// Reference Types
uint[8] public _staticArray; // 所有成员设为其默认值的静态数组[0,0,0,0,0,0,0,0]
uint[] public _dynamicArray; // `[]`
mapping(uint =&gt; address) public _mapping; // 所有元素都为其默认值的mapping
// 所有成员设为其默认值的结构体 0, 0
struct Student{
    uint256 id;
    uint256 score; 
}
Student public student;
</code></pre>
<figure data-type="image" tabindex="30"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221109103443921.png" alt="引用类型初始化" loading="lazy"></figure>
<h4 id="delete操作符"><code>delete</code>操作符</h4>
<p><code>delete a</code>会让变量<code>a</code>的值变为初始值。</p>
<pre><code class="language-solidity">// delete操作符
bool public _bool2 = true; 
function d() external {
    delete _bool2; // delete 会让_bool2变为默认值，false
}
</code></pre>
<figure data-type="image" tabindex="31"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221109103603138.png" alt="delete 操作符" loading="lazy"></figure>
<h3 id="9-常数">9. 常数</h3>
<p>介绍<code>solidity</code>中两个关键字，<code>constant</code>（常量）和<code>immutable</code>（不变量）。状态变量声明这个两个关键字之后，不能在合约后更改数值；并且还可以节省<code>gas</code>。另外，只有数值变量可以声明<code>constant</code>和<code>immutable</code>；<code>string</code>和<code>bytes</code>可以声明为<code>constant</code>，但不能为<code>immutable</code>。</p>
<h4 id="constant">constant</h4>
<p><code>constant</code>变量必须在<strong>声明的时候初始化，之后再也不能改变</strong>。尝试改变的话，编译不通过。</p>
<p><code>constant</code>变量初始化之后，尝试改变它的值，会编译不通过并抛出<code>TypeError: Cannot assign to a constant variable.</code>的错误。</p>
<pre><code class="language-solidity">// constant变量必须在声明的时候初始化，之后不能改变
uint256 constant CONSTANT_NUM = 10;
string constant CONSTANT_STRING = &quot;0xAA&quot;;
bytes constant CONSTANT_BYTES = &quot;WTF&quot;;
address constant CONSTANT_ADDRESS = 0x0000000000000000000000000000000000000000;
</code></pre>
<h4 id="immutableimmutable-variables-cannot-have-a-non-value-type">immutable（Immutable variables cannot have a non-value type）</h4>
<p><code>immutable</code>变量可以在声明时或构造函数中初始化，因此更加灵活。</p>
<pre><code class="language-solidity">// immutable变量可以在constructor里初始化，之后不能改变
uint256 public immutable IMMUTABLE_NUM = 9999999999;
address public immutable IMMUTABLE_ADDRESS;
uint256 public immutable IMMUTABLE_BLOCK;
uint256 public immutable IMMUTABLE_TEST;
</code></pre>
<p>你可以使用全局变量例如<code>address(this)</code>，<code>block.number</code> ，或者自定义的函数给<code>immutable</code>变量初始化。</p>
<p><code>immutable</code>变量初始化之后，尝试改变它的值，会编译不通过并抛出<code>TypeError: Immutable state variable already initialized.</code>的错误。</p>
<p>在下面这个例子，我们利用了<code>test()</code>函数给<code>IMMUTABLE_TEST</code>初始化为<code>9</code>：</p>
<pre><code class="language-solidity">// 利用constructor初始化immutable变量，因此可以利用
constructor(){
    IMMUTABLE_ADDRESS = address(this);
    IMMUTABLE_BLOCK = block.number;
    IMMUTABLE_TEST = test();
}

function test() public pure returns(uint256){
    uint256 what = 9;
    return(what);
}
</code></pre>
<figure data-type="image" tabindex="32"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221109104948188.png" alt="immutable 常量" loading="lazy"></figure>
<h3 id="10-控制流">10. 控制流</h3>
<p>介绍<code>solidity</code>中的控制流，然后讲如何用<code>solidity</code>实现插入排序（<code>InsertionSort</code>），一个看起来简单，但实际上很容易写出<code>bug</code>的程序。</p>
<h4 id="控制流类型">控制流类型</h4>
<p><code>Solidity</code>的控制流与其他语言类似，主要包含以下几种：</p>
<ol>
<li><code>if-else</code></li>
</ol>
<pre><code class="language-solidity">function ifElseTest(uint256 _number) public pure returns(bool){
    if(_number == 0){
    	return(true);
    }else{
    	return(false);
    }
}
</code></pre>
<ol start="2">
<li><code>for循环</code></li>
</ol>
<pre><code class="language-solidity">function forLoopTest() public pure returns(uint256){
    uint sum = 0;
    for(uint i = 0; i &lt; 10; i++){
    	sum += i;
    }
    return(sum);
}
</code></pre>
<ol start="3">
<li><code>while循环</code></li>
</ol>
<pre><code class="language-solidity">function whileTest() public pure returns(uint256){
    uint sum = 0;
    uint i = 0;
    while(i &lt; 10){
    	sum += i;
    	i++;
    }
    return(sum);
}
</code></pre>
<ol start="4">
<li><code>do-while循环</code></li>
</ol>
<pre><code class="language-solidity">function doWhileTest() public pure returns(uint256){
    uint sum = 0;
    uint i = 0;
    do{
    	sum += i;
    	i++;
    }while(i &lt; 10);
    return(sum);
}
</code></pre>
<ol start="5">
<li><code>三元运算符</code> 三元运算符是<code>solidity</code>中唯一一个接受三个操作数的运算符，规则<code>条件? 条件为真的表达式:条件为假的表达式</code>。 此运算符经常用作 if 语句的快捷方式。</li>
</ol>
<pre><code class="language-solidity">// 三元运算符 ternary/conditional operator
function ternaryTest(uint256 x, uint256 y) public pure returns(uint256){
    // return the max of x and y
    return x &gt;= y ? x: y; 
}
</code></pre>
<p>另外还有<code>continue</code>（立即进入下一个循环）和<code>break</code>（跳出当前循环）关键字可以使用。</p>
<figure data-type="image" tabindex="33"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221109130349335.png" alt="控制流简介" loading="lazy"></figure>
<h4 id="用solidity实现插入排序">用solidity实现插入排序</h4>
<p>排序算法解决的问题是将无序的一组数字，例如<code>[2, 5, 3, 1]</code>，从小到大依次排列好。插入排序（<code>InsertionSort</code>）是最简单的一种排序算法，也是很多人学习的第一个算法。它的思路很简答，从前往后，依次将每一个数和排在他前面的数字比大小，如果比前面的数字小，就互换位置。</p>
<h5 id="python代码"><code>python</code>代码</h5>
<p>我们可以先看一下插入排序的python代码：</p>
<pre><code class="language-python"># Python program for implementation of Insertion Sort
def insertionSort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i-1
        while j &gt;=0 and key &lt; arr[j] :
            arr[j+1] = arr[j]
            j -= 1
        arr[j+1] = key
</code></pre>
<pre><code class="language-solidity">// 插入排序 错误版
function insertionSortWrong(uint[] memory a) public pure returns(uint[] memory) {
    for (uint i = 1;i &lt; a.length;i++){
        uint temp = a[i];
        uint j=i-1;
        while( (j &gt;= 0) &amp;&amp; (temp &lt; a[j])){
            a[j+1] = a[j];
            j--;
    	}
        a[j+1] = temp;
    }
    return(a);
}
</code></pre>
<figure data-type="image" tabindex="34"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221109133703767.png" alt="插入排序错误版" loading="lazy"></figure>
<p><code>solidity</code>中最常用的变量类型是<code>uint</code>，也就是正整数，取到负值的话，会报<code>underflow</code>错误。而在插入算法中，变量<code>j</code>有可能会取到<code>-1</code>，引起报错。</p>
<p>这里，我们需要把<code>j</code>加1，让它无法取到负值。正确代码：</p>
<pre><code class="language-solidity">// 插入排序 正确版*
function insertionSort(uint[] memory a) public pure returns(uint[] memory) {
    // note that uint can not take negative value*
    for (uint i = 1;i &lt; a.length;i++){
        uint temp = a[i];
        uint j=i;
        while( (j &gt;= 1) &amp;&amp; (temp &lt; a[j-1])){
            a[j] = a[j-1];
            j--;
        }
        a[j] = temp;
    }
    return(a);
}
</code></pre>
<figure data-type="image" tabindex="35"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221109134230450.png" alt="插入排序正确版" loading="lazy"></figure>
<h3 id="11-构造函数和修饰器">11. 构造函数和修饰器</h3>
<p>用合约权限控制（<code>Ownable</code>）的例子介绍<code>solidity</code>语言中构造函数（<code>constructor</code>）和独有的修饰器（<code>modifier</code>）。</p>
<h4 id="构造函数">构造函数</h4>
<p>构造函数（<code>constructor</code>）是一种特殊的函数，每个合约可以<strong>定义一个</strong>，并在<strong>部署合约的时候自动运行一次</strong>。它可以用来<strong>初始化合约</strong>的一些参数，例如初始化合约的<code>owner</code>地址：</p>
<pre><code class="language-solidity">address owner; // 定义owner变量

// 构造函数
constructor() {
	owner = msg.sender; // 在部署合约的时候，将owner设置为部署者的地址
}
</code></pre>
<p><strong>注意</strong>⚠️：构造函数在不同的solidity版本中的语法并不一致，在Solidity 0.4.22之前，构造函数不使用 <code>constructor</code> 而是使用与合约名同名的函数作为构造函数而使用，由于这种旧写法容易使开发者在书写时发生疏漏（例如合约名叫 <code>Parents</code>，构造函数名写成 <code>parents</code>），使得构造函数变成普通函数，引发漏洞，所以0.4.22版本及之后，采用了全新的 <code>constructor</code> 写法。</p>
<p>构造函数的旧写法代码示例：</p>
<pre><code class="language-solidity">pragma solidity =0.4.21;
contract Parents {
    // 与合约名Parents同名的函数就是构造函数
    function Parents () public {
    }
}
</code></pre>
<h4 id="修饰器">修饰器</h4>
<p>修饰器（<code>modifier</code>）是<code>solidity</code>特有的语法，类似于面向对象编程中的<code>decorator</code>，声明<strong>函数拥有的特性，并减少代码冗余</strong>。它就像钢铁侠的智能盔甲，穿上它的函数会带有某些特定的行为。<code>modifier</code>的主要使用场景是<strong>运行函数前的检查，例如地址，变量，余额</strong>等。</p>
<p>我们来定义一个叫做onlyOwner的modifier：</p>
<pre><code class="language-solidity">// 定义modifier
modifier onlyOwner {
    require(msg.sender == owner); // 检查调用者是否为owner地址
    _; // 如果是的话，继续运行函数主体；否则报错并revert交易
}
</code></pre>
<p>代有<code>onlyOwner</code>修饰符的函数只能被<code>owner</code>地址调用，比如下面这个例子：</p>
<pre><code class="language-solidity">function changeOwner(address _newOwner) external onlyOwner{
    owner = _newOwner; // 只有owner地址运行这个函数，并改变owner
}
</code></pre>
<p>我们定义了一个<code>changeOwner</code>函数，运行他可以改变合约的<code>owner</code>，但是由于<code>onlyOwner</code>修饰符的存在，只有原先的<code>owner</code>可以调用，别人调用就会报错。这也是最常用的控制智能合约权限的方法。</p>
<figure data-type="image" tabindex="36"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221109143515517.png" alt="查看owner" loading="lazy"></figure>
<figure data-type="image" tabindex="37"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221109143910469.png" alt="以owner身份调用change函数" loading="lazy"></figure>
<figure data-type="image" tabindex="38"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221109144203709.png" alt="非owner账户地址，调用报错" loading="lazy"></figure>
<h3 id="12-事件">12. 事件</h3>
<p><code>Solidity</code>中的事件（<code>event</code>）是<code>EVM</code>上日志的抽象，它具有两个特点：</p>
<ul>
<li>响应：应用程序（<a href="https://learnblockchain.cn/docs/ethers.js/api-contract.html#id18"><code>ether.js</code></a>）可以通过<code>RPC</code>接口订阅和监听这些事件，并在前端做响应。</li>
<li>经济：事件是<code>EVM</code>上比较经济的存储数据的方式，每个大概消耗2,000 <code>gas</code>；相比之下，链上存储一个新变量至少需要20,000 <code>gas</code>。</li>
</ul>
<h4 id="规则">规则</h4>
<p>事件的声明由<code>event</code>关键字开头，然后跟<strong>事件名称</strong>，括号里面写好事件<strong>需要记录的变量类型和变量名</strong>。以<code>ERC20</code>代币合约的<code>Transfer</code>事件为例：</p>
<pre><code class="language-solidity">event Transfer(address indexed from, address indexed to, uint256 value);
</code></pre>
<p>我们可以看到，<code>Transfer</code>事件共记录了3个变量<code>from</code>，<code>to</code>和<code>value</code>，分别对应代币的转账地址，接收地址和转账数量。</p>
<p>同时<code>from</code>和<code>to</code>前面带着<code>indexed</code>关键字，每个<code>indexed</code>标记的变量可以理解<strong>为检索事件的索引“键”</strong>，在以太坊上单独作为一个<code>topic</code>进行存储和索引，程序可以轻松的筛选出特定转账地址和接收地址的转账事件。每个<strong>事件最多有3个</strong>带<code>indexed</code>的变量。每个 <code>indexed</code> 变量的大小为固定的256比特。事件的哈希以及这三个带<code>indexed</code>的变量在<code>EVM</code>日志中通常被存储为<code>topic</code>。其中<code>topic[0]</code>是此事件的<code>keccak256</code>哈希，<code>topic[1]</code>到<code>topic[3]</code>存储了带<code>indexed</code>变量的<code>keccak256</code>哈希。</p>
<p><code>value</code> 不带 <code>indexed</code> 关键字，会存储在事件的 <code>data</code> 部分中，可以理解为事件的“值”。<code>data</code> 部分的变量不能被直接检索，但可以存储任意大小的数据。因此一般 <code>data</code> 部分可以用来存储复杂的数据结构，例如数组和字符串等等，因为这些数据超过了256比特，即使存储在事件的 <code>topic</code> 部分中，也是以哈希的方式存储。另外，<code>data</code> 部分的变量在存储上消耗的gas相比于 <code>topic</code> 更少。</p>
<p>我们可以在函数里释放事件。在下面的例子中，每次用<code>_transfer()</code>函数进行转账操作的时候，都会释放<code>Transfer</code>事件，并记录相应的变量。</p>
<pre><code class="language-solidity">// 定义_transfer函数，执行转账逻辑
function _transfer(
    address from,
    address to,
    uint256 amount
) external {
    _balances[from] = 10000000; // 给转账地址一些初始代币

    _balances[from] -=  amount; // from地址减去转账数量
    _balances[to] += amount; // to地址加上转账数量

    // 释放事件
    emit Transfer(from, to, amount);
}
</code></pre>
<figure data-type="image" tabindex="39"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221110103328402.png" alt="发起transfer交易" loading="lazy"></figure>
<figure data-type="image" tabindex="40"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221110103621003.png" alt="具体内容" loading="lazy"></figure>
<h3 id="13-继承">13. 继承</h3>
<p>继承是面向对象编程很重要的组成部分，可以显著减少重复代码。如果把合约看作是对象的话，<code>solidity</code>也是面向对象的编程，也支持继承。</p>
<h4 id="规则-2">规则</h4>
<ul>
<li><code>virtual</code>: 父合约中的函数，如果希望子合约重写，需要加上<code>virtual</code>关键字。</li>
<li><code>override</code>：子合约重写了父合约中的函数，需要加上<code>override</code>关键字。</li>
</ul>
<h4 id="简单继承">简单继承</h4>
<p>我们先写一个简单的爷爷合约<code>Yeye</code>，里面包含1个<code>Log</code>事件和3个<code>function</code>: <code>hip()</code>, <code>pop()</code>, <code>yeye()</code>，输出都是”Yeye”。</p>
<pre><code class="language-solidity">contract Yeye {
    event Log(string msg);

    // 定义3个function: hip(), pop(), man()，Log值为Yeye。
    function hip() public virtual{
        emit Log(&quot;Yeye&quot;);
    }

    function pop() public virtual{
        emit Log(&quot;Yeye&quot;);
    }

    function yeye() public virtual {
        emit Log(&quot;Yeye&quot;);
    }
}
</code></pre>
<p>我们再定义一个爸爸合约<code>Baba</code>，让他继承<code>Yeye</code>合约，语法就是<code>contract Baba is Yeye</code>，非常直观。在<code>Baba</code>合约里，我们重写一下<code>hip()</code>和<code>pop()</code>这两个函数，加上<code>override</code>关键字，并将他们的输出改为<code>”Baba”</code>；并且加一个新的函数<code>baba</code>，输出也是<code>”Baba”</code>。</p>
<pre><code class="language-solidity">contract Baba is Yeye{
    // 继承两个function: hip()和pop()，输出改为Baba。
    function hip() public virtual override{
        emit Log(&quot;Baba&quot;);
    }

    function pop() public virtual override{
        emit Log(&quot;Baba&quot;);
    }

    function baba() public virtual{
        emit Log(&quot;Baba&quot;);
    }
}
</code></pre>
<p>我们部署合约，可以看到<code>Baba</code>合约里有4个函数，其中<code>hip()</code>和<code>pop()</code>的输出被成功改写成<code>”Baba”</code>，而继承来的<code>yeye()</code>的输出仍然是<code>”Yeye”</code>。</p>
<figure data-type="image" tabindex="41"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221110104822210.png" alt="BABA 继承 Yeye" loading="lazy"></figure>
<h4 id="多重继承">多重继承</h4>
<p><code>solidity</code>的合约可以继承多个合约。规则：</p>
<p>继承时要按辈分<strong>最高到最低的顺序排</strong>。比如我们写一个<code>Erzi</code>合约，继承<code>Yeye</code>合约和<code>Baba</code>合约，那么就要写成<code>contract Erzi is Yeye, Baba</code>，而不能写成<code>contract Erzi is Baba, Yeye</code>，不然就会报错。 如果某一个函数在多个继承的合约里都存在，比如例子中的<code>hip()</code>和<code>pop()</code>，在<strong>子合约里必须重写</strong>，不然会报错。 重写在<strong>多个父合约中都重名</strong>的函数时，<code>override</code>关键字后面要<strong>加上所有父合约名字</strong>，例如<code>override(Yeye, Baba)</code>。 例子：</p>
<pre><code class="language-solidity">contract Erzi is Yeye, Baba{
// 继承两个function: hip()和pop()，输出值为Erzi。
    function hip() public virtual override(Yeye, Baba){
    	emit Log(&quot;Erzi&quot;);
    }

    function pop() public virtual override(Yeye, Baba) {
    	emit Log(&quot;Erzi&quot;);
	}
}
</code></pre>
<p>我们可以看到，<code>Erzi</code>合约里面重写了<code>hip()</code>和<code>pop()</code>两个函数，将输出改为<code>”Erzi”</code>，并且还分别从<code>Yeye</code>和<code>Baba</code>合约继承了<code>yeye()</code>和<code>baba()</code>两个函数。</p>
<figure data-type="image" tabindex="42"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221110105230795.png" alt="多重继承" loading="lazy"></figure>
<h4 id="修饰器的继承">修饰器的继承</h4>
<p><code>Solidity</code>中的修饰器（<code>Modifier</code>）同样可以继承，用法与函数继承类似，在相应的地方加<code>virtual</code>和<code>override</code>关键字即可。</p>
<pre><code class="language-solidity">contract Base1 {
    modifier exactDividedBy2And3(uint _a) virtual {
        require(_a % 2 == 0 &amp;&amp; _a % 3 == 0);
        _;
    }
}

contract Identifier is Base1 {

    //计算一个数分别被2除和被3除的值，但是传入的参数必须是2和3的倍数
    function getExactDividedBy2And3(uint _dividend) public exactDividedBy2And3(_dividend) pure returns(uint, uint) {
        return getExactDividedBy2And3WithoutModifier(_dividend);
    }

    //计算一个数分别被2除和被3除的值
    function getExactDividedBy2And3WithoutModifier(uint _dividend) public pure returns(uint, uint){
        uint div2 = _dividend / 2;
        uint div3 = _dividend / 3;
        return (div2, div3);
    }
}
</code></pre>
<figure data-type="image" tabindex="43"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221110110533752.png" alt="修饰器的继承" loading="lazy"></figure>
<p><code>Identifier</code>合约可以直接在代码中使用父合约中的<code>exactDividedBy2And3</code>修饰器，也可以利用<code>override</code>关键字重写修饰器：</p>
<pre><code class="language-solidity">modifier exactDividedBy2And3(uint _a) override {
    _;
    require(_a % 2 == 0 &amp;&amp; _a % 3 == 0);
}
</code></pre>
<h4 id="构造函数的继承">构造函数的继承</h4>
<p>子合约有两种方法继承父合约的构造函数。举个简单的例子，父合约<code>A</code>里面有一个状态变量<code>a</code>，并由构造函数的参数来确定：</p>
<pre><code class="language-solidity">// 构造函数的继承
abstract contract A {
    uint public a;
    constructor(uint _a) {
        a = _a;
    }
}
</code></pre>
<ol>
<li>在继承时声明父构造函数的参数，例如：<code>contract B is A(1)</code></li>
<li>在子合约的构造函数中声明构造函数的参数，例如：</li>
</ol>
<pre><code class="language-solidity">contract C is A {
    constructor(uint _c) A(_c * _c) {}
}
</code></pre>
<figure data-type="image" tabindex="44"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221110130451581.png" alt="输入参数部署合约" loading="lazy"></figure>
<figure data-type="image" tabindex="45"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221110130644330.png" alt="查看a的值" loading="lazy"></figure>
<h4 id="调用父合约的函数">调用父合约的函数</h4>
<p>子合约有两种方式调用父合约的函数，直接调用和利用<code>super</code>关键字。</p>
<ol>
<li>直接调用：子合约可以直接用<code>父合约名.函数名()</code>的方式来调用父合约函数，例如<code>Yeye.pop()</code>。</li>
</ol>
<pre><code class="language-solidity">function callParent() public{
	Yeye.pop();
}
</code></pre>
<ol start="2">
<li><code>super</code>关键字：子合约可以利用<code>super.函数名()</code>来调用最近的父合约函数。<code>solidity</code>继承关系按声明时从右到左的顺序是：<code>contract Erzi is Yeye, Baba</code>，那么<code>Baba</code>是<strong>最近的父合约</strong>，<code>super.pop()</code>将调用<code>Baba.pop()</code>而不是<code>Yeye.pop()</code>：</li>
</ol>
<pre><code class="language-solidity">function callParentSuper() public{
    // 将调用最近的父合约函数，Baba.pop()
    super.pop();
}
</code></pre>
<figure data-type="image" tabindex="46"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221110130028088.png" alt="调用父合约的函数" loading="lazy"></figure>
<h3 id="14-抽象合约与接口">14. 抽象合约与接口</h3>
<p>用<code>ERC721</code>的接口合约为例介绍<code>solidity</code>中的抽象合约（<code>abstract</code>）和接口（<code>interface</code>），帮助大家更好的理解<code>ERC721</code>标准。</p>
<h4 id="抽象合约">抽象合约</h4>
<p>如果一个智能合约里<strong>至少有一个未实现的函数</strong>，即某个函数缺少主体<code>{}</code>中的内容，则必须将该合约标为<code>abstract</code>，不然编译会报错；另外，未实现的函数<strong>需要加</strong><code>virtual</code>，以便子合约重写。拿我们之前的<a href="https://github.com/AmazingAng/WTFSolidity/tree/main/07_InsertionSort">插入排序合约</a>为例，如果我们还没想好具体怎么实现插入排序函数，那么可以把合约标为<code>abstract</code>，之后让别人补写上。</p>
<pre><code class="language-solidity">abstract contract InsertionSort{
    function insertionSort(uint[] memory a) public pure virtual returns(uint[] memory);
}
</code></pre>
<figure data-type="image" tabindex="47"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221110131826591.png" alt="抽象合约" loading="lazy"></figure>
<h4 id="接口">接口</h4>
<p>接口类似于抽象合约，<strong>但它不实现任何功能</strong>。接口的规则：</p>
<ol>
<li>不能包含状态变量</li>
<li>不能包含构造函数</li>
<li>不能继承除接口外的其他合约</li>
<li><strong>所有函数都必须是external且不能有函数体</strong></li>
<li>继承接口的合约<strong>必须实现接口定义的所有功能</strong></li>
</ol>
<p>虽然接口不实现任何功能，但它非常重要。接口是智能合约的骨架，定义了合约的功能以及如何触发它们：如果智能合约实现了某种接口（比如<code>ERC20</code>或<code>ERC721</code>），其他Dapps和智能合约就知道如何与它交互。因为接口提供了两个重要的信息：</p>
<ol>
<li>合约里每个函数的<code>bytes4</code>选择器，以及基于它们的函数签名<code>函数名(每个参数类型）</code>。</li>
<li>接口id（更多信息见<a href="https://eips.ethereum.org/EIPS/eip-165">EIP165</a>）</li>
</ol>
<p>另外，接口与合约<code>ABI</code>（Application Binary Interface）等价，可以相互转换：编译接口可以得到合约的<code>ABI</code>，利用<a href="https://gnidan.github.io/abi-to-sol/">abi-to-sol工具</a>也可以将<code>ABI json</code>文件转换为<code>接口sol</code>文件。</p>
<p>我们以<code>ERC721</code>接口合约<code>IERC721</code>为例，它定义了3个<code>event</code>和9个<code>function</code>，所有<code>ERC721</code>标准的NFT都实现了这些函数。我们可以看到，<strong>接口和常规合约的区别</strong>在于每个函数都以<code>;</code>代替函数体<code>{ }</code>结尾。</p>
<pre><code class="language-solidity">interface IERC721 is IERC165 {
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
    
    function balanceOf(address owner) external view returns (uint256 balance);

    function ownerOf(uint256 tokenId) external view returns (address owner);

    function safeTransferFrom(address from, address to, uint256 tokenId) external;

    function transferFrom(address from, address to, uint256 tokenId) external;

    function approve(address to, uint256 tokenId) external;

    function getApproved(uint256 tokenId) external view returns (address operator);

    function setApprovalForAll(address operator, bool _approved) external;

    function isApprovedForAll(address owner, address operator) external view returns (bool);

    function safeTransferFrom( address from, address to, uint256 tokenId, bytes calldata data) external;
}
</code></pre>
<h5 id="ierc721事件">IERC721事件</h5>
<p><code>IERC721</code>包含3个事件，其中<code>Transfer</code>和<code>Approval</code>事件在<code>ERC20</code>中也有。</p>
<ul>
<li><code>Transfer</code>事件：在转账时被释放，记录代币的发出地址<code>from</code>，接收地址<code>to</code>和<code>tokenid</code>。</li>
<li><code>Approval</code>事件：在授权时释放，记录授权地址<code>owner</code>，被授权地址<code>approved</code>和<code>tokenid</code>。</li>
<li><code>ApprovalForAll</code>事件：在批量授权时释放，记录批量授权的发出地址<code>owner</code>，被授权地址<code>operator</code>和授权与否的<code>approved</code>。</li>
</ul>
<h5 id="ierc721函数">IERC721函数</h5>
<ul>
<li><code>balanceOf</code>：返回某地址的NFT持有量<code>balance</code>。</li>
<li><code>ownerOf</code>：返回某<code>tokenId</code>的主人<code>owner</code>。</li>
<li><code>transferFrom</code>：普通转账，参数为转出地址<code>from</code>，接收地址<code>to</code>和<code>tokenId</code>。</li>
<li><code>safeTransferFrom</code>：安全转账（如果接收方是合约地址，会要求实现<code>ERC721Receiver</code>接口）。参数为转出地址<code>from</code>，接收地址<code>to</code>和<code>tokenId</code>。</li>
<li><code>approve</code>：授权另一个地址使用你的NFT。参数为被授权地址<code>approve</code>和<code>tokenId</code>。</li>
<li><code>getApproved</code>：查询<code>tokenId</code>被批准给了哪个地址。</li>
<li><code>setApprovalForAll</code>：将自己持有的该系列NFT批量授权给某个地址<code>operator</code>。</li>
<li><code>isApprovedForAll</code>：查询某地址的NFT是否批量授权给了另一个<code>operator</code>地址。</li>
<li><code>safeTransferFrom</code>：安全转账的重载函数，参数里面包含了<code>data</code>。</li>
</ul>
<h5 id="什么时候使用接口">什么时候使用接口？</h5>
<p>如果我们知道一个合约实现了<code>IERC721</code>接口，我们不需要知道它具体代码实现，就可以与它交互。</p>
<p>无聊猿<code>BAYC</code>属于<code>ERC721</code>代币，实现了<code>IERC721</code>接口的功能。我们不需要知道它的源代码，只需知道它的合约地址，用<code>IERC721</code>接口就可以与它交互，比如用<code>balanceOf()</code>来查询某个地址的<code>BAYC</code>余额，用<code>safeTransferFrom()</code>来转账<code>BAYC</code>。</p>
<pre><code class="language-solidity">contract interactBAYC {
    // 利用BAYC地址创建接口合约变量（ETH主网）
    IERC721 BAYC = IERC721(0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D);

    // 通过接口调用BAYC的balanceOf()查询持仓量
    function balanceOfBAYC(address owner) external view returns (uint256 balance){
        return BAYC.balanceOf(owner);
    }

    // 通过接口调用BAYC的safeTransferFrom()安全转账
    function safeTransferFromBAYC(address from, address to, uint256 tokenId) external{
        BAYC.safeTransferFrom(from, to, tokenId);
    }
}
</code></pre>
<figure data-type="image" tabindex="48"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221110132218696.png" alt="接口实例" loading="lazy"></figure>
<h3 id="15-异常">15. 异常</h3>
<h4 id="error">Error</h4>
<p><code>error</code>是<code>solidity 0.8版本</code>新加的内容，方便且高效（省<code>gas</code>）地向用户解释操作失败的原因。人们可以在<code>contract</code>之外定义异常。下面，我们定义一个<code>TransferNotOwner</code>异常，当用户不是代币<code>owner</code>的时候尝试转账，会抛出错误：</p>
<pre><code class="language-solidity">error TransferNotOwner(); // 自定义error
</code></pre>
<p>在执行当中，<code>error</code>必须搭配<code>revert</code>（回退）命令使用。</p>
<pre><code class="language-solidity">function transferOwner1(uint256 tokenId, address newOwner) public {
    if(_owners[tokenId] != msg.sender){
    	revert TransferNotOwner();
    }
    _owners[tokenId] = newOwner;
}
</code></pre>
<p>我们定义了一个<code>transferOwner1()</code>函数，它会检查代币的<code>owner</code>是不是发起人，如果不是，就会抛出<code>TransferNotOwner</code>异常；如果是的话，就会转账。</p>
<figure data-type="image" tabindex="49"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221110134643773.png" alt="控制台抛出异常，显示自定义error" loading="lazy"></figure>
<figure data-type="image" tabindex="50"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221110135132246.png" alt="gas值消耗" loading="lazy"></figure>
<p><strong>定义参数的error</strong></p>
<figure data-type="image" tabindex="51"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221110135457383.png" alt="定义参数的error" loading="lazy"></figure>
<figure data-type="image" tabindex="52"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221110135540337.png" alt="gas值消耗" loading="lazy"></figure>
<h4 id="require">Require</h4>
<p><code>require</code>命令是<code>solidity 0.8版本</code>之前抛出异常的常用方法，目前很多主流合约仍然还在使用它。它很好用，唯一的缺点就是<code>gas</code>随着描述异常的字符串长度增加，比<code>error</code>命令要高。使用方法：<code>require(检查条件，&quot;异常的描述&quot;)</code>，当检查条件不成立的时候，就会抛出异常。</p>
<p>我们用<code>require</code>命令重写一下上面的<code>transferOwner</code>函数：</p>
<pre><code class="language-solidity">function transferOwner2(uint256 tokenId, address newOwner) public {
    require(_owners[tokenId] == msg.sender, &quot;Transfer Not Owner&quot;);
    _owners[tokenId] = newOwner;
}
</code></pre>
<figure data-type="image" tabindex="53"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221110152206293.png" alt="require以及gas值消耗" loading="lazy"></figure>
<h4 id="assert">Assert</h4>
<p><code>assert</code>命令一般用于程序员写程序<code>debug</code>，因为<strong>它不能解释抛出异常的原因</strong>（比<code>require</code>少个字符串）。它的用法很简单，<code>assert(检查条件）</code>，当检查条件不成立的时候，就会抛出异常。</p>
<p>我们用<code>assert</code>命令重写一下上面的<code>transferOwner</code>函数：</p>
<pre><code class="language-solidity">function transferOwner3(uint256 tokenId, address newOwner) public {
    assert(_owners[tokenId] == msg.sender);
    _owners[tokenId] = newOwner;
}
</code></pre>
<figure data-type="image" tabindex="54"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221110152306479.png" alt="assert 与 gas 值消耗" loading="lazy"></figure>
<p>我们比较一下三种抛出异常的<code>gas</code>消耗，通过remix控制台的Debug按钮，能查到每次函数调用的<code>gas</code>消耗分别如下：</p>
<ol>
<li><strong><code>error</code>方法<code>gas</code>消耗</strong>：24457</li>
<li><strong><code>require</code>方法<code>gas</code>消耗</strong>：24755</li>
<li><strong><code>assert</code>方法<code>gas</code>消耗</strong>：24473</li>
</ol>
<p>我们可以看到，<code>error</code>方法<code>gas</code>最少，其次是<code>assert</code>，<code>require</code>方法消耗<code>gas</code>最多！因此，<code>error</code>既可以告知用户抛出异常的原因，又能省<code>gas</code>，大家要多用！（注意，由于部署测试时间的不同，每个函数的<code>gas</code>消耗会有所不同，但是比较结果会是一致的。）</p>
<h2 id="solidity-进阶">Solidity 进阶</h2>
<h3 id="16-函数重载">16. 函数重载</h3>
<p><code>solidity</code>中允许<strong>函数</strong>进行重载（<code>overloading</code>），即<strong>名字相同但输入参数类型不同</strong>的函数可以同时存在，他们被视为不同的函数。注意，<code>solidity</code><strong>不允许</strong>修饰器（<code>modifier</code>）重载。</p>
<h4 id="函数重载">函数重载</h4>
<p>举个例子，我们可以定义两个都叫<code>saySomething()</code>的函数，一个没有任何参数，输出<code>&quot;Nothing&quot;</code>；另一个接收一个<code>string</code>参数，输出这个<code>string</code>。</p>
<pre><code class="language-solidity">function saySomething() public pure returns(string memory){
    return(&quot;Nothing&quot;);
}

function saySomething(string memory something) public pure returns(string memory){
    return(something);
}
</code></pre>
<p>最终重载函数在经过编译器编译后，由于不同的参数类型，都变成了不同的函数选择器（selector）。关于函数选择器的具体内容可参考<a href="https://github.com/AmazingAng/WTFSolidity/tree/main/29_Selector">Solidity极简入门: 29. 函数选择器Selector</a>。</p>
<p>以 <code>Overloading.sol</code> 合约为例，在 Remix 上编译部署后，分别调用重载函数 <code>saySomething()</code> 和 <code>saySomething(string memory something)</code>，可以看到他们返回了不同的结果，被区分为不同的函数。</p>
<figure data-type="image" tabindex="55"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221114220544651.png" alt="函数重载" loading="lazy"></figure>
<h4 id="实参匹配argument-matching08-后-已修复">实参匹配（Argument Matching）（0.8 后 已修复？）</h4>
<p>在调用重载函数时，会把<strong>输入的实际参数和函数参数的变量类型做匹配</strong>。 如果出现<strong>多个匹配的重载函数，则会报错</strong>。下面这个例子有两个叫<code>f()</code>的函数，一个参数为<code>uint8</code>，另一个为<code>uint256</code>：</p>
<pre><code class="language-solidity">function f(uint8 _in) public pure returns (uint8 out) {
	out = _in;
}

function f(uint256 _in) public pure returns (uint256 out) {
	out = _in;
}
</code></pre>
<p>我们调用<code>f(50)</code>，因为<code>50</code>既可以被转换为<code>uint8</code>，也可以被转换为<code>uint256</code>，<strong>因此会报错。</strong></p>
<h3 id="17-库合约">17. 库合约</h3>
<p>用<code>ERC721</code>的引用的库合约<code>String</code>为例介绍<code>solidity</code>中的库合约（<code>library</code>），并总结了常用的库函数。</p>
<h4 id="库函数">库函数</h4>
<p>库函数是一种特殊的合约，为了提升<code>solidity</code>代码的复用性和减少<code>gas</code>而存在。库合约一般都是一些好用的函数合集（<code>库函数</code>），由大神或者项目方创作，咱们站在巨人的肩膀上，会用就行了。</p>
<figure data-type="image" tabindex="56"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/HJC0UjkALdrL8a2BmAE2J.jpeg" alt="库合约：站在巨人的肩膀上" loading="lazy"></figure>
<p>这一讲，我们用<code>ERC721</code>的引用的库函数<code>String</code>为例介绍<code>solidity</code>中的库函数（<code>Library</code>）。99%的开发者都不需要自己去写库合约，会用大神写的就可以了。我们只需要知道什么情况该用什么库合约。常用的有：</p>
<ol>
<li><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Strings.sol">String</a>：将<code>uint256</code>转换为<code>String</code></li>
<li><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Address.sol">Address</a>：判断某个地址是否为合约地址</li>
<li><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Create2.sol">Create2</a>：更安全的使用<code>Create2 EVM opcode</code></li>
<li><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Arrays.sol">Arrays</a>：跟数组相关的库函数</li>
</ol>
<p>他和普通合约主要有以下几点不同：</p>
<ol>
<li><strong>不能存在状态变量</strong></li>
<li><strong>不能够继承或被继承</strong></li>
<li><strong>不能接收以太币</strong></li>
<li><strong>不可以被销毁</strong></li>
</ol>
<h4 id="string库合约">String库合约</h4>
<p><code>String库合约</code>是将<code>uint256</code>类型转换为相应的<code>string</code>类型的代码库，样例代码如下：</p>
<pre><code class="language-solidity">library Strings {
    bytes16 private constant _HEX_SYMBOLS = &quot;0123456789abcdef&quot;;

    /**
     * @dev Converts a `uint256` to its ASCII `string` decimal representation.
     */
    function toString(uint256 value) public pure returns (string memory) {
        // Inspired by OraclizeAPI's implementation - MIT licence
        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol

        if (value == 0) {
            return &quot;0&quot;;
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
     */
    function toHexString(uint256 value) public pure returns (string memory) {
        if (value == 0) {
            return &quot;0x00&quot;;
        }
        uint256 temp = value;
        uint256 length = 0;
        while (temp != 0) {
            length++;
            temp &gt;&gt;= 8;
        }
        return toHexString(value, length);
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
     */
    function toHexString(uint256 value, uint256 length) public pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = &quot;0&quot;;
        buffer[1] = &quot;x&quot;;
        for (uint256 i = 2 * length + 1; i &gt; 1; --i) {
            buffer[i] = _HEX_SYMBOLS[value &amp; 0xf];
            value &gt;&gt;= 4;
        }
        require(value == 0, &quot;Strings: hex length insufficient&quot;);
        return string(buffer);
    }
}
</code></pre>
<p>他主要包含两个函数，<code>toString()</code>将<code>uint256</code>转为<code>string</code>，<code>toHexString()</code>将<code>uint256</code>转换为<code>16进制</code>，再转换为<code>string</code>。</p>
<p>我们用String库函数的**toHexString()**来演示两种使用库合约中函数的办法。</p>
<p><strong>1. 利用using for指令</strong></p>
<p>指令<code>using A for B;</code>可用于附加库函数（从库 A）到任何类型（B）。添加完指令后，库<code>A</code>中的函数会自动添加为<code>B</code>类型变量的成员，可以直接调用。注意：在调用的时候，<strong>这个变量会被当作第一个参数传递给函数</strong>：</p>
<pre><code class="language-solidity">// 利用using for指令
using Strings for uint256;
function getString1(uint256 _number) public pure returns(string memory){
    // 库函数会自动添加为uint256型变量的成员
    return _number.toHexString();
}
</code></pre>
<p><strong>2. 通过库合约名称调用库函数</strong></p>
<pre><code class="language-solidity">// 直接通过库合约名调用
function getString2(uint256 _number) public pure returns(string memory){
    return Strings.toHexString(_number);
}
</code></pre>
<p>我们部署合约并输入<code>170</code>测试一下，两种方法均能返回正确的<code>16进制string</code> “0xaa”。证明我们调用库函数成功！</p>
<figure data-type="image" tabindex="57"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115101057935.png" alt="调用库函数测试" loading="lazy"></figure>
<h3 id="18-import">18. Import</h3>
<p><code>solidity</code>支持利用<code>import</code>关键字导入其他源代码中的合约，让开发更加模块化。</p>
<p>Solidity中import的作用是：导入其他合约中的<strong>全局符号</strong>。包括：合约、纯函数、结构体类型。</p>
<p>被导入文件中的全局符号想要被其他合约单独导入，将合约并列在文件结构中</p>
<h4 id="import用法"><code>import</code>用法</h4>
<ul>
<li>通过源文件<strong>相对位置</strong>导入，例子：</li>
</ul>
<pre><code class="language-text">文件结构
├── Import.sol
└── Yeye.sol

// 通过文件相对位置import
import './Yeye.sol';
</code></pre>
<ul>
<li>通过源文件网址导入网上的合约，例子：</li>
</ul>
<pre><code class="language-text">// 通过网址引用
import 'https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol';
</code></pre>
<ul>
<li>通过<code>npm</code>的目录导入，例子：</li>
</ul>
<pre><code class="language-solidity">import '@openzeppelin/contracts/access/Ownable.sol';
</code></pre>
<ul>
<li>通过<code>全局符号</code>导入特定的合约，例子：</li>
</ul>
<pre><code class="language-solidity">import {Yeye} from './Yeye.sol';
</code></pre>
<ul>
<li>引用(<code>import</code>)在代码中的位置为：在声明版本号之后，在其余代码之前。</li>
</ul>
<figure data-type="image" tabindex="58"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115104033293.png" alt="导入测试结果" loading="lazy"></figure>
<h3 id="19-接受eth">19. 接受ETH</h3>
<p><code>Solidity</code>支持两种特殊的回调函数，<code>receive()</code>和<code>fallback()</code>，他们主要在两种情况下被使用：</p>
<ol>
<li>接收ETH</li>
<li>处理合约中不存在的函数调用（代理合约proxy contract）</li>
</ol>
<p>注意⚠️：在solidity <strong>0.6.x版本之前</strong>，语法上只有 <code>fallback()</code> 函数，用来接收用户发送的ETH时调用以及在被调用函数签名没有匹配到时，来调用。 0.6版本之后，solidity才将 <code>fallback()</code> 函数拆分成 <code>receive()</code> 和 <code>fallback()</code> 两个函数。</p>
<p>我们这一讲主要讲接收ETH的情况。</p>
<h4 id="接收eth函数-receive">接收ETH函数 receive</h4>
<p><code>receive()</code>只用于处理<strong>接收</strong><code>ETH</code>。一个合约<strong>最多有一个</strong><code>receive()</code>函数，声明方式与一般函数不一样，<strong>不需要</strong><code>function</code>关键字：<code>receive() external payable { ... }</code>。<code>receive()</code>函数<strong>不能有任何的参数，不能返回任何值</strong>，必须包含<code>external</code>和<code>payable</code>。</p>
<p>当合约接收ETH的时候，<code>receive()</code>会被触发。<code>receive()</code>最好不要执行太多的逻辑因为如果别人用<code>send</code>和<code>transfer</code>方法发送<code>ETH</code>的话，<code>gas</code>会限制在<code>2300</code>，<code>receive()</code>太复杂可能会触发<code>Out of Gas</code>报错；如果用<code>call</code>就可以自定义<code>gas</code>执行更复杂的逻辑（这三种发送ETH的方法我们之后会讲到）。</p>
<p>我们可以在<code>receive()</code>里发送一个<code>event</code>，例如：</p>
<pre><code class="language-solidity">// 定义事件
event Received(address Sender, uint Value);
// 接收ETH时释放Received事件
receive() external payable {
	emit Received(msg.sender, msg.value);
}
</code></pre>
<p>有些恶意合约，会在<code>receive()</code> 函数（老版本的话，就是 <code>fallback()</code> 函数）嵌入恶意消耗<code>gas</code>的内容或者使得执行故意失败的代码，导致一些包含退款和转账逻辑的合约不能正常工作，因此写包含退款等逻辑的合约时候，一定要注意这种情况。</p>
<h4 id="回退函数-fallback">回退函数 fallback</h4>
<p><code>fallback()</code>函数会<strong>在调用合约不存在的函数时被触发</strong>。可用于接收ETH，也可以用于代理合约<code>proxy contract</code>。<code>fallback()</code>声明时不需要<code>function</code>关键字，必须由<code>external</code>修饰，一般也会用<code>payable</code>修饰，用于接收ETH:<code>fallback() external payable { ... }</code>。</p>
<p>我们定义一个<code>fallback()</code>函数，被触发时候会释放<code>fallbackCalled</code>事件，并输出<code>msg.sender</code>，<code>msg.value</code>和<code>msg.data</code>:</p>
<pre><code class="language-solidity">// fallback
fallback() external payable{
    emit fallbackCalled(msg.sender, msg.value, msg.data);
}
</code></pre>
<h4 id="receive和fallback的区别">receive和fallback的区别</h4>
<p><code>receive</code>和<code>fallback</code>都能够用于接收<code>ETH</code>，他们触发的规则如下：</p>
<pre><code class="language-text">触发fallback() 还是 receive()?
           接收ETH
              |
         msg.data是空？
            /  \
          是    否
          /      \
receive()存在?   fallback()
        / \
       是  否
      /     \
receive()   fallback()
</code></pre>
<p>简单来说，合约接收<code>ETH</code>时，<code>msg.data</code>为空且存在<code>receive()</code>时，会触发<code>receive()</code>；<code>msg.data</code>不为空或不存在<code>receive()</code>时，会触发<code>fallback()</code>，此时<code>fallback()</code>必须为<code>payable</code>。</p>
<p><code>receive()</code>和<code>payable fallback()</code>均不存在的时候，向合约发送<code>ETH</code>将会报错。</p>
<h4 id="remix-演示">remix 演示</h4>
<ol>
<li>
<p>首先remix部署</p>
</li>
<li>
<p>&quot;VALUE&quot; 栏中填入要发送给合约的金额（单位是 Wei），然后点击 &quot;Transact&quot;。</p>
<figure data-type="image" tabindex="59"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115105904995.png" alt="transact" loading="lazy"></figure>
</li>
<li>
<p>可以看到交易成功，并且触发了 &quot;received&quot; 事件。</p>
</li>
</ol>
<figure data-type="image" tabindex="60"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115122804262.png" alt="received事件" loading="lazy"></figure>
<ol start="4">
<li>&quot;VALUE&quot; 栏中填入要发送给合约的金额（单位是 Wei），&quot;CALLDATA&quot; 栏中填入随意编写的<code>msg.data</code>，然后点击 &quot;Transact&quot;。</li>
<li>可以看到交易成功，并且触发了 &quot;fallbackCalled&quot; 事件。</li>
</ol>
<figure data-type="image" tabindex="61"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115123025710.png" alt="fallbackCalled 事件被触发" loading="lazy"></figure>
<h3 id="20-发送eth">20. 发送ETH</h3>
<p><code>Solidity</code>有三种方法向其他合约发送<code>ETH</code>，他们是：<code>transfer()</code>，<code>send()</code>和<code>call()</code>，其中<code>call()</code>是被鼓励的用法。</p>
<ul>
<li><code>call</code>没有<code>gas</code>限制，最为灵活，是最提倡的方法；</li>
<li><code>transfer</code>有<code>2300 gas</code>限制，但是发送失败会自动<code>revert</code>交易，是次优选择；</li>
<li><code>send</code>有<code>2300 gas</code>限制，而且发送失败不会自动<code>revert</code>交易，几乎没有人用它。</li>
</ul>
<p>我们先部署一个接收<code>ETH</code>合约<code>ReceiveETH</code>。<code>ReceiveETH</code>合约里有一个事件<code>Log</code>，记录收到的<code>ETH</code>数量和<code>gas</code>剩余。还有两个函数，一个是<code>receive()</code>函数，收到<code>ETH</code>被触发，并发送<code>Log</code>事件；另一个是查询合约<code>ETH</code>余额的<code>getBalance()</code>函数。</p>
<pre><code class="language-solidity">contract ReceiveETH {
    // 收到eth事件，记录amount和gas
    event Log(uint amount, uint gas);
    
    // receive方法，接收eth时被触发
    receive() external payable{
        emit Log(msg.value, gasleft());
    }
    
    // 返回合约ETH余额
    function getBalance() view public returns(uint) {
        return address(this).balance;
    }
}
</code></pre>
<p>部署<code>ReceiveETH</code>合约后，运行<code>getBalance()</code>函数，可以看到当前合约的<code>ETH</code>余额为<code>0</code>。</p>
<figure data-type="image" tabindex="62"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115124043096.png" alt="eth余额" loading="lazy"></figure>
<p>我们将实现三种方法向<code>ReceiveETH</code>合约发送<code>ETH</code>。首先，先在发送ETH合约<code>SendETH</code>中实现<code>payable</code>的<code>构造函数</code>和<code>receive()</code>，<strong>让我们能够在部署时和部署后向合约转账</strong>。</p>
<pre><code class="language-solidity">contract SendETH {
    // 构造函数，payable使得部署的时候可以转eth进去
    constructor() payable{}
    // receive方法，接收eth时被触发
    receive() external payable{}
}
</code></pre>
<h4 id="transfer">transfer</h4>
<ul>
<li>用法是<code>接收方地址.transfer(发送ETH数额)</code>。</li>
<li><code>transfer()</code>的<code>gas</code>限制是<code>2300</code>，足够用于转账，但对方合约的<code>fallback()</code>或<code>receive()</code>函数不能实现太复杂的逻辑。</li>
<li><code>transfer()</code>如果转账失败，会自动<code>revert</code>（回滚交易）。</li>
</ul>
<p>代码样例，注意里面的<code>_to</code>填<code>ReceiveETH</code>合约的地址，<code>amount</code>是<code>ETH</code>转账金额：</p>
<pre><code class="language-solidity">// 用transfer()发送ETH
function transferETH(address payable _to, uint256 amount) external payable{
    _to.transfer(amount);
}
</code></pre>
<p>部署<code>SendETH</code>合约后，对<code>ReceiveETH</code>合约发送ETH，此时<code>amount</code>为10，<code>value</code>为0，<code>amount</code>&gt;<code>value</code>，转账失败，发生<code>revert</code>。</p>
<figure data-type="image" tabindex="63"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115124545643.png" alt="amount 大于 value，转账失败" loading="lazy"></figure>
<p>此时<code>amount</code>为10，<code>value</code>为10，<code>amount</code>&lt;=<code>value</code>，转账成功。</p>
<figure data-type="image" tabindex="64"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115125019477.png" alt="转账成功" loading="lazy"></figure>
<h4 id="send">send</h4>
<ul>
<li>用法是<code>接收方地址.send(发送ETH数额)</code>。</li>
<li><code>send()</code>的<code>gas</code>限制是<code>2300</code>，足够用于转账，但对方合约的<code>fallback()</code>或<code>receive()</code>函数不能实现太复杂的逻辑。</li>
<li><code>send()</code>如果转账失败，不会<code>revert</code>。</li>
<li><code>send()</code>的返回值是<code>bool</code>，代表着转账成功或失败，需要额外代码处理一下。</li>
</ul>
<p>代码样例：</p>
<pre><code class="language-solidity">// send()发送ETH
function sendETH(address payable _to, uint256 amount) external payable{
    // 处理下send的返回值，如果失败，revert交易并发送error
    bool success = _to.send(amount);
    if(!success){
        revert SendFailed();
    }
}
</code></pre>
<p>对<code>ReceiveETH</code>合约发送ETH，此时<code>amount</code>为10，<code>value</code>为0，<code>amount</code>&gt;<code>value</code>，转账失败，因为经过处理，所以发生<code>revert</code>。</p>
<figure data-type="image" tabindex="65"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115131454004.png" alt="send发送失败" loading="lazy"></figure>
<p>此时<code>amount</code>为10，<code>value</code>为11，<code>amount</code>&lt;=<code>value</code>，转账成功。</p>
<figure data-type="image" tabindex="66"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115131639448.png" alt="send发送成功" loading="lazy"></figure>
<h4 id="call">call</h4>
<ul>
<li>用法是<code>接收方地址.call{value: 发送ETH数额}(&quot;&quot;)</code>。</li>
<li><code>call()</code>没有<code>gas</code>限制，可以支持对方合约<code>fallback()</code>或<code>receive()</code>函数实现复杂逻辑。</li>
<li><code>call()</code>如果转账失败，不会<code>revert</code>。</li>
<li><code>call()</code>的返回值是<code>(bool, data)</code>，其中<code>bool</code>代表着转账成功或失败，需要额外代码处理一下。</li>
</ul>
<p>代码样例：</p>
<pre><code class="language-solidity">// call()发送ETH
function callETH(address payable _to, uint256 amount) external payable{
    // 处理下call的返回值，如果失败，revert交易并发送error
    (bool success,) = _to.call{value: amount}(&quot;&quot;);
    if(!success){
        revert CallFailed();
    }
}
</code></pre>
<p>对<code>ReceiveETH</code>合约发送ETH，此时<code>amount</code>为10，<code>value</code>为0，<code>amount</code>&gt;<code>value</code>，转账失败，因为经过处理，所以发生<code>revert</code>。</p>
<figure data-type="image" tabindex="67"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115125523238.png" alt="call调用失败" loading="lazy"></figure>
<p>此时<code>amount</code>为10，<code>value</code>为11，<code>amount</code>&lt;=<code>value</code>，转账成功。</p>
<figure data-type="image" tabindex="68"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115131004187.png" alt="call转账成功" loading="lazy"></figure>
<h3 id="21-调用其他合约">21. 调用其他合约</h3>
<p>开发者写智能合约来调用其他合约，这让以太坊网络上的程序<strong>可以复用</strong>，从而建立繁荣的生态。很多<code>web3</code>项目依赖于调用其他合约，比如收益农场（<code>yield farming</code>）。这一讲，我们介绍如何在已知合约代码（或接口）和地址情况下调用目标合约的函数。</p>
<h4 id="目标合约">目标合约</h4>
<p>这个合约包含一个状态变量<code>_x</code>，一个事件<code>Log</code>在收到<code>ETH</code>时触发，三个函数：</p>
<ul>
<li><code>getBalance()</code>: 返回合约<code>ETH</code>余额。</li>
<li><code>setX()</code>: <code>external payable</code>函数，可以设置<code>_x</code>的值，并向合约发送<code>ETH</code>。</li>
<li><code>getX()</code>: 读取<code>_x</code>的值</li>
</ul>
<pre><code class="language-solidity">contract OtherContract {
    uint256 private _x = 0; // 状态变量_x
    // 收到eth的事件，记录amount和gas
    event Log(uint amount, uint gas);
    
    // 返回合约ETH余额
    function getBalance() view public returns(uint) {
        return address(this).balance;
    }

    // 可以调整状态变量_x的函数，并且可以往合约转ETH (payable)
    function setX(uint256 x) external payable{
        _x = x;
        // 如果转入ETH，则释放Log事件
        if(msg.value &gt; 0){
            emit Log(msg.value, gasleft());
        }
    }

    // 读取_x
    function getX() external view returns(uint x){
        x = _x;
    }
}
</code></pre>
<h4 id="调用othercontract合约">调用OtherContract合约</h4>
<p>我们可以利用合约的地址和合约代码（或接口）来创建合约的引用：<code>_Name(_Address)</code>，其中<code>_Name</code>是合约名，<code>_Address</code>是合约地址。然后用合约的引用来调用它的函数：<code>_Name(_Address).f()</code>，其中<code>f()</code>是要调用的函数。</p>
<p>下面我们介绍4个调用合约的例子，在remix中编译合约后，分别部署<code>OtherContract</code>和<code>CallContract</code>：</p>
<h5 id="1-传入合约地址">1. 传入合约地址</h5>
<p>我们可以在函数里传入目标合约地址，生成目标合约的引用，然后调用目标函数。以调用<code>OtherContract</code>合约的<code>setX</code>函数为例，我们在新合约中写一个<code>callSetX</code>函数，传入已部署好的<code>OtherContract</code>合约地址<code>_Address</code>和<code>setX</code>的参数<code>x</code>：</p>
<pre><code class="language-solidity">function callSetX(address _Address, uint256 x) external{
    OtherContract(_Address).setX(x);
}
</code></pre>
<p>复制<code>OtherContract</code>合约的地址，填入<code>callSetX</code>函数的参数中</p>
<figure data-type="image" tabindex="69"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115133953897.png" alt="image-20221115133953897" loading="lazy"></figure>
<p>成功调用后，调用<code>OtherContract</code>合约中的<code>getX</code>验证<code>x</code>变为123</p>
<figure data-type="image" tabindex="70"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115134253074.png" alt="验证x" loading="lazy"></figure>
<h5 id="2-传入合约变量">2. 传入合约变量</h5>
<p>我们可以直接在函数里传入合约的引用，只需要把上面参数的<code>address</code>类型改为目标合约名，比如<code>OtherContract</code>。下面例子实现了调用目标合约的<code>getX()</code>函数。</p>
<p><strong>注意</strong>该函数参数<code>OtherContract _Address</code>底层类型仍然是<code>address</code>，生成的<code>ABI</code>中、调用<code>callGetX</code>时传入的参数都是<code>address</code>类型</p>
<pre><code class="language-solidity">function callGetX(OtherContract _Address) external view returns(uint x){
	x = _Address.getX();
}
</code></pre>
<p>复制<code>OtherContract</code>合约的地址，填入<code>callGetX</code>函数的参数中，调用后成功获取<code>x</code>的值</p>
<figure data-type="image" tabindex="71"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115134728806.png" alt="获取x的值" loading="lazy"></figure>
<h5 id="3-创建合约变量">3. 创建合约变量</h5>
<p>我们可以创建合约变量，然后通过它来调用目标函数。下面例子，我们给变量<code>oc</code>存储了<code>OtherContract</code>合约的引用：</p>
<pre><code class="language-solidity">function callGetX2(address _Address) external view returns(uint x){
    OtherContract oc = OtherContract(_Address);
    x = oc.getX();
}
</code></pre>
<p>复制<code>OtherContract</code>合约的地址，填入<code>callGetX2</code>函数的参数中，调用后成功获取<code>x</code>的值</p>
<figure data-type="image" tabindex="72"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115135110265.png" alt="成功获取x的值" loading="lazy"></figure>
<h5 id="4-调用合约并发送eth">4. 调用合约并发送<code>ETH</code></h5>
<p>如果目标合约的函数是<code>payable</code>的，那么我们可以通过调用它来给合约转账：<code>_Name(_Address).f{value: _Value}()</code>，其中<code>_Name</code>是合约名，<code>_Address</code>是合约地址，<code>f</code>是目标函数名，<code>_Value</code>是要转的<code>ETH</code>数额（以<code>wei</code>为单位）。</p>
<p><code>OtherContract</code>合约的<code>setX</code>函数是<code>payable</code>的，在下面这个例子中我们通过调用<code>setX</code>来往目标合约转账。</p>
<pre><code class="language-solidity">function setXTransferETH(address otherContract, uint256 x) payable external{
    OtherContract(otherContract).setX{value: msg.value}(x);
}
</code></pre>
<p>复制<code>OtherContract</code>合约的地址，填入<code>setXTransferETH</code>函数的参数中，并转入10ETH</p>
<figure data-type="image" tabindex="73"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115140121469.png" alt="setXTransferETH函数" loading="lazy"></figure>
<p>转账后，我们可以通过<code>Log</code>事件和<code>getBalance()</code>函数观察目标合约<code>ETH</code>余额的变化。</p>
<figure data-type="image" tabindex="74"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115140237100.png" alt="getBalance变化" loading="lazy"></figure>
<h3 id="22-call">22. Call</h3>
<p>利用<code>call</code>来调用合约。</p>
<p><code>call</code> 是<code>address</code>类型的低级成员函数，它用来与其他合约交互。它的返回值为<code>(bool, data)</code>，分别对应<code>call</code>是否成功以及目标函数的返回值。</p>
<ul>
<li><code>call</code>是<code>solidity</code>官方推荐的通过触发<code>fallback</code>或<code>receive</code>函数发送<code>ETH</code>的方法。</li>
<li>不推荐用<code>call</code>来调用另一个合约，因为当你调用不安全合约的函数时，你就把主动权交给了它。<strong>推荐的方法仍是声明合约变量后调用函数</strong>，见<a href="https://github.com/AmazingAng/WTFSolidity/tree/main/21_CallContract">第21讲：调用其他合约</a></li>
<li>当我们不知道对方合约的源代码或<code>ABI</code>，就没法生成合约变量；这时，我们仍可以通过<code>call</code>调用对方合约的函数。</li>
</ul>
<h4 id="call的使用规则"><code>call</code>的使用规则</h4>
<p><code>call</code>的使用规则如下：</p>
<pre><code class="language-text">目标合约地址.call(二进制编码);
</code></pre>
<p>其中<code>二进制编码</code>利用结构化编码函数<code>abi.encodeWithSignature</code>获得：</p>
<pre><code class="language-text">abi.encodeWithSignature(&quot;函数签名&quot;, 逗号分隔的具体参数)
</code></pre>
<p><code>函数签名</code>为<code>&quot;函数名（逗号分隔的参数类型)&quot;</code>。例如<code>abi.encodeWithSignature(&quot;f(uint256,address)&quot;, _x, _addr)</code>。</p>
<p>另外<code>call</code>在调用合约时可以指定交易发送的<code>ETH</code>数额和<code>gas</code>：</p>
<pre><code class="language-text">目标合约地址.call{value:发送数额, gas:gas数额}(二进制编码);
</code></pre>
<p>看起来有点复杂，下面我们举个<code>call</code>应用的例子。</p>
<h4 id="目标合约-2">目标合约</h4>
<p>我们先写一个简单的目标合约<code>OtherContract</code>并部署，代码与第19讲中基本相同，只是多了<code>fallback</code>函数。</p>
<pre><code class="language-solidity">contract OtherContract {
    uint256 private _x = 0; // 状态变量x
    // 收到eth的事件，记录amount和gas
    event Log(uint amount, uint gas);
    
    fallback() external payable{}

    // 返回合约ETH余额
    function getBalance() view public returns(uint) {
        return address(this).balance;
    }

    // 可以调整状态变量_x的函数，并且可以往合约转ETH (payable)
    function setX(uint256 x) external payable{
        _x = x;
        // 如果转入ETH，则释放Log事件
        if(msg.value &gt; 0){
            emit Log(msg.value, gasleft());
        }
    }

    // 读取x
    function getX() external view returns(uint x){
        x = _x;
    }
}
</code></pre>
<p>这个合约包含一个状态变量<code>x</code>，一个在收到<code>ETH</code>时触发的事件<code>Log</code>，三个函数：</p>
<ul>
<li><code>getBalance()</code>: 返回合约<code>ETH</code>余额。</li>
<li><code>setX()</code>: <code>external payable</code>函数，可以设置<code>x</code>的值，并向合约发送<code>ETH</code>。</li>
<li><code>getX()</code>: 读取<code>x</code>的值。</li>
</ul>
<h4 id="利用call调用目标合约">利用<code>call</code>调用目标合约</h4>
<p><strong>1. Response事件</strong></p>
<p>我们写一个<code>Call</code>合约来调用目标合约函数。首先定义一个<code>Response</code>事件，输出<code>call</code>返回的<code>success</code>和<code>data</code>，方便我们观察返回值。</p>
<pre><code class="language-solidity">// 定义Response事件，输出call返回的结果success和data
event Response(bool success, bytes data);
</code></pre>
<p><strong>2. 调用setX函数</strong></p>
<p>我们定义<code>callSetX</code>函数来调用目标合约的<code>setX()</code>，转入<code>msg.value</code>数额的<code>ETH</code>，并释放<code>Response</code>事件输出<code>success</code>和<code>data</code>：</p>
<pre><code class="language-solidity">function callSetX(address payable _addr, uint256 x) public payable {
    // call setX()，同时可以发送ETH
    (bool success, bytes memory data) = _addr.call{value: msg.value}(
        abi.encodeWithSignature(&quot;setX(uint256)&quot;, x)
    );

    emit Response(success, data); //释放事件
}
</code></pre>
<p>接下来我们调用<code>callSetX</code>把状态变量<code>_x</code>改为5，参数为<code>OtherContract</code>地址和<code>5</code>，由于目标函数<code>setX()</code>没有返回值，因此<code>Response</code>事件输出的<code>data</code>为<code>0x</code>，也就是空。</p>
<figure data-type="image" tabindex="75"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115143818700.png" alt="调用set函数成功" loading="lazy"></figure>
<p><strong>3. 调用getX函数</strong></p>
<p>下面我们调用<code>getX()</code>函数，它将返回目标合约<code>_x</code>的值，类型为<code>uint256</code>。我们可以利用<code>abi.decode</code>来解码<code>call</code>的返回值<code>data</code>，并读出数值。</p>
<pre><code class="language-solidity">function callGetX(address _addr) external returns(uint256){
    // call getX()
    (bool success, bytes memory data) = _addr.call(
        abi.encodeWithSignature(&quot;getX()&quot;)
    );

    emit Response(success, data); //释放事件
    return abi.decode(data, (uint256));
}
</code></pre>
<p>从<code>Response</code>事件的输出，我们可以看到<code>data</code>为<code>0x0000000000000000000000000000000000000000000000000000000000000005</code>。而经过<code>abi.decode</code>，最终返回值为<code>5</code>。</p>
<figure data-type="image" tabindex="76"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115144414577.png" alt="call调用getX函数" loading="lazy"></figure>
<p><strong>4. 调用不存在的函数</strong></p>
<p>如果我们给<code>call</code>输入的函数不存在于目标合约，那么目标合约的<code>fallback</code>函数会被触发。</p>
<pre><code class="language-solidity">function callNonExist(address _addr) external{
    // call getX()
    (bool success, bytes memory data) = _addr.call(
        abi.encodeWithSignature(&quot;foo(uint256)&quot;)
    );

    emit Response(success, data); //释放事件
}
</code></pre>
<p>上面例子中，我们<code>call</code>了不存在的<code>foo</code>函数。<code>call</code>仍能执行成功，并返回<code>success</code>，但其实调用的目标合约<code>fallback</code>函数。</p>
<figure data-type="image" tabindex="77"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115144610997.png" alt="call调用不存在的函数" loading="lazy"></figure>
<h3 id="23-delegatecall">23. Delegatecall</h3>
<p><code>delegatecall</code>与<code>call</code>类似，是<code>solidity</code>中地址类型的<strong>低级成员函数</strong>。<code>delegate</code>中是委托/代表的意思，那么<code>delegatecall</code>委托了什么？<code>B call C</code>，语境为<code>C</code>；而<code>B delegatecall C</code>，语境为<code>B</code>。</p>
<p>当用户<code>A</code>通过合约<code>B</code>来<code>call</code>合约<code>C</code>的时候，执行的是合约<code>C</code>的函数，<code>语境</code>(<code>Context</code>，可以理解为包含变量和状态的环境)也是合约<code>C</code>的：<code>msg.sender</code>是<code>B</code>的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约<code>C</code>的变量上。</p>
<figure data-type="image" tabindex="78"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115150244163.png" alt="普通call" loading="lazy"></figure>
<p>而当用户<code>A</code>通过合约<code>B</code>来<code>delegatecall</code>合约<code>C</code>的时候，执行的是合约<code>C</code>的函数，但是<code>语境</code>仍是合约<code>B</code>的：<code>msg.sender</code>是<code>A</code>的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约<code>B</code>的变量上。</p>
<figure data-type="image" tabindex="79"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115150344469.png" alt="delegatecall" loading="lazy"></figure>
<p>大家可以这样理解：一个<code>富商</code>把它的资产（<code>状态变量</code>）都交给一个<code>VC</code>代理（<code>目标合约</code>的函数）来打理。执行的是<code>VC</code>的函数，但是改变的是<code>富商</code>的状态。</p>
<p><code>delegatecall</code>语法和<code>call</code>类似，也是：</p>
<pre><code class="language-solidity">目标合约地址.delegatecall(二进制编码);
</code></pre>
<p>其中<code>二进制编码</code>利用结构化编码函数<code>abi.encodeWithSignature</code>获得：</p>
<pre><code class="language-solidity">abi.encodeWithSignature(&quot;函数签名&quot;, 逗号分隔的具体参数)
</code></pre>
<p><code>函数签名</code>为<code>&quot;函数名（逗号分隔的参数类型)&quot;</code>。例如<code>abi.encodeWithSignature(&quot;f(uint256,address)&quot;, _x, _addr)</code>。</p>
<p>和<code>call</code>不一样，<code>delegatecall</code>在调用合约时可以<strong>指定交易发送的</strong><code>gas</code>，但不能指定发送的<code>ETH</code>数额</p>
<blockquote>
<p><strong>注意</strong>：<code>delegatecall</code>有安全隐患，使用时要保证当前合约和目标合约的<strong>状态变量存储结构相同</strong>，并且目标合约安全，不然会造成资产损失。<strong>(变量名可以不同，变量类型、声明顺序必须相同)</strong></p>
</blockquote>
<h4 id="什么情况下会用到delegatecall">什么情况下会用到<code>delegatecall</code>?</h4>
<p>目前<code>delegatecall</code>主要有两个应用场景：</p>
<ol>
<li>代理合约（<code>Proxy Contract</code>）：将智能合约的存储合约和逻辑合约分开：代理合约（<code>Proxy Contract</code>）存储所有相关的变量，并且保存逻辑合约的地址；所有函数存在逻辑合约（<code>Logic Contract</code>）里，通过<code>delegatecall</code>执行。当升级时，只需要将代理合约指向新的逻辑合约即可。</li>
<li>EIP-2535 Diamonds（钻石）：钻石是一个支持构建可在生产中扩展的模块化智能合约系统的标准。钻石是具有多个实施合同的代理合同。 更多信息请查看：<a href="https://eip2535diamonds.substack.com/p/introduction-to-the-diamond-standard">钻石标准简介</a>。</li>
</ol>
<h4 id="delegatecall例子"><code>delegatecall</code>例子</h4>
<p>调用结构：你（<code>A</code>）通过合约<code>B</code>调用目标合约<code>C</code>。</p>
<h5 id="被调用的合约c">被调用的合约C</h5>
<p>我们先写一个简单的目标合约<code>C</code>：有两个<code>public</code>变量：<code>num</code>和<code>sender</code>，分别是<code>uint256</code>和<code>address</code>类型；有一个函数，可以将<code>num</code>设定为传入的<code>_num</code>，并且将<code>sender</code>设为<code>msg.sender</code>。</p>
<pre><code class="language-solidity">// 被调用的合约C
contract C {
    uint public num;
    address public sender;

    function setVars(uint _num) public payable {
        num = _num;
        sender = msg.sender;
    }
}
</code></pre>
<h5 id="发起调用的合约b">发起调用的合约B</h5>
<p>首先，合约<code>B</code>必须和目标合约<code>C</code>的变量存储布局必须相同，两个变量，并且顺序为<code>num</code>和<code>sender</code></p>
<pre><code class="language-solidity">contract B {
    uint public num;
    address public sender;
</code></pre>
<p>接下来，我们分别用<code>call</code>和<code>delegatecall</code>来调用合约<code>C</code>的<code>setVars</code>函数，更好的理解它们的区别。</p>
<p><code>callSetVars</code>函数通过<code>call</code>来调用<code>setVars</code>。它有两个参数<code>_addr</code>和<code>_num</code>，分别对应合约<code>C</code>的地址和<code>setVars</code>的参数。</p>
<pre><code class="language-solidity">    // 通过call来调用C的setVars()函数，将改变合约C里的状态变量
    function callSetVars(address _addr, uint _num) external payable{
        // call setVars()
        (bool success, bytes memory data) = _addr.call(
            abi.encodeWithSignature(&quot;setVars(uint256)&quot;, _num)
        );
    }
</code></pre>
<p>而<code>delegatecallSetVars</code>函数通过<code>delegatecall</code>来调用<code>setVars</code>。与上面的<code>callSetVars</code>函数相同，有两个参数<code>_addr</code>和<code>_num</code>，分别对应合约<code>C</code>的地址和<code>setVars</code>的参数。</p>
<pre><code class="language-solidity">    // 通过delegatecall来调用C的setVars()函数，将改变合约B里的状态变量
    function delegatecallSetVars(address _addr, uint _num) external payable{
        // delegatecall setVars()
        (bool success, bytes memory data) = _addr.delegatecall(
            abi.encodeWithSignature(&quot;setVars(uint256)&quot;, _num)
        );
    }
}
</code></pre>
<h5 id="remix-验证">remix 验证</h5>
<ol>
<li>首先，我们把合约<code>B</code>和<code>C</code>都部署好</li>
</ol>
<figure data-type="image" tabindex="80"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115151932843.png" alt="部署B C" loading="lazy"></figure>
<ol start="2">
<li>部署之后，查看<code>C</code>合约状态变量的初始值，<code>B</code>合约的状态变量也是一样。</li>
</ol>
<figure data-type="image" tabindex="81"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115152046534.png" alt="B C 合约的初始值和状态变量" loading="lazy"></figure>
<ol start="3">
<li>此时，调用合约<code>B</code>中的<code>callSetVars</code>，传入参数为合约<code>C</code>地址和<code>10</code>，运行后，合约<code>C</code>中的状态变量将被修改：<code>num</code>被改为<code>10</code>，<code>sender</code>变为合约<code>B</code>的地址</li>
</ol>
<figure data-type="image" tabindex="82"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115152539058.png" alt="call" loading="lazy"></figure>
<ol start="4">
<li>接下来，我们调用合约<code>B</code>中的<code>delegatecallSetVars</code>，传入参数为合约<code>C</code>地址和<code>123</code>。由于是<code>delegatecall</code>，语境为合约<code>B</code>。在运行后，合约<code>B</code>中的状态变量将被修改：<code>num</code>被改为<code>123</code>，<code>sender</code>变为你的钱包地址。合约<code>C</code>中的状态变量不会被修改。</li>
</ol>
<figure data-type="image" tabindex="83"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115152925951.png" alt="delegatecall" loading="lazy"></figure>
<h3 id="24-create">24. Create</h3>
<p>在以太坊链上，用户（外部账户，<code>EOA</code>）可以创建智能合约，智能合约同样也可以创建新的智能合约。去中心化交易所<code>uniswap</code>就是利用工厂合约（<code>Factory</code>）创建了无数个币对合约（<code>Pair</code>）。这一讲，我会用简化版的<code>uniswap</code>讲如何通过合约创建合约。</p>
<h4 id="create和create2"><code>create</code>和<code>create2</code></h4>
<p>有两种方法可以在合约中创建新合约，<code>create</code>和<code>create2</code>，这里我们讲<code>create</code>，下一讲会介绍<code>create2</code>。</p>
<p><code>create</code>的用法很简单，就是<code>new</code>一个合约，并传入新合约构造函数所需的参数：</p>
<pre><code class="language-solidity">Contract x = new Contract{value: _value}(params)
</code></pre>
<p>其中<code>Contract</code>是要创建的合约名，<code>x</code>是合约对象（地址），如果构造函数是<code>payable</code>，可以创建时转入<code>_value</code>数量的<code>ETH</code>，<code>params</code>是<strong>新合约构造函数的参数。</strong></p>
<h4 id="极简uniswap">极简Uniswap</h4>
<p><code>Uniswap V2</code><a href="https://github.com/Uniswap/v2-core/tree/master/contracts">核心合约</a>中包含两个合约：</p>
<ol>
<li>UniswapV2Pair: <strong>币对合约</strong>，用于管理币对地址、流动性、买卖。</li>
<li>UniswapV2Factory: <strong>工厂合约</strong>，用于<strong>创建新的币对</strong>，并管理币对地址。</li>
</ol>
<p>下面我们用<code>create</code>方法实现一个极简版的<code>Uniswap</code>：<code>Pair</code>币对合约负<strong>责管理币对地址</strong>，<code>PairFactory</code>工厂合约<strong>用于创建新的币对</strong>，并管理币对地址。</p>
<h4 id="pair合约"><code>Pair</code>合约</h4>
<pre><code class="language-solidity">contract Pair{
    address public factory; // 工厂合约地址
    address public token0; // 代币1
    address public token1; // 代币2

    constructor() payable {
        factory = msg.sender;
    }

    // called once by the factory at time of deployment
    function initialize(address _token0, address _token1) external {
        require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check
        token0 = _token0;
        token1 = _token1;
    }
}
</code></pre>
<p><code>Pair</code>合约很简单，包含3个状态变量：<code>factory</code>，<code>token0</code>和<code>token1</code>。</p>
<p>构造函数<code>constructor</code>在部署时将<code>factory</code>赋值<strong>为工厂合约地址</strong>。<code>initialize</code>函数会在<code>Pair</code>合约创建的时候被工厂合约调用一次，将<code>token0</code>和<code>token1</code>更新为币对中两种代币的地址。</p>
<blockquote>
<p><strong>提问</strong>：为什么<code>uniswap</code>不在<code>constructor</code>中将<code>token0</code>和<code>token1</code>地址更新好？</p>
<p><strong>答</strong>：因为<code>uniswap</code>使用的是<code>create2</code>创建合约，限制构造函数不能有参数。当使用<code>create</code>时，<code>Pair</code>合约允许构造函数有参数，可以在<code>constructor</code>中将<code>token0</code>和<code>token1</code>地址更新好。</p>
</blockquote>
<h4 id="pairfactory"><code>PairFactory</code></h4>
<p>1个工厂合约PairFactory创建Pair合约的最大数量一般由什么决定？<strong>PairFactory合约逻辑</strong></p>
<pre><code class="language-solidity">contract PairFactory{
    mapping(address =&gt; mapping(address =&gt; address)) public getPair; // 通过两个代币地址查Pair地址
    address[] public allPairs; // 保存所有Pair地址

    function createPair(address tokenA, address tokenB) external returns (address pairAddr) {
        // 创建新合约
        Pair pair = new Pair(); 
        // 调用新合约的initialize方法
        pair.initialize(tokenA, tokenB);
        // 更新地址map
        pairAddr = address(pair);
        allPairs.push(pairAddr);
        getPair[tokenA][tokenB] = pairAddr;
        getPair[tokenB][tokenA] = pairAddr;
    }
}
</code></pre>
<p>工厂合约（<code>PairFactory</code>）有两个状态变量<code>getPair</code>是两个代币地址到币对地址的<code>map</code>，方便根据代币找到币对地址；<code>allPairs</code>是币对地址的数组，存储了所有代币地址。</p>
<p><code>PairFactory</code>合约只有一个<code>createPair</code>函数，根据输入的两个代币地址<code>tokenA</code>和<code>tokenB</code>来创建新的<code>Pair</code>合约。其中</p>
<pre><code class="language-solidity">Pair pair = new Pair(); 
</code></pre>
<p>就是创建合约的代码，非常简单。大家可以部署好<code>PairFactory</code>合约，然后用下面两个地址作为参数调用<code>createPair</code>，看看创建的币对地址是什么：</p>
<pre><code class="language-text">WBNB地址: 0x2c44b726ADF1963cA47Af88B284C06f30380fC78
BSC链上的PEOPLE地址:
0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c
</code></pre>
<h4 id="在remix上验证-2">在remix上验证</h4>
<ol>
<li>使用<code>WBNB</code>和<code>PEOPLE</code>的地址作为参数调用<code>createPair</code>,得到<code>Pair</code>合约地址：{ &quot;0&quot;: &quot;address: pairAddr 0x72986C3fE625a2a6908327F96b681422C528E754&quot; }</li>
</ol>
<figure data-type="image" tabindex="84"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115163115424.png" alt="pair地址" loading="lazy"></figure>
<ol start="2">
<li>查看<code>Pair</code>合约变量</li>
</ol>
<figure data-type="image" tabindex="85"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115163149873.png" alt="部署pair合约" loading="lazy"></figure>
<ol start="3">
<li>查看pair合约变量</li>
</ol>
<figure data-type="image" tabindex="86"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115163259762.png" alt="查看pari合约变量" loading="lazy"></figure>
<ol start="5">
<li>debug 查看操作码</li>
</ol>
<figure data-type="image" tabindex="87"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115163653380.png" alt="操作码" loading="lazy"></figure>
<h3 id="25-create2">25. Create2</h3>
<p><code>CREATE2</code> 操作码使我们在智能合约部署在以太坊网络之前就能预测合约的地址。<code>Uniswap</code>创建<code>Pair</code>合约用的就是<code>CREATE2</code>而不是<code>CREATE</code>。</p>
<h4 id="create如何计算地址">CREATE如何计算地址</h4>
<p>智能合约可以由其他合约和普通账户利用<code>CREATE</code>操作码创建。 在这两种情况下，新合约的地址都以相同的方式计算：创建者的地址(通常为部署的钱包地址或者合约地址)和<code>nonce</code>(该地址发送交易的总数,对于合约账户是创建的合约总数,每创建一个合约nonce+1))的哈希。</p>
<pre><code class="language-text">新地址 = hash(创建者地址, nonce)
</code></pre>
<p>创建者地址不会变，但<code>nonce</code>可能会随时间而改变，因此用<code>CREATE</code>创建的合约地址不好预测。</p>
<h4 id="create2如何计算地址">CREATE2如何计算地址</h4>
<p><code>CREATE2</code>的目的是为了让合约地址独立于未来的事件。不管未来区块链上发生了什么，你都可以把合约部署在事先计算好的地址上。用<code>CREATE2</code>创建的合约地址由4个部分决定：</p>
<ul>
<li><code>0xFF</code>：一个常数，避免和<code>CREATE</code>冲突</li>
<li>创建者地址</li>
<li><code>salt</code>（盐）：<strong>一个创建者给定的数值</strong></li>
<li><strong>待部署合约的字节码</strong>（<code>bytecode</code>）</li>
</ul>
<pre><code class="language-text">新地址 = hash(&quot;0xFF&quot;,创建者地址, salt, bytecode)
</code></pre>
<p><code>CREATE2</code> 确保，如果创建者使用 <code>CREATE2</code> 和提供的 <code>salt</code> 部署给定的合约<code>bytecode</code>，它将存储在 <code>新地址</code> 中。</p>
<h4 id="如何使用create2">如何使用<code>CREATE2</code></h4>
<p><code>CREATE2</code>的用法和之前讲的<code>Create</code>类似，同样是<code>new</code>一个合约，并传入新合约构造函数所需的参数，只不过要多传一个<code>salt</code>参数：</p>
<pre><code class="language-text">Contract x = new Contract{salt: _salt, value: _value}(params)
</code></pre>
<p>其中<code>Contract</code>是要创建的合约名，<code>x</code>是合约对象（地址），<code>_salt</code>是指定的盐；如果构造函数是<code>payable</code>，可以创建时转入<code>_value</code>数量的<code>ETH</code>，<code>params</code>是新合约构造函数的参数。</p>
<h5 id="极简uniswap2">极简Uniswap2</h5>
<p>跟<a href="https://mirror.xyz/dashboard/edit/kojopp2CgDK3ehHxXc_2fkZe87uM0O5OmsEU6y83eJs">上一讲</a>类似，我们用<code>Create2</code>来实现极简<code>Uniswap</code>。</p>
<h5 id="pair"><code>Pair</code></h5>
<pre><code class="language-solidity">contract Pair{
    address public factory; // 工厂合约地址
    address public token0; // 代币1
    address public token1; // 代币2

    constructor() payable {
        factory = msg.sender;
    }

    // called once by the factory at time of deployment
    function initialize(address _token0, address _token1) external {
        require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check
        token0 = _token0;
        token1 = _token1;
    }
}
</code></pre>
<p><code>Pair</code>合约很简单，包含3个状态变量：<code>factory</code>，<code>token0</code>和<code>token1</code>。</p>
<p>构造函数<code>constructor</code>在部署时将<code>factory</code>赋值为工厂合约地址。<code>initialize</code>函数会在<code>Pair</code>合约创建的时候被工厂合约调用一次，将<code>token0</code>和<code>token1</code>更新为币对中两种代币的地址。</p>
<h5 id="pairfactory2"><code>PairFactory2</code></h5>
<pre><code class="language-solidity">contract PairFactory2{
    mapping(address =&gt; mapping(address =&gt; address)) public getPair; // 通过两个代币地址查Pair地址
    address[] public allPairs; // 保存所有Pair地址

    function createPair2(address tokenA, address tokenB) external returns (address pairAddr) {
        require(tokenA != tokenB, 'IDENTICAL_ADDRESSES'); //避免tokenA和tokenB相同产生的冲突
        // 计算用tokenA和tokenB地址计算salt
        (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); 
        //将tokenA和tokenB按大小排序
        bytes32 salt = keccak256(abi.encodePacked(token0, token1));
        // 用create2部署新合约
        Pair pair = new Pair{salt: salt}(); 
        // 调用新合约的initialize方法
        pair.initialize(tokenA, tokenB);
        // 更新地址map
        pairAddr = address(pair);
        allPairs.push(pairAddr);
        getPair[tokenA][tokenB] = pairAddr;
        getPair[tokenB][tokenA] = pairAddr;
	}
</code></pre>
<p>工厂合约（<code>PairFactory2</code>）有两个状态变量<code>getPair</code>是两个代币地址到币对地址的<code>map</code>，方便根据代币找到币对地址；<code>allPairs</code>是币对地址的数组，存储了所有币对地址。</p>
<p><code>PairFactory2</code>合约只有一个<code>createPair2</code>函数，使用<code>CREATE2</code>根据输入的两个代币地址<code>tokenA</code>和<code>tokenB</code>来创建新的<code>Pair</code>合约。其中</p>
<pre><code class="language-solidity">    Pair pair = new Pair{salt: salt}(); 
</code></pre>
<p>就是利用<code>CREATE2</code>创建合约的代码，非常简单，而<code>salt</code>为<code>token1</code>和<code>token2</code>的<code>hash</code>：</p>
<pre><code class="language-solidity">	bytes32 salt = keccak256(abi.encodePacked(token0, token1));
</code></pre>
<h5 id="事先计算pair地址">事先计算<code>Pair</code>地址</h5>
<pre><code class="language-solidity">// 提前计算pair合约地址
function calculateAddr(address tokenA, address tokenB) public view returns(address predictedAddress){
    require(tokenA != tokenB, 'IDENTICAL_ADDRESSES'); //避免tokenA和tokenB相同产生的冲突
    // 计算用tokenA和tokenB地址计算salt
    (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); 
    //将tokenA和tokenB按大小排序
    bytes32 salt = keccak256(abi.encodePacked(token0, token1));
    // 计算合约地址方法 hash()
    predictedAddress = address(uint160(uint(keccak256(abi.encodePacked(
        bytes1(0xff),
        address(this),
        salt,
        keccak256(type(Pair).creationCode)
    )))));
}
</code></pre>
<p>我们写了一个<code>calculateAddr</code>函数来事先计算<code>tokenA</code>和<code>tokenB</code>将会生成的<code>Pair</code>地址。通过它，我们可以验证我们事先计算的地址和实际地址是否相同。</p>
<p>大家可以部署好<code>PairFactory2</code>合约，然后用下面两个地址作为参数调用<code>createPair2</code>，看看创建的币对地址是什么，是否与事先计算的地址一样：</p>
<pre><code class="language-text">WBNB地址: 0x2c44b726ADF1963cA47Af88B284C06f30380fC78
BSC链上的PEOPLE地址:
0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c
</code></pre>
<h4 id="在remix上验证-3">在remix上验证</h4>
<ol>
<li>首先用<code>WBNB</code>和<code>PEOPLE</code>的地址哈希作为<code>salt</code>来计算出<code>Pair</code>合约的地址（）</li>
<li>调用<code>PairFactory2.createPair2</code>传入参数为<code>WBNB</code>和<code>PEOPLE</code>的地址，获取出创建的<code>pair</code>合约地址</li>
<li>对比合约地址</li>
</ol>
<figure data-type="image" tabindex="88"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115171028495.png" alt="create2交易对地址" loading="lazy"></figure>
<h4 id="create2的实际应用场景">create2的实际应用场景</h4>
<ol>
<li>交易所为新用户预留创建钱包合约地址。</li>
<li>由 <code>CREATE2</code> 驱动的 <code>factory</code> 合约，在<code>uniswapV2</code>中交易对的创建是在 <code>Factory</code>中调用<code>create2</code>完成。这样做的好处是: 它可以得到一个确定的<code>pair</code>地址, 使得 <code>Router</code>中就可以通过 <code>(tokenA, tokenB)</code> 计算出<code>pair</code>地址, 不再需要执行一次 <code>Factory.getPair(tokenA, tokenB)</code> 的跨合约调用。</li>
</ol>
<h3 id="26-删除合约">26. 删除合约</h3>
<p><code>selfdestruct</code>命令可以用来删除智能合约，并将该合约剩余<code>ETH</code>转到指定地址。<code>selfdestruct</code>是为了应对合约出错的极端情况而设计的。它最早被命名为<code>suicide</code>（自杀），但是这个词太敏感。为了保护抑郁的程序员，改名为<code>selfdestruct</code>。</p>
<h4 id="如何使用selfdestruct">如何使用<code>selfdestruct</code></h4>
<p><code>selfdestruct</code>使用起来非常简单：</p>
<pre><code class="language-solidity">selfdestruct(_addr)；
</code></pre>
<p>其中<code>_addr</code>是<strong>接收合约</strong>中剩余<code>ETH</code>的地址。</p>
<h4 id="例子">例子</h4>
<pre><code class="language-solidity">contract DeleteContract {

    uint public value = 10;

    constructor() payable {}

    receive() external payable {}

    function deleteContract() external {
        // 调用selfdestruct销毁合约，并把剩余的ETH转给msg.sender
        selfdestruct(payable(msg.sender));
    }

    function getBalance() external view returns(uint balance){
        balance = address(this).balance;
    }
}
</code></pre>
<p>在<code>DeleteContract</code>合约中，我们写了一个<code>public</code>状态变量<code>value</code>，两个函数：<code>getBalance()</code>用于获取合约<code>ETH</code>余额，<code>deleteContract()</code>用于自毁合约，并把<code>ETH</code>转入给发起人。</p>
<p>部署好合约后，我们向<code>DeleteContract</code>合约转入1 <code>ETH</code>。这时，<code>getBalance()</code>会返回1 <code>ETH</code>，<code>value</code>变量是10。</p>
<p>当我们调用<code>deleteContract()</code>函数，合约将自毁，所有变量都清空，此时<code>value</code>变为默认值<code>0</code>，<code>getBalance()</code>也返回空值。</p>
<h4 id="注意事项">注意事项</h4>
<ol>
<li>对外提供合约销毁接口时，最好设置为只有合约所有者可以调用，可以使用函数修饰符<code>onlyOwner</code>进行函数声明。</li>
<li>当合约被销毁后与智能合约的交互也能成功，并且返回0。</li>
<li>当合约中有<code>selfdestruct</code>功能时常常会带来安全问题和信任问题，合约中的Selfdestruct功能会为攻击者打开攻击向量(例如使用<code>selfdestruct</code>向一个合约频繁转入token进行攻击，这将大大节省了GAS的费用，虽然很少人这么做)，此外，此功能还会降低用户对合约的信心。</li>
</ol>
<h4 id="在remix上验证-4">在remix上验证</h4>
<ol>
<li>部署合约并且转入1ETH，查看合约状态</li>
</ol>
<figure data-type="image" tabindex="89"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115182843256.png" alt="转1ETH" loading="lazy"></figure>
<ol start="2">
<li>销毁合约，查看合约状态</li>
</ol>
<figure data-type="image" tabindex="90"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115183016707.png" alt="调用合约" loading="lazy"></figure>
<h3 id="27-abi-编码解码">27. ABI 编码解码</h3>
<p><code>ABI</code> (Application Binary Interface，应用二进制接口)是与以太坊智能合约交互的标准。数据基于他们的类型编码；并且由于编码后不包含类型信息，解码时需要注明它们的类型。</p>
<p><code>Solidity</code>中，<code>ABI编码</code>有4个函数：<code>abi.encode</code>, <code>abi.encodePacked</code>, <code>abi.encodeWithSignature</code>, <code>abi.encodeWithSelector</code>。而<code>ABI解码</code>有1个函数：<code>abi.decode</code>，用于解码<code>abi.encode</code>的数据。这一讲，我们将学习如何使用这些函数。</p>
<h4 id="abi编码">ABI编码</h4>
<p>我们将用编码4个变量，他们的类型分别是<code>uint256</code>, <code>address</code>, <code>string</code>, <code>uint256[2]</code>：</p>
<pre><code class="language-solidity">uint x = 10;
address addr = 0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71;
string name = &quot;0xAA&quot;;
uint[2] array = [5, 6]; 
</code></pre>
<h5 id="abiencode"><code>abi.encode</code></h5>
<p>将给定参数利用<a href="https://learnblockchain.cn/docs/solidity/abi-spec.html">ABI规则</a>编码。<code>ABI</code>被设计出来跟智能合约交互，他将每个参数填充为32字节的数据，并拼接在一起。如果你要和合约交互，你要用的就是<code>abi.encode</code>。</p>
<pre><code class="language-solidity">function encode() public view returns(bytes memory result) {
	result = abi.encode(x, addr, name, array);
}
</code></pre>
<p>编码的结果为<code>0x000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007a58c0be72be218b41c608b7fe7c5bb630736c7100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000043078414100000000000000000000000000000000000000000000000000000000</code>，由于<code>abi.encode</code>将每个数据都填充为32字节，中间有很多<code>0</code>。</p>
<h5 id="abiencodepacked"><code>abi.encodePacked</code></h5>
<p>将给定参数根据其所需最低空间编码。它类似 <code>abi.encode</code>，但是会把其中填充的很多<code>0</code>省略。比如，只用1字节来编码<code>uint</code>类型。当你想省空间，并且<strong>不与合约交互的时候</strong>，可以使用<code>abi.encodePacked</code>，例如算一些数据的<code>hash</code>时。</p>
<pre><code class="language-solidity">function encodePacked() public view returns(bytes memory result) {
	result = abi.encodePacked(x, addr, name, array);
}
</code></pre>
<p>编码的结果为<code>0x000000000000000000000000000000000000000000000000000000000000000a7a58c0be72be218b41c608b7fe7c5bb630736c713078414100000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000006</code>，由于<code>abi.encodePacked</code>对编码进行了压缩，长度比<code>abi.encode</code>短很多。</p>
<h5 id="abiencodewithsignature"><code>abi.encodeWithSignature</code></h5>
<p>与<code>abi.encode</code>功能类似，只不过第一个参数为<code>函数签名</code>，比如<code>&quot;foo(uint256,address)&quot;</code>。当调用其他合约的时候可以使用。</p>
<pre><code class="language-solidity">function encodeWithSignature() public view returns(bytes memory result) {
	result = abi.encodeWithSignature(&quot;foo(uint256,address,string,uint256[2])&quot;, x, addr, name, array);
}
</code></pre>
<p>编码的结果为<code>0xe87082f1000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007a58c0be72be218b41c608b7fe7c5bb630736c7100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000043078414100000000000000000000000000000000000000000000000000000000</code>，等同于在<code>abi.encode</code>编码结果前加上了4字节的<code>函数选择器</code><a href="https://wtf.academy/solidity-advanced/ABIEncode/#fn-%E8%AF%B4%E6%98%8E">说明</a>。 <a href="https://wtf.academy/solidity-advanced/ABIEncode/#fn-%E8%AF%B4%E6%98%8E">说明</a>: 函数选择器就是通过函数名和参数进行签名处理(Keccak–Sha3)来标识函数，可以用于不同合约之间的函数调用</p>
<h5 id="abiencodewithselector"><code>abi.encodeWithSelector</code></h5>
<p>与<code>abi.encodeWithSignature</code>功能类似，只不过第一个参数为<code>函数选择器</code>，为<code>函数签名</code>Keccak哈希<strong>的前4个字节。</strong></p>
<pre><code class="language-solidity">function encodeWithSelector() public view returns(bytes memory result) {
	result = abi.encodeWithSelector(bytes4(keccak256(&quot;foo(uint256,address,string,uint256[2])&quot;)), x, addr, name, array);
}
</code></pre>
<p>编码的结果为<code>0xe87082f1000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007a58c0be72be218b41c608b7fe7c5bb630736c7100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000043078414100000000000000000000000000000000000000000000000000000000</code>，与<code>abi.encodeWithSignature</code>结果一样。</p>
<h4 id="abi解码">ABI解码</h4>
<h5 id="abidecode"><code>abi.decode</code></h5>
<p><code>abi.decode</code>用于解码<code>abi.encode</code>生成的二进制编码，将它还原成原本的参数。</p>
<pre><code class="language-solidity">function decode(bytes memory data) public pure returns(uint dx, address daddr, string memory dname, uint[2] memory darray) {
	(dx, daddr, dname, darray) = abi.decode(data, (uint, address, string, uint[2]));
}
</code></pre>
<p>我们将<code>abi.encode</code>的二进制编码输入给<code>decode</code>，将解码出原来的参数：</p>
<figure data-type="image" tabindex="91"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115184805769.png" alt="decode" loading="lazy"></figure>
<h4 id="abi的使用场景">ABI的使用场景</h4>
<ol>
<li>在合约开发中，ABI常配合call来实现对合约的底层调用。</li>
</ol>
<pre><code class="language-solidity">bytes4 selector = contract.getValue.selector;

bytes memory data = abi.encodeWithSelector(selector, _x);
(bool success, bytes memory returnedData) = address(contract).staticcall(data);
require(success);

return abi.decode(returnedData, (uint256));
</code></pre>
<ol start="2">
<li>ethers.js中常用ABI实现合约的导入和函数调用。</li>
</ol>
<pre><code class="language-solidity">const wavePortalContract = new ethers.Contract(contractAddress, contractABI, signer);
/*
* Call the getAllWaves method from your Smart Contract
*/
const waves = await wavePortalContract.getAllWaves();
</code></pre>
<h3 id="28-hash">28. Hash</h3>
<p>哈希函数（hash function）是一个密码学概念，它可以将任意长度的消息转换为一个固定长度的值，这个值也称作哈希（hash）。这一讲，我们简单介绍一下哈希函数及在<code>solidity</code>的应用</p>
<h4 id="hash的性质">Hash的性质</h4>
<p>一个好的哈希函数应该具有以下几个特性：</p>
<ul>
<li>单向性：从输入的消息到它的哈希的正向运算简单且唯一确定，而反过来非常难，只能靠暴力枚举。</li>
<li>灵敏性：输入的消息<strong>改变一点对它的哈希改变很大</strong>。</li>
<li>高效性：从输入的消息到哈希的<strong>运算高效</strong>。</li>
<li>均一性：<strong>每个哈希值被取到的概率应该基本相等</strong>。</li>
<li>抗碰撞性：
<ul>
<li>弱抗碰撞性：给定一个消息<code>x</code>，找到另一个消息<code>x'</code>使得<code>hash(x) = hash(x')</code>是困难的。</li>
<li>强抗碰撞性：找到任意<code>x</code>和<code>x'</code>，使得<code>hash(x) = hash(x')</code>是困难的。</li>
</ul>
</li>
</ul>
<h4 id="hash的应用">Hash的应用</h4>
<ul>
<li>生成数据唯一标识</li>
<li>加密签名</li>
<li>安全加密</li>
</ul>
<h4 id="keccak256">Keccak256</h4>
<p><code>Keccak256</code>函数是<code>solidity</code>中最常用的哈希函数，用法非常简单：</p>
<pre><code class="language-solidity">哈希 = keccak256(数据);
</code></pre>
<h4 id="keccak256和sha3">Keccak256和sha3</h4>
<p>这是一个很有趣的事情：</p>
<ol>
<li>sha3由keccak标准化而来，在很多场合下Keccak和SHA3是同义词，但在2015年8月SHA3最终完成标准化时，NIST调整了填充算法。<strong>所以SHA3就和keccak计算的结果不一样</strong>，这点在实际开发中要注意。</li>
<li>以太坊在开发的时候sha3还在标准化中，所以采用了keccak，所以Ethereum和Solidity智能合约代码中的SHA3是指Keccak256，而不是标准的NIST-SHA3，为了避免混淆，直接在合约代码中写成Keccak256是最清晰的。</li>
</ol>
<h4 id="生成数据唯一标识">生成数据唯一标识</h4>
<p>我们可以利用<code>keccak256</code>来生成一些数据的唯一标识。比如我们有几个不同类型的数据：<code>uint</code>，<code>string</code>，<code>address</code>，我们可以先用<code>abi.encodePacked</code>方法将他们打包编码，然后再用<code>keccak256</code>来生成唯一标识：</p>
<pre><code class="language-solidity">function hash(
	uint _num,
	string memory _string,
	address _addr
) public pure returns (bytes32) {
	return keccak256(abi.encodePacked(_num, _string, _addr));
}
</code></pre>
<h4 id="弱抗碰撞性">弱抗碰撞性</h4>
<p>我们用<code>keccak256</code>演示一下之前讲到的弱抗碰撞性，即给定一个消息<code>x</code>，找到另一个消息<code>x'</code>使得<code>hash(x) = hash(x')</code>是困难的。</p>
<p>我们给定一个消息<code>0xAA</code>，试图去找另一个消息，使得它们的哈希值相等：</p>
<pre><code class="language-solidity">// 弱抗碰撞性
function weak(
	string memory string1
)public view returns (bool){
	return keccak256(abi.encodePacked(string1)) == _msg;
}
</code></pre>
<p>大家可以试个10次，看看能不能幸运的碰撞上。</p>
<h4 id="强抗碰撞性">强抗碰撞性</h4>
<p>我们用<code>keccak256</code>演示一下之前讲到的强抗碰撞性，即找到任意不同的<code>x</code>和<code>x'</code>，使得<code>hash(x) = hash(x')</code>是困难的。</p>
<p>我们构造一个函数<code>strong</code>，接收两个不同的<code>string</code>参数<code>string1</code>和<code>string2</code>，然后判断它们的哈希是否相同：</p>
<pre><code class="language-solidity">// 强抗碰撞性
function strong(
    string memory string1,
    string memory string2
)public pure returns (bool){
	return keccak256(abi.encodePacked(string1)) == keccak256(abi.encodePacked(string2));
}
</code></pre>
<p>大家可以试个10次，看看能不能幸运的碰撞上。</p>
<h4 id="在remix上验证-5">在remix上验证</h4>
<ol>
<li>部署合约查看唯一标识生成结果</li>
</ol>
<figure data-type="image" tabindex="92"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115190728397.png" alt="查看唯一标识生成结果" loading="lazy"></figure>
<ol start="2">
<li>验证哈希函数的灵敏性、强弱碰撞性</li>
</ol>
<figure data-type="image" tabindex="93"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115191131973.png" alt="哈希函数测试" loading="lazy"></figure>
<h3 id="29-选择器">29. 选择器</h3>
<p>当我们调用智能合约时，本质上是向目标合约发送了一段<code>calldata</code>，在remix中发送一次交易后，可以在详细信息中看见<code>input</code>即为此次交易的<code>calldata</code></p>
<p>发送的<code>calldata</code>中前4个字节是<code>selector</code>（函数选择器）。这一讲，我们将介绍<code>selector</code>是什么，以及如何使用。</p>
<h4 id="msgdata"><code>msg.data</code></h4>
<p><code>msg.data</code>是<code>solidity</code>中的一个全局变量，值为完整的<code>calldata</code>（调用函数时传入的数据）。</p>
<p>在下面的代码中，我们可以通过<code>Log</code>事件来输出调用<code>mint</code>函数的<code>calldata</code>：</p>
<pre><code class="language-solidity">// event 返回msg.data
event Log(bytes data);

function mint(address to) external{
	emit Log(msg.data);
}
</code></pre>
<p>当参数为<code>0x2c44b726ADF1963cA47Af88B284C06f30380fC78</code>时，输出的<code>calldata</code>为</p>
<pre><code class="language-text">0x6a6278420000000000000000000000002c44b726adf1963ca47af88b284c06f30380fc78
</code></pre>
<p>这段很乱的字节码可以分成两部分：</p>
<pre><code class="language-text">前4个字节为函数选择器selector：
0x6a627842

后面32个字节为输入的参数：
0x0000000000000000000000002c44b726adf1963ca47af88b284c06f30380fc78
</code></pre>
<p>其实<code>calldata</code>就是告诉智能合约，我要调用<strong>哪个函数，以及参数是什么</strong>。</p>
<figure data-type="image" tabindex="94"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115193859938.png" alt="calldata" loading="lazy"></figure>
<h4 id="method-id-selector和函数签名"><code>method id</code>、<code>selector</code>和<code>函数签名</code></h4>
<p><code>method id</code>定义为<code>函数签名</code>的<code>Keccak</code>哈希后的前4个字节，当<code>selector</code>与<code>method id</code>相匹配时，即表示调用该函数，那么<code>函数签名</code>是什么？</p>
<p>其实在第21讲中，我们简单介绍了函数签名，为<code>&quot;函数名（逗号分隔的参数类型)&quot;</code>。举个例子，上面代码中<code>mint</code>的函数签名为<code>&quot;mint(address)&quot;</code>。在同一个智能合约中，不同的函数有不同的函数签名，因此我们可以通过函数签名来确定要调用哪个函数。</p>
<p><strong>注意</strong>，在函数签名中，<code>uint</code>和<code>int</code>要写为<code>uint256</code>和<code>int256</code>。</p>
<p>我们写一个函数，来验证<code>mint</code>函数的<code>method id</code>是否为<code>0x6a627842</code>。大家可以运行下面的函数，看看结果。</p>
<pre><code class="language-solidity">function mintSelector() external pure returns(bytes4 mSelector){
	return bytes4(keccak256(&quot;mint(address)&quot;));
}
</code></pre>
<p>结果正是<code>0x6a627842</code>：</p>
<figure data-type="image" tabindex="95"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115194447412.png" alt="method id验证" loading="lazy"></figure>
<h4 id="使用selector">使用<code>selector</code></h4>
<p>我们可以利用<code>selector</code>来调用目标函数。例如我想调用<code>mint</code>函数，我只需要利用<code>abi.encodeWithSelector</code>将<code>mint</code>函数的<code>method id</code>作为<code>selector</code>和参数打包编码，传给<code>call</code>函数：</p>
<pre><code class="language-solidity">function callWithSignature() external returns(bool, bytes memory){
    (bool success, bytes memory data) = address(this).call(abi.encodeWithSelector(0x6a627842, &quot;0x2c44b726ADF1963cA47Af88B284C06f30380fC78&quot;));
    return(success, data);
}
</code></pre>
<p>在日志中，我们可以看到<code>mint</code>函数被成功调用，并输出<code>Log</code>事件。</p>
<figure data-type="image" tabindex="96"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115194938520.png" alt="使用selector" loading="lazy"></figure>
<h3 id="30-try-catch">30. try-catch</h3>
<p><code>try-catch</code>是现代编程语言几乎都有的处理异常的一种标准方式，<code>solidity</code>0.6版本也添加了它。这一讲，我们将介绍如何利用<code>try-catch</code>处理智能合约中的异常。</p>
<p>在<code>solidity</code>中，<code>try-catch</code>只能被用于<code>external</code>函数或创建合约时<code>constructor</code>（被视为<code>external</code>函数）的调用。基本语法如下：</p>
<pre><code class="language-solidity">try externalContract.f() {
    // call成功的情况下 运行一些代码
} catch {
    // call失败的情况下 运行一些代码
}
</code></pre>
<p>其中<code>externalContract.f()</code>是某个外部合约的函数调用，<code>try</code>模块在调用成功的情况下运行，而<code>catch</code>模块则在调用失败时运行。</p>
<p>同样可以使用<code>this.f()</code>来替代<code>externalContract.f()</code>，<code>this.f()</code>也被视作为外部调用，<strong>但不可在构造函数中使用</strong>，因为此时合约还未创建。</p>
<p>如果调用的函数有返回值，那么必须在<code>try</code>之后声明<code>returns(returnType val)</code>，并且在<code>try</code>模块中可以使用返回的变量；如果是创建合约，那么返回值是新创建的合约变量。</p>
<pre><code class="language-solidity">try externalContract.f() returns(returnType val){
    // call成功的情况下 运行一些代码
} catch {
    // call失败的情况下 运行一些代码
}
</code></pre>
<p>另外，<code>catch</code>模块支持捕获特殊的异常原因：</p>
<pre><code class="language-solidity">try externalContract.f() returns(returnType){
    // call成功的情况下 运行一些代码
} catch Error(string memory reason) {
    // 捕获失败的 revert() 和 require()
} catch (bytes memory reason) {
    // 捕获失败的 assert()
}
</code></pre>
<h4 id="try-catch实战"><code>try-catch</code>实战</h4>
<h5 id="onlyeven"><code>OnlyEven</code></h5>
<p>我们创建一个外部合约<code>OnlyEven</code>，并使用<code>try-catch</code>来处理异常：</p>
<pre><code class="language-solidity">contract OnlyEven{
    constructor(uint a){
        require(a != 0, &quot;invalid number&quot;);
        assert(a != 1);
    }

    function onlyEven(uint256 b) external pure returns(bool success){
        // 输入奇数时revert
        require(b % 2 == 0, &quot;Ups! Reverting&quot;);
        success = true;
    }
}
</code></pre>
<p><code>OnlyEven</code>合约包含一个构造函数和一个<code>onlyEven</code>函数。</p>
<ul>
<li>构造函数有一个参数<code>a</code>，当<code>a=0</code>时，<code>require</code>会抛出异常；当<code>a=1</code>时，<code>assert</code>会抛出异常；其他情况均正常。</li>
<li><code>onlyEven</code>函数有一个参数<code>b</code>，当<code>b</code>为奇数时，<code>require</code>会抛出异常。</li>
</ul>
<h5 id="处理外部函数调用异常">处理外部函数调用异常</h5>
<p>首先，在<code>TryCatch</code>合约中定义一些事件和状态变量：</p>
<pre><code class="language-solidity">// 成功event
event SuccessEvent();

// 失败event
event CatchEvent(string message);
event CatchByte(bytes data);

// 声明OnlyEven合约变量
OnlyEven even;

constructor() {
	even = new OnlyEven(2);
}
</code></pre>
<p><code>SuccessEvent</code>是调用成功会释放的事件，而<code>CatchEvent</code>和<code>CatchByte</code>是抛出异常时会释放的事件，分别对应<code>require/revert</code>和<code>assert</code>异常的情况。<code>even</code>是个<code>OnlyEven</code>合约类型的状态变量。</p>
<p>然后我们在<code>execute</code>函数中使用<code>try-catch</code>处理调用外部函数<code>onlyEven</code>中的异常：</p>
<pre><code class="language-solidity">// 在external call中使用try-catch
function execute(uint amount) external returns (bool success) {
    try even.onlyEven(amount) returns(bool _success){
        // call成功的情况下
        emit SuccessEvent();
        return _success;
    } catch Error(string memory reason){
        // call不成功的情况下
        emit CatchEvent(reason);
    }
}
</code></pre>
<h5 id="在remix上验证-6">在remix上验证<a href="https://wtf.academy/solidity-advanced/TryCatch/#%E5%9C%A8remix%E4%B8%8A%E9%AA%8C%E8%AF%81"></a></h5>
<p>当运行<code>execute(0)</code>的时候，因为<code>0</code>为偶数，满足<code>require(b % 2 == 0, &quot;Ups! Reverting&quot;);</code>，没有异常抛出，调用成功并释放<code>SuccessEvent</code>事件。</p>
<figure data-type="image" tabindex="97"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115200048618.png" alt="成功，释放success事件" loading="lazy"></figure>
<p>当运行<code>execute(1)</code>的时候，因为<code>1</code>为奇数，不满足<code>require(b % 2 == 0, &quot;Ups! Reverting&quot;);</code>，异常抛出，调用失败并释放<code>CatchEvent</code>事件。</p>
<figure data-type="image" tabindex="98"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115200158797.png" alt="失败，释放catchevent事件" loading="lazy"></figure>
<h5 id="处理合约创建异常">处理合约创建异常</h5>
<p>这里，我们利用<code>try-catch</code>来处理合约创建时的异常。只需要把<code>try</code>模块改写为<code>OnlyEven</code>合约的创建就行：</p>
<pre><code class="language-solidity">    // 在创建新合约中使用try-catch （合约创建被视为external call）
    // executeNew(0)会失败并释放`CatchEvent`
    // executeNew(1)会失败并释放`CatchByte`
    // executeNew(2)会成功并释放`SuccessEvent`
    function executeNew(uint a) external returns (bool success) {
        try new OnlyEven(a) returns(OnlyEven _even){
            // call成功的情况下
            emit SuccessEvent();
            success = _even.onlyEven(a);
        } catch Error(string memory reason) {
            // catch失败的 revert() 和 require()
            emit CatchEvent(reason);
        } catch (bytes memory reason) {
            // catch失败的 assert()
            emit CatchByte(reason);
        }
    }
</code></pre>
<h5 id="在remix上验证-7">在remix上验证</h5>
<p>当运行<code>executeNew(0)</code>时，因为<code>0</code>不满足<code>require(a != 0, &quot;invalid number&quot;);</code>，会失败并释放<code>CatchEvent</code>事件。</p>
<figure data-type="image" tabindex="99"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115200505157.png" alt="require 不满足" loading="lazy"></figure>
<p>当运行<code>executeNew(1)</code>时，因为<code>1</code>不满足<code>assert(a != 1);</code>，会失败并释放<code>CatchByte</code>事件。</p>
<figure data-type="image" tabindex="100"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115200626634.png" alt="assert 不满足" loading="lazy"></figure>
<p>当运行<code>executeNew(2)</code>时，因为<code>2</code>满足<code>require(a != 0, &quot;invalid number&quot;);</code>和<code>assert(a != 1);</code>，会成功并释放<code>SuccessEvent</code>事件。</p>
<figure data-type="image" tabindex="101"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115200724485.png" alt="成功释放success 事件" loading="lazy"></figure>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#solidity-study">Solidity Study</a>
<ul>
<li><a href="#solidity-%E5%B7%A5%E5%85%B7">Solidity 工具</a>
<ul>
<li><a href="#remix">Remix</a>
<ul>
<li><a href="#1-%E6%89%93%E5%BC%80remix">1. 打开remix</a></li>
<li><a href="#2-%E5%9B%BE%E6%A0%87%E9%9D%A2%E6%9D%BF">2. 图标面板</a></li>
<li><a href="#3-%E9%83%A8%E7%BD%B2%E7%AE%80%E5%8D%95%E5%90%88%E7%BA%A6">3. 部署简单合约</a>
<ul>
<li><a href="#%E7%BC%96%E8%AF%91">编译</a></li>
<li><a href="#%E9%83%A8%E7%BD%B2"><strong>部署</strong></a></li>
<li><a href="#%E8%B0%83%E7%94%A8">调用</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#solidity-%E5%85%A5%E9%97%A8">Solidity 入门</a>
<ul>
<li><a href="#1-helloweb3">1. HelloWeb3</a>
<ul>
<li><a href="#%E7%AC%AC%E4%B8%80%E4%B8%AAsolidity%E7%A8%8B%E5%BA%8F">第一个solidity程序</a></li>
<li><a href="#%E7%BC%96%E8%AF%91%E5%B9%B6%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%A0%81">编译并部署代码</a></li>
</ul>
</li>
<li><a href="#2-%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">2. 数值类型</a>
<ul>
<li><a href="#solidity-%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B">solidity 中的变量类型</a></li>
<li><a href="#1-%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8Bvalue-type">1. 数值类型Value type</a>
<ul>
<li><a href="#1-%E5%B8%83%E5%B0%94%E5%9E%8B">1. 布尔型</a></li>
<li><a href="#2-%E6%95%B4%E5%9E%8B">2. 整型</a></li>
<li><a href="#3-%E5%9C%B0%E5%9D%80%E7%B1%BB%E5%9E%8B">3. 地址类型</a></li>
<li><a href="#4-%E5%AE%9A%E9%95%BF%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84">4. 定长字节数组</a></li>
<li><a href="#5-%E6%9E%9A%E4%B8%BE-enum">5. 枚举 enum</a></li>
<li><a href="#%E5%9C%A8remix%E4%B8%8A%E9%AA%8C%E8%AF%81">在remix上验证</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
<li><a href="#3-%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B">3. 函数类型</a>
<ul>
<li><a href="#solidity%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0">Solidity中的函数</a>
<ul>
<li><a href="#1-pure-vs-view">1. pure v.s. view</a></li>
<li><a href="#2-internal-vs-external">2. internal v.s. external</a></li>
<li><a href="#3-payable">3. payable</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93-2">总结</a></li>
</ul>
</li>
<li><a href="#4-%E5%87%BD%E6%95%B0%E8%BE%93%E5%87%BA">4. 函数输出</a>
<ul>
<li><a href="#%E8%BF%94%E5%9B%9E%E5%80%BC-return%E5%92%8Creturns">返回值 return和returns</a></li>
<li><a href="#%E5%91%BD%E5%90%8D%E5%BC%8F%E8%BF%94%E5%9B%9E">命名式返回</a></li>
<li><a href="#%E8%A7%A3%E6%9E%84%E5%BC%8F%E8%B5%8B%E5%80%BC">解构式赋值</a></li>
</ul>
</li>
<li><a href="#5-%E5%8F%98%E9%87%8F%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F">5. 变量数据存储和作用域</a>
<ul>
<li><a href="#solidity%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B">Solidity中的引用类型</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE">数据位置</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE%E5%92%8C%E8%B5%8B%E5%80%BC%E8%A7%84%E5%88%99">数据位置和赋值规则</a></li>
<li><a href="#%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F">变量的作用域</a>
<ul>
<li><a href="#1-%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F">1. 状态变量</a></li>
<li><a href="#2-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F">2. 局部变量</a></li>
<li><a href="#3-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">3. 全局变量</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B">6. 引用类型</a>
<ul>
<li><a href="#%E6%95%B0%E7%BB%84array">数组array</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84%E7%9A%84%E8%A7%84%E5%88%99">创建数组的规则</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E6%88%90%E5%91%98">数组成员</a></li>
</ul>
</li>
<li><a href="#%E7%BB%93%E6%9E%84%E4%BD%93struct">结构体struct</a></li>
</ul>
</li>
<li><a href="#7-%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B">7. 映射类型</a>
<ul>
<li><a href="#%E6%98%A0%E5%B0%84mapping">映射Mapping</a></li>
<li><a href="#%E6%98%A0%E5%B0%84%E7%9A%84%E8%A7%84%E5%88%99">映射的规则</a></li>
<li><a href="#%E6%98%A0%E5%B0%84%E7%9A%84%E5%8E%9F%E7%90%86">映射的原理</a></li>
</ul>
</li>
<li><a href="#8-%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%80%BC">8. 变量初始值</a>
<ul>
<li><a href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%88%9D%E5%A7%8B%E5%80%BC">值类型初始值</a></li>
<li><a href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%88%9D%E5%A7%8B%E5%80%BC">引用类型初始值</a></li>
<li><a href="#delete%E6%93%8D%E4%BD%9C%E7%AC%A6"><code>delete</code>操作符</a></li>
</ul>
</li>
<li><a href="#9-%E5%B8%B8%E6%95%B0">9. 常数</a>
<ul>
<li><a href="#constant">constant</a></li>
<li><a href="#immutableimmutable-variables-cannot-have-a-non-value-type">immutable（Immutable variables cannot have a non-value type）</a></li>
</ul>
</li>
<li><a href="#10-%E6%8E%A7%E5%88%B6%E6%B5%81">10. 控制流</a>
<ul>
<li><a href="#%E6%8E%A7%E5%88%B6%E6%B5%81%E7%B1%BB%E5%9E%8B">控制流类型</a></li>
<li><a href="#%E7%94%A8solidity%E5%AE%9E%E7%8E%B0%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">用solidity实现插入排序</a>
<ul>
<li><a href="#python%E4%BB%A3%E7%A0%81"><code>python</code>代码</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#11-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E4%BF%AE%E9%A5%B0%E5%99%A8">11. 构造函数和修饰器</a>
<ul>
<li><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">构造函数</a></li>
<li><a href="#%E4%BF%AE%E9%A5%B0%E5%99%A8">修饰器</a></li>
</ul>
</li>
<li><a href="#12-%E4%BA%8B%E4%BB%B6">12. 事件</a>
<ul>
<li><a href="#%E8%A7%84%E5%88%99">规则</a></li>
</ul>
</li>
<li><a href="#13-%E7%BB%A7%E6%89%BF">13. 继承</a>
<ul>
<li><a href="#%E8%A7%84%E5%88%99-2">规则</a></li>
<li><a href="#%E7%AE%80%E5%8D%95%E7%BB%A7%E6%89%BF">简单继承</a></li>
<li><a href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF">多重继承</a></li>
<li><a href="#%E4%BF%AE%E9%A5%B0%E5%99%A8%E7%9A%84%E7%BB%A7%E6%89%BF">修饰器的继承</a></li>
<li><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF">构造函数的继承</a></li>
<li><a href="#%E8%B0%83%E7%94%A8%E7%88%B6%E5%90%88%E7%BA%A6%E7%9A%84%E5%87%BD%E6%95%B0">调用父合约的函数</a></li>
</ul>
</li>
<li><a href="#14-%E6%8A%BD%E8%B1%A1%E5%90%88%E7%BA%A6%E4%B8%8E%E6%8E%A5%E5%8F%A3">14. 抽象合约与接口</a>
<ul>
<li><a href="#%E6%8A%BD%E8%B1%A1%E5%90%88%E7%BA%A6">抽象合约</a></li>
<li><a href="#%E6%8E%A5%E5%8F%A3">接口</a>
<ul>
<li><a href="#ierc721%E4%BA%8B%E4%BB%B6">IERC721事件</a></li>
<li><a href="#ierc721%E5%87%BD%E6%95%B0">IERC721函数</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3">什么时候使用接口？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#15-%E5%BC%82%E5%B8%B8">15. 异常</a>
<ul>
<li><a href="#error">Error</a></li>
<li><a href="#require">Require</a></li>
<li><a href="#assert">Assert</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#solidity-%E8%BF%9B%E9%98%B6">Solidity 进阶</a>
<ul>
<li><a href="#16-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">16. 函数重载</a>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">函数重载</a></li>
<li><a href="#%E5%AE%9E%E5%8F%82%E5%8C%B9%E9%85%8Dargument-matching08-%E5%90%8E-%E5%B7%B2%E4%BF%AE%E5%A4%8D">实参匹配（Argument Matching）（0.8 后 已修复？）</a></li>
</ul>
</li>
<li><a href="#17-%E5%BA%93%E5%90%88%E7%BA%A6">17. 库合约</a>
<ul>
<li><a href="#%E5%BA%93%E5%87%BD%E6%95%B0">库函数</a></li>
<li><a href="#string%E5%BA%93%E5%90%88%E7%BA%A6">String库合约</a></li>
</ul>
</li>
<li><a href="#18-import">18. Import</a>
<ul>
<li><a href="#import%E7%94%A8%E6%B3%95"><code>import</code>用法</a></li>
</ul>
</li>
<li><a href="#19-%E6%8E%A5%E5%8F%97eth">19. 接受ETH</a>
<ul>
<li><a href="#%E6%8E%A5%E6%94%B6eth%E5%87%BD%E6%95%B0-receive">接收ETH函数 receive</a></li>
<li><a href="#%E5%9B%9E%E9%80%80%E5%87%BD%E6%95%B0-fallback">回退函数 fallback</a></li>
<li><a href="#receive%E5%92%8Cfallback%E7%9A%84%E5%8C%BA%E5%88%AB">receive和fallback的区别</a></li>
<li><a href="#remix-%E6%BC%94%E7%A4%BA">remix 演示</a></li>
</ul>
</li>
<li><a href="#20-%E5%8F%91%E9%80%81eth">20. 发送ETH</a>
<ul>
<li><a href="#transfer">transfer</a></li>
<li><a href="#send">send</a></li>
<li><a href="#call">call</a></li>
</ul>
</li>
<li><a href="#21-%E8%B0%83%E7%94%A8%E5%85%B6%E4%BB%96%E5%90%88%E7%BA%A6">21. 调用其他合约</a>
<ul>
<li><a href="#%E7%9B%AE%E6%A0%87%E5%90%88%E7%BA%A6">目标合约</a></li>
<li><a href="#%E8%B0%83%E7%94%A8othercontract%E5%90%88%E7%BA%A6">调用OtherContract合约</a>
<ul>
<li><a href="#1-%E4%BC%A0%E5%85%A5%E5%90%88%E7%BA%A6%E5%9C%B0%E5%9D%80">1. 传入合约地址</a></li>
<li><a href="#2-%E4%BC%A0%E5%85%A5%E5%90%88%E7%BA%A6%E5%8F%98%E9%87%8F">2. 传入合约变量</a></li>
<li><a href="#3-%E5%88%9B%E5%BB%BA%E5%90%88%E7%BA%A6%E5%8F%98%E9%87%8F">3. 创建合约变量</a></li>
<li><a href="#4-%E8%B0%83%E7%94%A8%E5%90%88%E7%BA%A6%E5%B9%B6%E5%8F%91%E9%80%81eth">4. 调用合约并发送<code>ETH</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#22-call">22. Call</a>
<ul>
<li><a href="#call%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99"><code>call</code>的使用规则</a></li>
<li><a href="#%E7%9B%AE%E6%A0%87%E5%90%88%E7%BA%A6-2">目标合约</a></li>
<li><a href="#%E5%88%A9%E7%94%A8call%E8%B0%83%E7%94%A8%E7%9B%AE%E6%A0%87%E5%90%88%E7%BA%A6">利用<code>call</code>调用目标合约</a></li>
</ul>
</li>
<li><a href="#23-delegatecall">23. Delegatecall</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E7%94%A8%E5%88%B0delegatecall">什么情况下会用到<code>delegatecall</code>?</a></li>
<li><a href="#delegatecall%E4%BE%8B%E5%AD%90"><code>delegatecall</code>例子</a>
<ul>
<li><a href="#%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84%E5%90%88%E7%BA%A6c">被调用的合约C</a></li>
<li><a href="#%E5%8F%91%E8%B5%B7%E8%B0%83%E7%94%A8%E7%9A%84%E5%90%88%E7%BA%A6b">发起调用的合约B</a></li>
<li><a href="#remix-%E9%AA%8C%E8%AF%81">remix 验证</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#24-create">24. Create</a>
<ul>
<li><a href="#create%E5%92%8Ccreate2"><code>create</code>和<code>create2</code></a></li>
<li><a href="#%E6%9E%81%E7%AE%80uniswap">极简Uniswap</a></li>
<li><a href="#pair%E5%90%88%E7%BA%A6"><code>Pair</code>合约</a></li>
<li><a href="#pairfactory"><code>PairFactory</code></a></li>
<li><a href="#%E5%9C%A8remix%E4%B8%8A%E9%AA%8C%E8%AF%81-2">在remix上验证</a></li>
</ul>
</li>
<li><a href="#25-create2">25. Create2</a>
<ul>
<li><a href="#create%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%9C%B0%E5%9D%80">CREATE如何计算地址</a></li>
<li><a href="#create2%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%9C%B0%E5%9D%80">CREATE2如何计算地址</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8create2">如何使用<code>CREATE2</code></a>
<ul>
<li><a href="#%E6%9E%81%E7%AE%80uniswap2">极简Uniswap2</a></li>
<li><a href="#pair"><code>Pair</code></a></li>
<li><a href="#pairfactory2"><code>PairFactory2</code></a></li>
<li><a href="#%E4%BA%8B%E5%85%88%E8%AE%A1%E7%AE%97pair%E5%9C%B0%E5%9D%80">事先计算<code>Pair</code>地址</a></li>
</ul>
</li>
<li><a href="#%E5%9C%A8remix%E4%B8%8A%E9%AA%8C%E8%AF%81-3">在remix上验证</a></li>
<li><a href="#create2%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">create2的实际应用场景</a></li>
</ul>
</li>
<li><a href="#26-%E5%88%A0%E9%99%A4%E5%90%88%E7%BA%A6">26. 删除合约</a>
<ul>
<li><a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8selfdestruct">如何使用<code>selfdestruct</code></a></li>
<li><a href="#%E4%BE%8B%E5%AD%90">例子</a></li>
<li><a href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li>
<li><a href="#%E5%9C%A8remix%E4%B8%8A%E9%AA%8C%E8%AF%81-4">在remix上验证</a></li>
</ul>
</li>
<li><a href="#27-abi-%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81">27. ABI 编码解码</a>
<ul>
<li><a href="#abi%E7%BC%96%E7%A0%81">ABI编码</a>
<ul>
<li><a href="#abiencode"><code>abi.encode</code></a></li>
<li><a href="#abiencodepacked"><code>abi.encodePacked</code></a></li>
<li><a href="#abiencodewithsignature"><code>abi.encodeWithSignature</code></a></li>
<li><a href="#abiencodewithselector"><code>abi.encodeWithSelector</code></a></li>
</ul>
</li>
<li><a href="#abi%E8%A7%A3%E7%A0%81">ABI解码</a>
<ul>
<li><a href="#abidecode"><code>abi.decode</code></a></li>
</ul>
</li>
<li><a href="#abi%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">ABI的使用场景</a></li>
</ul>
</li>
<li><a href="#28-hash">28. Hash</a>
<ul>
<li><a href="#hash%E7%9A%84%E6%80%A7%E8%B4%A8">Hash的性质</a></li>
<li><a href="#hash%E7%9A%84%E5%BA%94%E7%94%A8">Hash的应用</a></li>
<li><a href="#keccak256">Keccak256</a></li>
<li><a href="#keccak256%E5%92%8Csha3">Keccak256和sha3</a></li>
<li><a href="#%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86">生成数据唯一标识</a></li>
<li><a href="#%E5%BC%B1%E6%8A%97%E7%A2%B0%E6%92%9E%E6%80%A7">弱抗碰撞性</a></li>
<li><a href="#%E5%BC%BA%E6%8A%97%E7%A2%B0%E6%92%9E%E6%80%A7">强抗碰撞性</a></li>
<li><a href="#%E5%9C%A8remix%E4%B8%8A%E9%AA%8C%E8%AF%81-5">在remix上验证</a></li>
</ul>
</li>
<li><a href="#29-%E9%80%89%E6%8B%A9%E5%99%A8">29. 选择器</a>
<ul>
<li><a href="#msgdata"><code>msg.data</code></a></li>
<li><a href="#method-id-selector%E5%92%8C%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D"><code>method id</code>、<code>selector</code>和<code>函数签名</code></a></li>
<li><a href="#%E4%BD%BF%E7%94%A8selector">使用<code>selector</code></a></li>
</ul>
</li>
<li><a href="#30-try-catch">30. try-catch</a>
<ul>
<li><a href="#try-catch%E5%AE%9E%E6%88%98"><code>try-catch</code>实战</a>
<ul>
<li><a href="#onlyeven"><code>OnlyEven</code></a></li>
<li><a href="#%E5%A4%84%E7%90%86%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%BC%82%E5%B8%B8">处理外部函数调用异常</a></li>
<li><a href="#%E5%9C%A8remix%E4%B8%8A%E9%AA%8C%E8%AF%81-6">在remix上验证</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E5%90%88%E7%BA%A6%E5%88%9B%E5%BB%BA%E5%BC%82%E5%B8%B8">处理合约创建异常</a></li>
<li><a href="#%E5%9C%A8remix%E4%B8%8A%E9%AA%8C%E8%AF%81-7">在remix上验证</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank"> Gridea </a>
  <a class="rss" href="https://CNZedChou.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
