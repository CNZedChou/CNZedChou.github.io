<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>蓝桥杯C++ | ZedChou&#39;s Blog</title>
<link rel="shortcut icon" href="https://CNZedChou.github.io/favicon.ico?v=1676222959031">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://CNZedChou.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="蓝桥杯C++ | ZedChou&#39;s Blog - Atom Feed" href="https://CNZedChou.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="@Description:   用于AcWing上学习蓝桥杯C++的学习过程
@Author:    Zed Chou
@LastModified:    Wed 8 Feb 2023

递归与递推
递归
所有递归都可以转化为一棵递归搜索树..." />
    <meta name="keywords" content="Coding" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://CNZedChou.github.io">
  <img class="avatar" src="https://CNZedChou.github.io/images/avatar.png?v=1676222959031" alt="">
  </a>
  <h1 class="site-title">
    ZedChou&#39;s Blog
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              蓝桥杯C++
            </h2>
            <div class="post-info">
              <span>
                2023-01-13
              </span>
              <span>
                163 min read
              </span>
              
                <a href="https://CNZedChou.github.io/tag/yx9d52T4r/" class="post-tag">
                  # Coding
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <p>@Description:   用于AcWing上学习蓝桥杯C++的学习过程<br>
@Author:    Zed Chou<br>
@LastModified:    Wed 8 Feb 2023</p>
<!-- more -->
<h1 id="递归与递推">递归与递推</h1>
<h2 id="递归">递归</h2>
<p>所有递归都可以转化为一棵递归搜索树</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230113144601714.png" alt="image-20230113144601714" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230113143336682.png" alt="image-20230113143336682" loading="lazy"></figure>
<p>斐波那契数列代码</p>
<pre><code class="language-c++">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;

using namespace std;

int f(int n) {
	if (n == 1) return 1;
	if (n == 2) return 2;
	return f(n - 1) + f(n - 2);
}

int main() {
	int n;
	scanf(&quot;%d&quot;, &amp;n);
	printf(&quot;%d\n&quot;, f(n));
	
	return 0;
}
</code></pre>
<h3 id="例题-92-递归实现指数型枚举">例题 92. 递归实现指数型枚举</h3>
<p><a href="https://www.acwing.com/problem/content/94/">92. 递归实现指数型枚举</a></p>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230116214158902.png" alt="image-20230116214158902" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230113145510183.png" alt="image-20230113145510183" loading="lazy"></figure>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;

using namespace std;

int n;
const int N = 16;
int st[N]; // 表示数字选择的状态，0 表示还没选，1 表示选， 2表示不选 

void dfs(int u) {
	// u 表示当前所在的位数
	if (u &gt; n) {
		for (int i = 1; i &lt;= n; i ++) {
			if (st[i] == 1)
				printf(&quot;%d &quot;, i); // 加空格，否则wrong answer 
		}
		printf(&quot;\n&quot;);
		return ;
	}
	
	st[u] = 2; 
	dfs(u + 1); // 不选的分支 
	st[u] = 0; // 恢复现场 
	
	st[u] = 1;
	dfs(u + 1); // 选的分支 
	st[u] = 0; // 恢复现场 
}


int main() {
	scanf(&quot;%d&quot;, &amp;n);
	dfs(1);
	
	return 0; 
}
</code></pre>
<h3 id="例题-94-递归实现排列型枚举">例题 94. 递归实现排列型枚举</h3>
<p><a href="https://www.acwing.com/problem/content/96/">AcWing 94. 递归实现排列型枚举 </a></p>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230116214218850.png" alt="image-20230116214218850" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230113155248147.png" alt="image-20230113155248147" loading="lazy"></figure>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;

using namespace std;

int n;
const int N = 10;
int st[N]; // 	表示当前的状态， 0表示没有数，1-n表示有数字 
bool used[N]; //	表示每个数是否被用过，true表示已经被用过，false 表示还没有被用过 


void dfs(int u) {
	// 边界条件 
	if (u &gt; n) {
		for (int i = 1; i &lt;= n; i ++) printf(&quot;%d &quot;, st[i]);
		printf(&quot;\n&quot;);
		return ; 
	}
	
	for (int i = 1; i &lt;= n; i ++) {
		if (!used[i]) {
			st[u] = i;
			used[i] = true;
			dfs(u + 1);
			
			st[u] = 0;
			used[i] = false;
		}
	}		
}


int main() {
	scanf(&quot;%d&quot;, &amp;n);
	
	dfs(1);
	
	return 0;	
}
</code></pre>
<h3 id="习题-93-递归实现组合型枚举">习题 93. 递归实现组合型枚举</h3>
<p><a href="https://www.acwing.com/problem/content/95/">93. 递归实现组合型枚举</a></p>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230116214413907.png" alt="image-20230116214413907" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230116214643540.png" alt="image-20230116214643540" loading="lazy"></figure>
<p><strong>方案限制 从小到大排序</strong> 只需要保证所有新加的数 大于 前面的数</p>
<figure data-type="image" tabindex="9"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230116215538793.png" alt="递归组合搜索树" loading="lazy"></figure>
<p>代码要点</p>
<figure data-type="image" tabindex="10"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230116215902983.png" alt="image-20230116215902983" loading="lazy"></figure>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;

using namespace std;

const int N = 30;

int n, m;
int way[N];

void dfs(int u, int start) {
    if (u + n - start &lt; m) return ; // 优化
	if (u == m + 1) {
		// 表明已经递归完最后一位
		for (int i = 1; i &lt;= m; i ++) {
			printf(&quot;%d &quot;, way[i]);
			
		}
		puts(&quot;&quot;);
		return ;
	}
	// 开始递归
	for (int i = start; i &lt;= n; i ++) {
		way[u] = i;
		dfs(u + 1, i + 1);
		way[u] = 0; // 恢复现场
	}
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	
	dfs(1, 1);
	
	return 0;
}
</code></pre>
<h3 id="习题-1209-带分数">习题 1209. 带分数</h3>
<p><a href="https://www.acwing.com/problem/content/1211/">1209. 带分数</a></p>
<figure data-type="image" tabindex="11"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230116223936038.png" alt="image-20230116223936038" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230116231235695.png" alt="image-20230116231235695" loading="lazy"></figure>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

const int N = 20;
typedef long long LL;

int n, ans;
bool st[N], backup[N];

bool check(int a, int c) {
	LL b = n * (LL)c - a * c;
	if (!a || !b || !c) return false;
	memcpy(backup, st, sizeof st);
	while (b) {
		int x = b % 10;
		b /= 10;
		if (!x || backup[x]) return false; // 如果x是0 或 x已被用过
		backup[x] = true;	
	}
	for (int i = 1; i &lt;= 9; i ++) {
		if (!backup[i]) return false;	
	}
	
	return true;
}



void dfs_c(int a, int c) {
	if (check(a, c)) ans ++;
	for (int i = 1; i &lt;= 9; i ++) {
		if (!st[i]) {
			st[i] = true;
			dfs_c(a, c * 10 + i);	
			st[i] = false;
		}
	}
}

void dfs_a(int a) {
	if (a &gt;= n) return ; // 如果 a &gt; n 则不成立
	if (a) dfs_c(a, 0);
	
	for (int i = 1; i &lt;= 9; i ++) {
		if (!st[i]) {
			// 如果没有使用过
			st[i] = true;
			dfs_a(a * 10 + i); // 向前移动一位 
			st[i] = false; // 恢复现场	
		}
	}
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	
	dfs_a(0);
	cout &lt;&lt; ans;
	
	return 0;
}
</code></pre>
<h3 id="习题-1225-正则问题">习题 1225. 正则问题</h3>
<p><a href="https://www.acwing.com/problem/content/1227/">1225. 正则问题</a></p>
<p>考虑一种简单的正则表达式：</p>
<p>只由 x ( ) | 组成的正则表达式。</p>
<p>小明想求出这个正则表达式能接受的最长字符串的长度。</p>
<p>例如 ((xx|xxx)x|(x|xx))xx 能接受的最长字符串是： xxxxxx，长度是6。</p>
<h4 id="输入格式">输入格式</h4>
<p>一个由x()|组成的正则表达式。</p>
<h4 id="输出格式">输出格式</h4>
<p>输出所给正则表达式能接受的最长字符串的长度。</p>
<h4 id="数据范围">数据范围</h4>
<p>输入长度不超过100，保证合法。</p>
<h4 id="输入样例">输入样例：</h4>
<pre><code>((xx|xxx)x|(x|xx))xx 
</code></pre>
<h4 id="输出样例">输出样例：</h4>
<pre><code>6
</code></pre>
<figure data-type="image" tabindex="13"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230208155532386.png" alt="image-20230208155532386" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230208155845844.png" alt="image-20230208155845844" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

string str;
int k;

int dfs() {
    int res = 0;
    while (k &lt; str.size()) {
        if (str[k] == '(') {  // 处理形如(...)的内容
            k ++;  // 跳过当前的左括号
            res += dfs();
            k ++;  // 跳过当前的右括号
        } else if (str[k] == '|') {
            //  取左右的较大值
            k ++;  // 跳过当前的 '|'
            res = max(res, dfs());
        } else if (str[k] == ')') break;
        else {
            // 遇到'x' 
            k ++;
            res ++;
        }
    }
    return res;
}

int main() {
    cin &gt;&gt; str;
    printf(&quot;%d\n&quot;, dfs());

    return 0;
}
</code></pre>
<h2 id="递推">递推</h2>
<h3 id="例题-717-简单斐波那契">例题 717. 简单斐波那契</h3>
<p><a href="https://www.acwing.com/problem/content/719/">717. 简单斐波那契</a></p>
<figure data-type="image" tabindex="15"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230118155532256.png" alt="image-20230118155532256" loading="lazy"></figure>
<ul>
<li>使用数组的方法</li>
</ul>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;

using namespace std;

int main() {
	int f[46];
	int n;
	cin &gt;&gt; n;
	
	f[0] = 0, f[1] = 1;
	for (int i = 2; i &lt; n; i ++) f[i] = f[i - 1] + f[i - 2];
	
	for (int i = 0; i &lt; n; i ++) cout &lt;&lt; f[i] &lt;&lt; ' ';
	
	return 0;
}
</code></pre>
<ul>
<li>使用变量的方法</li>
</ul>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;

using namespace std;

int main() {
	int n;
	cin &gt;&gt; n;
	
	int a = 0, b = 1;
	for (int i = 1; i &lt;= n; i ++) {
		cout &lt;&lt; a &lt;&lt; ' ';
		int fn = a + b;
		a = b, b = fn;	
	}
	
	return 0;
}
</code></pre>
<h3 id="例题-95-费解的开关">例题 95. 费解的开关</h3>
<p><a href="https://www.acwing.com/problem/content/97/">95. 费解的开关</a></p>
<figure data-type="image" tabindex="16"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119133745755.png" alt="image-20230119133745755" loading="lazy"></figure>
<figure data-type="image" tabindex="17"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119134729534.png" alt="image-20230119134729534" loading="lazy"></figure>
<h4 id="思路当第一行确定之后接下来的操作都唯一确定">思路：当第一行确定之后，接下来的操作都唯一确定</h4>
<h4 id="代码关键点">代码关键点</h4>
<ul>
<li>如何枚举第一行的操作
<ul>
<li>由于一行只有5位，将这5位看成5位的二进制数，每个操作对应一个二进制数</li>
<li>判断2进制表示的数字某位是否为1的方法<code>i &gt;&gt; k &amp; 1</code></li>
</ul>
</li>
<li>如何去操作
<ul>
<li>turn(x,y) 通过偏移量进行操作</li>
</ul>
</li>
<li>时间复杂度</li>
</ul>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

const int N = 6;

char g[N][N], backup[N][N];
int dx[5] = {-1, 0, 1, 0, 0}, dy[5] = {0, 1, 0, -1, 0};

void turn(int x, int y) {
	for (int i = 0; i &lt; 5; i ++) {
		int a = x + dx[i], b = y + dy[i];
		if (a &lt; 0 || a &gt;= 5 || b &lt; 0 || b &gt;= 5) continue; // 在边界之外
		g[a][b] ^= 1; // 其中'0'ascii码为48二进制为110000， '1'ascii码为49二进制为110001 
	}
}

int main() {
	int n;
	cin &gt;&gt; n;
	while (n --) {
		for (int i = 0; i &lt; 5; i ++) cin &gt;&gt; g[i];
		int res = 10;
		
		// 对第一行进行操作
		for (int op = 0; op &lt; 32; op ++) {
			memcpy(backup, g, sizeof g);
			int step = 0;
			for (int i = 0; i &lt; 5; i ++) {
				if (op &gt;&gt; i &amp; 1) {
					step ++; // 操作数加1，表示将灭的灯打开 
					turn(0, i); // turn函数表示对当前坐标以及周围的灯的状态进行改变 
				}
			}
			for (int i = 0; i &lt; 4; i ++) {
				for (int j = 0; j &lt; 5; j ++) {
					if (g[i][j] == '0') {
						// 表示当前的等灭，下一行需要开灯，故操作数加1
						step++;
						turn(i + 1, j); 
					}
				}
			}
			
			bool dark = false;
			for (int i = 0; i &lt; 5; i ++) {
				if (g[4][i] == '0') {
					dark = true;
					break;
					// 最后一行仍有未开的灯	
				}
			}
			if (!dark) res = min(res, step); // 如果全部灯都打开
			memcpy(g, backup, sizeof g); 
		}
		if (res &gt; 6) res = -1;
		cout &lt;&lt; res &lt;&lt; endl;
		
	}
	
	return 0;
}
</code></pre>
<h3 id="习题-116-飞行员兄弟">习题 116. 飞行员兄弟</h3>
<p><a href="https://www.acwing.com/problem/content/118/">116. 飞行员兄弟</a></p>
<figure data-type="image" tabindex="18"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119143918474.png" alt="image-20230119143918474" loading="lazy"></figure>
<h4 id="思路">思路</h4>
<figure data-type="image" tabindex="19"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119153305792.png" alt="image-20230119153305792" loading="lazy"></figure>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;

#define x first
#define y second

using namespace std;

typedef pair&lt;int, int&gt; PII; 
const int N = 5;

char g[N][N], backup[N];


int get(int x, int y) {
	return x * 4 + y;
	// 坐标为x，y的对应为二进制数的第x*4+y位	
}

void turn_one(int x, int y) {
	if (g[x][y] == '-') g[x][y] = '+';
	else g[x][y] = '-';	
}

void turn_all(int x, int y) {
	// 修改对应的十字路径上的开关 
	for (int i = 0; i &lt; 4; i ++) {
		turn_one(i, y); // 修改行 
		turn_one(x, i); // 修改列 
	}
	turn_one(x, y); // 由于中间的被两次操作，所以再操作回来 
}


int main() {
	for (int i = 0; i &lt; 4; i ++) cin &gt;&gt; g[i];
	
	vector&lt;PII&gt; res; // 存储结果的操作 
	
	// 暴力枚举每一次的操作
	for (int op = 0; op &lt; (1 &lt;&lt; 16); op ++) {
		vector&lt;PII&gt; tmp;
		memcpy(backup, g, sizeof g); //		备份
		for (int i = 0; i &lt; 4; i ++) {
			for (int j = 0; j &lt; 4; j ++) {
				if (op &gt;&gt; get(i, j) &amp; 1) {
					tmp.push_back({i, j});
					turn_all(i, j);	
				}
			}
		}
		// 判断所有的灯泡是否全部亮 
		bool has_closed = false;
		for (int i = 0; i &lt; 4; i ++) {
			for (int j = 0; j &lt; 4; j ++) {
				if (g[i][j] == '+') has_closed = true; // 有还没关闭的 
			}
		}
		
		if (has_closed == false) {
			if (res.empty() || res.size() &gt; tmp.size()) res = tmp;	
		}
		memcpy(g, backup, sizeof g); // 	还原 
	}
	// 输出结果
	cout &lt;&lt; res.size() &lt;&lt; endl;
	for (auto p: res) cout &lt;&lt; p.x + 1 &lt;&lt; ' ' &lt;&lt; p.y + 1 &lt;&lt; endl; 

	return 0;
}
</code></pre>
<h3 id="习题-1208-翻硬币">习题 1208. 翻硬币</h3>
<p><a href="https://www.acwing.com/problem/content/1210/">1208. 翻硬币</a></p>
<figure data-type="image" tabindex="20"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119144156307.png" alt="image-20230119144156307" loading="lazy"></figure>
<h4 id="思路-2">思路</h4>
<figure data-type="image" tabindex="21"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119145109874.png" alt="image-20230119145109874" loading="lazy"></figure>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;

using namespace std;

const int N = 110;
char before[N], after[N];
 
void turn(int i) {
	if (before[i] == '*') before[i] = 'o';
	else before[i] = '*';	
}

int main() {
	cin &gt;&gt; before &gt;&gt; after;
	int res = 0;
	int n = strlen(before);
	for (int i = 0; i &lt; n - 1; i ++) {
		if (before[i] != after[i]) {
			turn(i), turn(i + 1); // 进行修改，翻转相邻的两枚硬币 
			res ++;
		}
	}
	cout &lt;&lt; res &lt;&lt; endl;
	return 0;
}
</code></pre>
<h1 id="二分与前缀和">二分与前缀和</h1>
<h2 id="二分">二分</h2>
<p>整数二分步骤：</p>
<ol>
<li>找一个区间[L,R],使得答案一定在该区间中</li>
<li>找一个判断条件，使得该判断条件具有二段性，并且答案一定是该二段性的分界点。</li>
<li>分析终点M在该判断条件下是否成立，如果成立，考虑答案在哪个区间；如果不成立，考虑答案在哪个区间：</li>
<li>如果更新方式写的是R=Mid,则不用做任何处理；如果更新方式写的是L=Mid,则需要在计算Mid时加上1。</li>
</ol>
<h3 id="整数二分的模板">整数二分的模板</h3>
<pre><code class="language-c++">bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l &lt; r)
    {
        int mid = l + r &gt;&gt; 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
{
    while (l &lt; r)
    {
        int mid = l + r + 1 &gt;&gt; 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
</code></pre>
<h4 id="第一类目标值为左侧区间的右端点落在左侧">第一类：目标值为左侧区间的右端点（落在左侧）</h4>
<figure data-type="image" tabindex="22"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119171603443.png" alt="image-20230119171603443" loading="lazy"></figure>
<pre><code class="language-c++">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
{
    while (l &lt; r)
    {
        int mid = l + r + 1 &gt;&gt; 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
</code></pre>
<h4 id="第二类目标值为右侧区间的左端点落在右侧">第二类：目标值为右侧区间的左端点（落在右侧）</h4>
<figure data-type="image" tabindex="23"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119171817071.png" alt="image-20230119171817071" loading="lazy"></figure>
<pre><code class="language-c++">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l &lt; r)
    {
        int mid = l + r &gt;&gt; 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
</code></pre>
<h3 id="浮点数二分的模板">浮点数二分的模板</h3>
<figure data-type="image" tabindex="24"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119225519164.png" alt="image-20230119225519164" loading="lazy"></figure>
<pre><code class="language-c++">double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l &gt; eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
</code></pre>
<h3 id="例题-789-数的范围">例题 789. 数的范围</h3>
<p><a href="https://www.acwing.com/problem/content/791/">789. 数的范围</a></p>
<figure data-type="image" tabindex="25"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119185556558.png" alt="image-20230119185556558" loading="lazy"></figure>
<h4 id="思路-3">思路</h4>
<figure data-type="image" tabindex="26"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119190414212.png" alt="image-20230119190414212" loading="lazy"></figure>
<p>在查找右侧的端点的时候</p>
<p>可以将找到的左端点作为左边界</p>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;

using namespace std;

const int N = 100010;
int q[N];
int n, m;

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	// 输入待询问的数组 
	for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;q[i]);
	
	// 处理每次询问 
	for (int i = 0; i &lt; m; i ++) {
		int x;
		scanf(&quot;%d&quot;, &amp;x);
		int l = 0, r = n - 1;
		// 二分查找左端点 
		while (l &lt; r) {
			int mid = (l + r) &gt;&gt; 1;
			if (q[mid] &gt;= x) r = mid;
			else l = mid + 1;	
		}
		if (q[r] == x) {
			cout &lt;&lt; r;	
			// 开始二分查找右端点 此时l = r
			r = n - 1; // 重新设置右边界点
			while (l &lt; r) {
				int mid = (l + r + 1) &gt;&gt; 1;
				if (q[mid] &lt;= x) l = mid;
				else r = mid - 1;
			}
			cout &lt;&lt; ' ' &lt;&lt; r &lt;&lt; endl;
			 
		} else {
			cout &lt;&lt; &quot;-1 -1&quot; &lt;&lt; endl;
		}
	}
	
	return 0;
}
</code></pre>
<h3 id="例题-790-数的三次方根">例题 790. 数的三次方根</h3>
<p><a href="https://www.acwing.com/problem/content/792/">790. 数的三次方根</a></p>
<figure data-type="image" tabindex="27"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119225730575.png" alt="image-20230119225730575" loading="lazy"></figure>
<figure data-type="image" tabindex="28"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119230241701.png" alt="image-20230119230241701" loading="lazy"></figure>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;

using namespace std;

double n;

int main() {
	cin &gt;&gt; n;
	double l = -1e6, r = 1e6;
	while (r - l &gt; 1e-7) {
		double mid = (l + r) / 2;
		if (mid * mid * mid &gt;= n) r = mid;
		else l = mid; 	
	}
	printf(&quot;%.6f&quot;, l);
	
	return 0;
}
</code></pre>
<h3 id="习题-730-机器人跳跃问题">习题 730. 机器人跳跃问题</h3>
<p><a href="https://www.acwing.com/problem/content/732/">730. 机器人跳跃问题</a></p>
<figure data-type="image" tabindex="29"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119233225250.png" alt="image-20230119233225250" loading="lazy"></figure>
<figure data-type="image" tabindex="30"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119233752375.png" alt="image-20230119233752375" loading="lazy"></figure>
<figure data-type="image" tabindex="31"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119234034010.png" alt="image-20230119234034010" loading="lazy"></figure>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;

using namespace std;

const int N = 100010;

int n;
int h[N];

bool check(int e) {
	for (int i = 1; i &lt;= n; i ++) {
		e = 2 * e - h[i];
		if (e &gt;= 1e5) return true;
		if (e &lt; 0) return false;
	}
	return true; 
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;h[i]);
	
	int l = 0, r = 1e5;
	while (l &lt; r) {
		int mid = (l + r) &gt;&gt; 1;
		if (check(mid)) r = mid;
		else l = mid + 1;	
	}
	
	printf(&quot;%d&quot;, r);
	return 0;	
}
</code></pre>
<h3 id="习题-1221-四平方和">习题 1221. 四平方和</h3>
<p><a href="https://www.acwing.com/problem/content/1223/">1221. 四平方和</a></p>
<figure data-type="image" tabindex="32"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230120143245617.png" alt="image-20230120143245617" loading="lazy"></figure>
<figure data-type="image" tabindex="33"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230120145053309.png" alt="image-20230120145053309" loading="lazy"></figure>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;

using namespace std;

const int N = 2500010;

struct Sum{
	int s, c, d; // 其中s=c*c+d*d
	// 重载运算符
	bool operator&lt; (const Sum &amp;t) const {
		if (s != t.s) return s &lt; t.s;
		if (c != t.c) return c &lt; t.c;
		return d &lt; t.d;
	}
} Sum[N];

int n, m;

int main() {
	cin &gt;&gt; n;
	for (int c = 0; c * c &lt;= n; c ++) {
		for (int d = c; c * c + d * d &lt;= n; d ++) {
			Sum[m++] = {c * c + d * d, c, d};
		}
	}
	// 对存储的sum进行排序
	sort(Sum, Sum + m);
	
	for (int a = 0; a * a &lt;= n; a ++) {
		for (int b = 0; a * a + b * b &lt;= n; b ++) {
			int t = n - a * a - b * b;
			int l = 0, r = m - 1;
			// 二分查找 
			while (l &lt; r) {
				int mid = (l + r) &gt;&gt; 1;
				if (Sum[mid].s &gt;= t) r = mid;
				else l = mid + 1;
			}
			if (t == Sum[l].s) {
				printf(&quot;%d %d %d %d&quot;, a, b, Sum[l].c, Sum[l].d);
				return 0;
			}
		}
	}
	
	return 0; 
}
</code></pre>
<h3 id="习题-1227-分巧克力">习题 1227. 分巧克力</h3>
<p><a href="https://www.acwing.com/problem/content/1229/">1227. 分巧克力</a></p>
<figure data-type="image" tabindex="34"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230120163921397.png" alt="image-20230120163921397" loading="lazy"></figure>
<figure data-type="image" tabindex="35"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230120164939813.png" alt="image-20230120164939813" loading="lazy"></figure>
<ul>
<li>块数大于等于K的最大边长</li>
</ul>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;

using namespace std;

const int N = 100010;

int n, k;
int h[N], w[N];

bool check(int mid) {
	int res = 0;
	for (int i = 0; i &lt; n; i ++) {
		res += (h[i] / mid) * (w[i] / mid);
		if (res &gt;= k) return true;
	}
	return false;
}


int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
	for (int i = 0; i &lt; n; i ++) scanf(&quot;%d%d&quot;, &amp;h[i], &amp;w[i]); // 输入每块的长与宽
	
	int l = 1, r = 100000;
	while (l &lt; r) {
		int mid = l + r + 1&gt;&gt; 1;
		if (check(mid)) l = mid;
		else r = mid - 1; 
	}
	printf(&quot;%d&quot;, l);
	
	return 0;
}
</code></pre>
<h2 id="前缀和">前缀和</h2>
<h3 id="一维前缀和">一维前缀和</h3>
<figure data-type="image" tabindex="36"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230120224820456.png" alt="image-20230120224820456" loading="lazy"></figure>
<ul>
<li>只能<strong>处理静态数据，不能修改数据</strong>(只能查询不能修改)</li>
</ul>
<h3 id="二维前缀和">二维前缀和</h3>
<p>求一个子矩阵内的和</p>
<ul>
<li>前缀和矩阵：表示左上角所有数的和</li>
</ul>
<figure data-type="image" tabindex="37"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230129145240479.png" alt="image-20230129145240479" loading="lazy"></figure>
<ul>
<li>
<p>如何计算前缀和矩阵：容斥原理</p>
<ul>
<li>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>x</mi><mi>y</mi></mrow></msub><mo>=</mo><msub><mi>S</mi><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>S</mi><mrow><mi>x</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi></mrow></msub><mo>−</mo><msub><mi>S</mi><mrow><mi>x</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>a</mi><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow></msub></mrow><annotation encoding="application/x-tex">S_{xy} = S_{x,y - 1} + S_{x - 1, y}- S_{x- 1, y - 1}+a_{x, y}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
</li>
<li>
<figure data-type="image" tabindex="38"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230129145609537.png" alt="image-20230129145609537" loading="lazy"></figure>
</li>
</ul>
</li>
<li>
<p>如何计算子矩阵的和：</p>
<ul>
<li>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub></mrow></msub><mo>−</mo><msub><mi>S</mi><mrow><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mrow><msub><mi>y</mi><mn>1</mn></msub><mo>−</mo><mn>1</mn></mrow></mrow></msub><mo>−</mo><msub><mi>S</mi><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>−</mo><mn>1</mn><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub></mrow></msub><mo>+</mo><msub><mi>S</mi><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>−</mo><mn>1</mn><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">S_{x_2,y_2} - S_{x_2, {y_1 - 1}} - S_{x_1 - 1, y_2} + S_{x_1 - 1, y_2 - 1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
</li>
<li>
<figure data-type="image" tabindex="39"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230129145934338.png" alt="image-20230129145934338" loading="lazy"></figure>
</li>
</ul>
</li>
</ul>
<h3 id="例题-795-前缀和">例题 795. 前缀和</h3>
<p><a href="https://www.acwing.com/problem/content/797/">795. 前缀和</a></p>
<figure data-type="image" tabindex="40"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230129143639574.png" alt="image-20230129143639574" loading="lazy"></figure>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;

using namespace std;

const int N = 1000010;

int n, m;
int a[N]; // 表示原数组 
int s[N]; // 表示前缀和数组

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m); 
	for (int i = 1; i &lt;= n; i ++) {
		scanf(&quot;%d&quot;, &amp;a[i]); // 读取原的数组
		s[i] = s[i - 1] + a[i]; // 初始化前缀和数组
	}
	
	while (m --) {
		int l, r;
		scanf(&quot;%d%d&quot;, &amp;l, &amp;r);
		printf(&quot;%d\n&quot;, s[r] - s[l - 1]);
	}
	
	return 0;
}
</code></pre>
<h3 id="例题-796-子矩阵的和">例题 796. 子矩阵的和</h3>
<p><a href="https://www.acwing.com/problem/content/798/">796. 子矩阵的和</a></p>
<figure data-type="image" tabindex="41"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230129144630859.png" alt="image-20230129144630859" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N =  1010;
int n, m, q;
int a[N][N], s[N][N];

int main()
{
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q);
    
    for (int i = 1; i &lt;= n; i ++ ) {
        for (int j = 1; j &lt;= m; j ++ ) {
            scanf(&quot;%d&quot;, &amp;a[i][j]); // 输入原数组
            s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j -1] + a[i][j];
        }
    }
    
    // 处理询问
    while (q -- ) {
        int x1, x2, y1, y2;
        scanf(&quot;%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);
        printf(&quot;%d\n&quot;, s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 -1] + s[x1 - 1][y1 - 1]);
    }
    
    return 0;
}
</code></pre>
<h3 id="习题-99-激光炸弹">习题 99. 激光炸弹</h3>
<p><a href="https://www.acwing.com/problem/content/101/">99. 激光炸弹</a></p>
<figure data-type="image" tabindex="42"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230129151237410.png" alt="image-20230129151237410" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;

using namespace std;

const int N = 5010;

int n, m;

int s[N][N];

int main() {
    int cnt, R;
    scanf(&quot;%d%d&quot;, &amp;cnt, &amp;R);
    
    R = min(5001, R);
    
    n = m = R;
    
    while (cnt -- ) {
        int x, y, w;
        scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;w);
        x ++, y ++; // 保证前缀和坐标从1 开始
        n = max(x, n), m = max(y, m);
        s[x][y] += w; 
    }
    
    // 预处理前缀和
    for (int i = 1; i &lt;= n; i ++ ) {
        for (int j = 1; j &lt;= m; j ++ ) {
            s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];
        }
    }
    
    int res = 0;
    for (int i = R; i &lt;= n; i ++) {
        for (int j = R; j &lt;= m; j ++) {
            res = max(res, s[i][j] - s[i][j - R] - s[i - R][j] + s[i - R][j - R]);
        }
    }
    
    printf(&quot;%d\n&quot;, res);
    
    return 0;
}
</code></pre>
<h3 id="习题-1230-k倍区间">习题 1230. K倍区间</h3>
<p><a href="https://www.acwing.com/problem/content/1232/">1230. K倍区间</a></p>
<figure data-type="image" tabindex="43"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230129151339797.png" alt="image-20230129151339797" loading="lazy"></figure>
<figure data-type="image" tabindex="44"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230129170108442.png" alt="image-20230129170108442" loading="lazy"></figure>
<ul>
<li><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230129170841638.png" alt="image-20230129170841638" loading="lazy"></li>
</ul>
<figure data-type="image" tabindex="46"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230129171642817.png" alt="image-20230129171642817" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 100010;
typedef long long LL;

LL a[N], s[N], cnt[N];
int n, k;


int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
    for (int i = 1; i &lt;= n; i ++ ) {
        scanf(&quot;%lld&quot;, &amp;a[i]);
        s[i] = s[i - 1] + a[i];
    }
    LL res = 0;
    
    cnt[0] = 1;
    for (int i = 1; i &lt;= n; i ++ ) {
        res += cnt[s[i] % k];
        cnt[s[i] % k] ++;
    }
    
    printf(&quot;%lld\n&quot;, res);
    
    return 0;
}
</code></pre>
<h1 id="数学与简单dp">数学与简单DP</h1>
<h2 id="数学">数学</h2>
<h3 id="例题-1205-买不到的数目">例题 1205. 买不到的数目</h3>
<p><a href="https://www.acwing.com/problem/content/1207/">1205. 买不到的数目</a></p>
<ul>
<li>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">如</mi><mi mathvariant="normal">果</mi><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mi mathvariant="normal">均</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">正</mi><mi mathvariant="normal">整</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">且</mi><mi mathvariant="normal">互</mi><mi mathvariant="normal">质</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">那</mi><mi mathvariant="normal">么</mi><mi mathvariant="normal">由</mi><mi>a</mi><mi>x</mi><mi mathvariant="normal">十</mi><mi>b</mi><mi>y</mi><mo separator="true">,</mo><mi>x</mi><mo>≥</mo><mn>0</mn><mi mathvariant="normal">，</mi><mi>y</mi><mo>≥</mo><mn>0</mn><mi mathvariant="normal">不</mi><mi mathvariant="normal">能</mi><mi mathvariant="normal">凑</mi><mi mathvariant="normal">出</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">最</mi><mi mathvariant="normal">大</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">是</mi><mi>a</mi><mi>b</mi><mi mathvariant="normal">一</mi><mi>a</mi><mi mathvariant="normal">一</mi><mi>b</mi><mi mathvariant="normal">。</mi></mrow><annotation encoding="application/x-tex">如果a,b均是正整数且互质，那么由ax十by,x≥0，y≥0不能凑出的最大数是ab一a一b。
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">果</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mord cjk_fallback">均</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">正</span><span class="mord cjk_fallback">整</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">且</span><span class="mord cjk_fallback">互</span><span class="mord cjk_fallback">质</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">那</span><span class="mord cjk_fallback">么</span><span class="mord cjk_fallback">由</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">十</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">能</span><span class="mord cjk_fallback">凑</span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">大</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">是</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord cjk_fallback">一</span><span class="mord mathdefault">a</span><span class="mord cjk_fallback">一</span><span class="mord mathdefault">b</span><span class="mord cjk_fallback">。</span></span></span></span></span></p>
</li>
</ul>
<figure data-type="image" tabindex="47"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230129204554603.png" alt="image-20230129204554603" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

int n, m;
typedef long long LL;

int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    LL res = (LL)n * m - n -m;
    printf(&quot;%lld&quot;, res);
    
    return 0;
}
</code></pre>
<h3 id="例题-1211-蚂蚁感冒">例题 1211. 蚂蚁感冒</h3>
<p><a href="https://www.acwing.com/problem/content/1213/">1211. 蚂蚁感冒</a></p>
<figure data-type="image" tabindex="48"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230129210443101.png" alt="image-20230129210443101" loading="lazy"></figure>
<figure data-type="image" tabindex="49"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230129211316883.png" alt="image-20230129211316883" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 110;
int n;
int x[N];

int main()
{
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;x[i]);
    
    int left = 0, right = 0; // 分别表示左边向右走 和 右边向左走的 蚂蚁的数量
    for (int i = 0; i &lt; n; i ++ ) {
        if (abs(x[i]) &lt; abs(x[0]) &amp;&amp; x[i] &gt; 0) left ++;
        else if (abs(x[i]) &gt; abs(x[0]) &amp;&amp; x[i] &lt; 0) right ++;
    }
    
    if (x[0] &lt; 0 &amp;&amp; left == 0 || x[0] &gt; 0 &amp;&amp; right == 0) printf(&quot;%d\n&quot;, 1);
    else printf(&quot;%d&quot;, left + right + 1);
    
    return 0;
}
</code></pre>
<h3 id="例题-1216-饮料换购">例题 1216. 饮料换购</h3>
<p><a href="https://www.acwing.com/problem/content/1218/">1216. 饮料换购</a></p>
<figure data-type="image" tabindex="50"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230130132541351.png" alt="image-20230130132541351" loading="lazy"></figure>
<ul>
<li>
<p>模拟</p>
<ul>
<li><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230130132715913.png" alt="image-20230130132715913" loading="lazy"></li>
</ul>
</li>
<li>
<p>思路</p>
<ul>
<li><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230130132914119.png" alt="image-20230130132914119" loading="lazy"></li>
</ul>
</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;


int n;
int main()
{
    scanf(&quot;%d&quot;, &amp;n);
    int res = n;
    while (n &gt;= 3 ) {
        res += n / 3;
        n = n % 3 + n / 3;
    }
    
    printf(&quot;%d&quot;, res);
    
    return 0;
}
</code></pre>
<h2 id="简单dp">简单DP</h2>
<h3 id="01背包问题">01背包问题</h3>
<ul>
<li>每个物品最多用1次</li>
</ul>
<ol>
<li>状态表示 f(i, j)
<ol>
<li>集合</li>
<li>属性：max、min、数量</li>
</ol>
</li>
<li>状态计算 (如何把每一步的状态计算出来)</li>
</ol>
<h3 id="例题-2-01背包问题">例题 2. 01背包问题</h3>
<p><a href="https://www.acwing.com/problem/content/2/">2. 01背包问题</a></p>
<figure data-type="image" tabindex="53"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230130145004998.png" alt="image-20230130145004998" loading="lazy"></figure>
<figure data-type="image" tabindex="54"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230130220732663.png" alt="image-20230130220732663" loading="lazy"></figure>
<figure data-type="image" tabindex="55"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230130144955793.png" alt="image-20230130144955793" loading="lazy"></figure>
<figure data-type="image" tabindex="56"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230130150025911.png" alt="image-20230130150025911" loading="lazy"></figure>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mo separator="true">,</mo><mi>f</mi><mo>(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><msub><mi>v</mi><mi>i</mi></msub><mo>)</mo><mo>+</mo><msub><mi>w</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">f(i, j) = max(f(i - 1, j), f(i - 1, j - v_i)+w_i)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<ul>
<li>二维写法</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 1010;

int n, m; // 表示物品数量和背包容积
int v[N], w[N];
int f[N][N];

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m); 
    for (int i = 1; i &lt;= n; i ++ ) {
        scanf(&quot;%d%d&quot;, &amp;v[i], &amp;w[i]);
    }
    
    // 由于 f[0][0~m] 表示选0个的最大价值，故都为0
    for (int i = 1; i &lt;= n; i ++ ) {
        for (int j = 0; j &lt;= m; j ++ ) {
            f[i][j] = f[i - 1][j];
            // 如果 j &gt; v[i] 则表示还可以放第i个
            if (j &gt;= v[i] ) {
                f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);
            }
        }
    }
    printf(&quot;%d&quot;, f[n][m]);
    
    return 0;
}
</code></pre>
<ul>
<li>一维写法（f(i) 只用到了f(i - 1））可以使用滚动数组</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 1010;

int n, m; // 表示物品数量和背包容积
int v[N], w[N];
int f[N];

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m); 
    for (int i = 1; i &lt;= n; i ++ ) {
        scanf(&quot;%d%d&quot;, &amp;v[i], &amp;w[i]);
    }
    
    for (int i = 1; i &lt;= n; i ++ ) {
        for (int j = m; j &gt;= v[i]; j --) 
            f[j] = max(f[j], f[j - v[i]] + w[i]);
    }
    printf(&quot;%d&quot;, f[m]);
    
    return 0;
}
</code></pre>
<h3 id="例题-1015-摘花生">例题 1015. 摘花生</h3>
<p><a href="https://www.acwing.com/problem/content/1017/">1015. 摘花生</a></p>
<p>Hello Kitty想摘点花生送给她喜欢的米老鼠。</p>
<p>她来到一片有网格状道路的矩形花生地(如下图)，从西北角进去，东南角出来。</p>
<p>地里每个道路的交叉点上都有种着一株花生苗，上面有若干颗花生，经过一株花生苗就能摘走该它上面所有的花生。</p>
<p>Hello Kitty只能向东或向南走，不能向西或向北走。</p>
<p>问Hello Kitty最多能够摘到多少颗花生。</p>
<figure data-type="image" tabindex="57"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/19_a8509f26d5-1.gif" alt="1.gif" loading="lazy"></figure>
<h4 id="输入格式-2">输入格式</h4>
<p>第一行是一个整数T，代表一共有多少组数据。</p>
<p>接下来是T组数据。</p>
<p>每组数据的第一行是两个整数，分别代表花生苗的行数R和列数 C。</p>
<p>每组数据的接下来R行数据，从北向南依次描述每行花生苗的情况。每行数据有C个整数，按从西向东的顺序描述了该行每株花生苗上的花生数目M。</p>
<h4 id="输出格式-2">输出格式</h4>
<p>对每组输入数据，输出一行，内容为Hello Kitty能摘到得最多的花生颗数。</p>
<h4 id="数据范围-2">数据范围</h4>
<p>1≤T≤100<br>
1≤R,C≤100<br>
0≤M≤1000</p>
<h4 id="输入样例-2">输入样例：</h4>
<pre><code>2
2 2
1 1
3 4
2 3
2 3 4
1 6 5
</code></pre>
<h4 id="输出样例-2">输出样例：</h4>
<pre><code>8
16
</code></pre>
<figure data-type="image" tabindex="58"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230130221623273.png" alt="image-20230130221623273" loading="lazy"></figure>
<ul>
<li>
<p>状态表示</p>
<ul>
<li><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230130165947282.png" alt="image-20230130165947282" loading="lazy"></li>
</ul>
</li>
<li>
<p>状态计算</p>
<ul>
<li><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230130170618569.png" alt="image-20230130170618569" loading="lazy"></li>
</ul>
</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 110;

int n, m;
int w[N][N];
int f[N][N];

int main()
{
    int T;
    scanf(&quot;%d&quot;, &amp;T);
    
    while (T --) {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m); 
        // 初始化权重数组
        
        for (int i = 1; i &lt;= n; i ++ )
            for (int j = 1; j &lt;= m; j ++ ) 
                scanf(&quot;%d&quot;, &amp;w[i][j]);
        
        // 进行dp
        for (int i = 1; i &lt;= n; i ++ ) {
            for (int j = 1; j &lt;= m; j ++ ) {
                f[i][j] = max(f[i - 1][j], f[i][j - 1]) + w[i][j];
            }
        }
        
        printf(&quot;%d\n&quot;, f[n][m]);
    }
    return 0;
}
</code></pre>
<h3 id="例题-895-最长上升子序列">例题 895. 最长上升子序列</h3>
<p><a href="https://www.acwing.com/problem/content/897/">895. 最长上升子序列 </a></p>
<p>给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少。</p>
<h4 id="输入格式-3">输入格式</h4>
<p>第一行包含整数 N。</p>
<p>第二行包含 N 个整数，表示完整序列。</p>
<h4 id="输出格式-3">输出格式</h4>
<p>输出一个整数，表示最大长度。</p>
<h4 id="数据范围-3">数据范围</h4>
<p>1≤N≤1000，<br>
−10<sup>9≤数列中的数≤10</sup>9</p>
<h4 id="输入样例-3">输入样例：</h4>
<pre><code>7
3 1 2 1 8 5 6
</code></pre>
<h4 id="输出样例-3">输出样例：</h4>
<pre><code>4
</code></pre>
<figure data-type="image" tabindex="61"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230130183608958.png" alt="image-20230130183608958" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 1010;

int n;
int a[N], f[N];

int main()
{
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]);
    
    // dp
    for (int i = 1; i &lt;= n; i ++ ) {
        f[i] = 1;
        for (int j = 1; j &lt; i; j ++) {
            if (a[j] &lt; a[i]) f[i] = max(f[i], f[j] + 1);
        }
    }
    
    // 寻找最大值
    int res = 0;
    for (int i = 1; i &lt;= n; i ++ ) res = max(res, f[i]);
    
    printf(&quot;%d&quot;, res);
    
    return 0;
}
</code></pre>
<h3 id="习题-1212-地宫取宝">习题 1212. 地宫取宝</h3>
<p><a href="https://www.acwing.com/problem/content/1214/">1212. 地宫取宝</a></p>
<p>X 国王有一个地宫宝库，是 n×m个格子的矩阵，每个格子放一件宝贝，每个宝贝贴着价值标签。</p>
<p>地宫的入口在左上角，出口在右下角。</p>
<p>小明被带到地宫的入口，国王要求他只能向右或向下行走。</p>
<p>走过某个格子时，如果那个格子中的宝贝价值比小明手中任意宝贝价值都大，小明就可以拿起它（当然，也可以不拿）。</p>
<p>当小明走到出口时，如果他手中的宝贝恰好是 k件，则这些宝贝就可以送给小明。</p>
<p>请你帮小明算一算，在给定的局面下，他有多少种不同的行动方案能获得这 k件宝贝。</p>
<h4 id="输入格式-4">输入格式</h4>
<p>第一行 33 个整数，n,m,k，含义见题目描述。</p>
<p>接下来 n行，每行有 m个整数 Ci用来描述宝库矩阵每个格子的宝贝价值。</p>
<h4 id="输出格式-4">输出格式</h4>
<p>输出一个整数，表示正好取 k� 个宝贝的行动方案数。</p>
<p>该数字可能很大，输出它对 10000000071000000007 取模的结果。</p>
<h4 id="数据范围-4">数据范围</h4>
<p>1≤n,m≤50<br>
1≤k≤12<br>
0≤Ci≤12</p>
<h4 id="输入样例1">输入样例1：</h4>
<pre><code>2 2 2
1 2
2 1
</code></pre>
<h4 id="输出样例1">输出样例1：</h4>
<pre><code>2
</code></pre>
<h4 id="输入样例2">输入样例2：</h4>
<pre><code>2 3 2
1 2 3
2 1 5
</code></pre>
<h4 id="输出样例2">输出样例2：</h4>
<pre><code>14
</code></pre>
<figure data-type="image" tabindex="62"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230130225212156.png" alt="image-20230130225212156" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 55, MOD = 1000000007;

int n, m, k;
int w[N][N];
int f[N][N][13][14];

int main()
{
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);
    // 初始化权重矩阵
    
    for (int i = 1; i &lt;= n; i ++) {
        for (int j = 1; j &lt;= m; j ++) {
            scanf(&quot;%d&quot;, &amp;w[i][j]);
            w[i][j] ++; // 防止出现-1 错误
        }
    }
    
    // 边界初始化
    f[1][1][1][w[1][1]] = 1;  // 第一个取
    f[1][1][0][0] = 1;
    
    // dp
    for (int i = 1; i &lt;= n; i ++) {
        for (int j = 1; j &lt;= m ; j ++) {
            if (i == 1 &amp;&amp; j == 1) continue;
            for (int u = 0; u &lt;= k; u ++) {
                for (int v = 0; v &lt;= 13; v ++) {
                    int &amp;val = f[i][j][u][v];
                    val = (val + f[i - 1][j][u][v]) % MOD;
                    val = (val + f[i][j - 1][u][v]) % MOD;
                    if (u &gt; 0 &amp;&amp; w[i][j] == v) {
                        for (int c = 0; c &lt; v; c ++) {
                            val = (val + f[i - 1][j][u - 1][c]) % MOD;
                            val = (val + f[i][j - 1][u - 1][c]) % MOD;
                        }
                    }
                }
            }
        }
    }
    
    int res = 0;
    for (int i = 0; i &lt;= 13; i ++) {
        res = (res + f[n][m][k][i]) % MOD;
    }
    
    printf(&quot;%d&quot;, res);
    
    return 0;
}
</code></pre>
<h3 id="习题-1214-波动数列">习题 1214. 波动数列</h3>
<p><a href="https://www.acwing.com/problem/content/1216/">1214. 波动数列</a></p>
<p>观察这个数列：</p>
<p>1 3 0 2 -1 1 -2 …</p>
<p>这个数列中后一项总是比前一项增加2或者减少3，<strong>且每一项都为整数</strong>。</p>
<p>栋栋对这种数列很好奇，他想知道长度为 n 和为 s 而且后一项总是比前一项增加 a或者减少 b的整数数列可能有多少种呢？</p>
<h4 id="输入格式-5">输入格式</h4>
<p>共一行，包含四个整数 n,s,a,b，含义如前面所述。</p>
<h4 id="输出格式-5">输出格式</h4>
<p>共一行，包含一个整数，表示满足条件的方案数。</p>
<p>由于这个数很大，请输出方案数除以 100000007 的余数。</p>
<h4 id="数据范围-5">数据范围</h4>
<p>1≤n≤1000<br>
−10<sup>9≤s≤10</sup>9<br>
1≤a,b≤10^6</p>
<h4 id="输入样例-4">输入样例：</h4>
<pre><code>4 10 2 3
</code></pre>
<h4 id="输出样例-4">输出样例：</h4>
<pre><code>2
</code></pre>
<h4 id="样例解释">样例解释</h4>
<p>两个满足条件的数列分别是2 4 1 3和7 4 1 -2。</p>
<figure data-type="image" tabindex="63"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230131000506977.png" alt="image-20230131000506977" loading="lazy"></figure>
<figure data-type="image" tabindex="64"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230131001018359.png" alt="image-20230131001018359" loading="lazy"></figure>
<figure data-type="image" tabindex="65"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230131001028462.png" alt="image-20230131001028462" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 1010, MOD = 100000007;
int f[N][N];

int get_mod(int a, int b) {
    return (a % b + b) % b;
}

int main()
{
    int n, s, a, b;
    scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;s, &amp;a, &amp;b);
    
    f[0][0] = 1;
    for (int i = 1; i &lt; n; i ++) {
        for (int j = 0; j &lt; n; j ++) // j 表示余数，取值范围从0~n-1 
            f[i][j] = (f[i - 1][get_mod(j - i * a, n)] + f[i - 1][get_mod(j + i * b, n)]) % MOD;
    }
    
    printf(&quot;%d&quot;, f[n - 1][get_mod(s, n)]);
    
    return 0;
}
</code></pre>
<h1 id="枚举-模拟与排序">枚举、模拟与排序</h1>
<h2 id="枚举">枚举</h2>
<h3 id="例题-1210-连号区间数">例题 1210. 连号区间数</h3>
<p><a href="https://www.acwing.com/problem/content/1212/">1210. 连号区间数</a></p>
<p>小明这些天一直在思考这样一个奇怪而有趣的问题：</p>
<p>在 1∼N 的某个排列中有多少个连号区间呢？</p>
<p>这里所说的连号区间的定义是：</p>
<p>如果区间 [L,R][�,�] 里的所有元素（即此排列的第 L个到第 R个元素）递增排序后能得到一个长度为 R−L+1的“连续”数列，则称这个区间连号区间。</p>
<p>当 N很小的时候，小明可以很快地算出答案，但是当 N变大的时候，问题就不是那么简单了，现在小明需要你的帮助。</p>
<h4 id="输入格式-6">输入格式</h4>
<p>第一行是一个正整数 N，表示排列的规模。</p>
<p>第二行是 N 个不同的数字 Pi，表示这 N个数字的某一排列。</p>
<h4 id="输出格式-6">输出格式</h4>
<p>输出一个整数，表示不同连号区间的数目。</p>
<h4 id="数据范围-6">数据范围</h4>
<p>1≤N≤10000,<br>
1≤Pi≤N1</p>
<h4 id="输入样例1-2">输入样例1：</h4>
<pre><code>4
3 2 4 1
</code></pre>
<h4 id="输出样例1-2">输出样例1：</h4>
<pre><code>7
</code></pre>
<h4 id="输入样例2-2">输入样例2：</h4>
<pre><code>5
3 4 2 5 1
</code></pre>
<h4 id="输出样例2-2">输出样例2：</h4>
<pre><code>9
</code></pre>
<h4 id="样例解释-2">样例解释</h4>
<p>第一个用例中，有 77 个连号区间分别是：[1,1],[1,2],[1,3],[1,4],[2,2],[3,3],[4,4]<br>
第二个用例中，有 99 个连号区间分别是：[1,1],[1,2],[1,3],[1,4],[1,5],[2,2],[3,3],[4,4],[5,5]</p>
<figure data-type="image" tabindex="66"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230131185746568.png" alt="image-20230131185746568" loading="lazy"></figure>
<ul>
<li>
<p>暴力做法</p>
<ul>
<li><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230131185917643.png" alt="image-20230131185917643" loading="lazy"></li>
</ul>
</li>
<li>
<p>优化</p>
<ul>
<li>[a, b] 区间Max - Min == b - a</li>
<li><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230131190528380.png" alt="image-20230131190528380" loading="lazy"></li>
</ul>
</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 10010, INF = 1e9; //  定义最大值

int n;
int a[N];

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;a[i]);

	int res = 0;
	for (int i = 0; i &lt; n; i ++) {
		int maxv = -INF, minv = INF;
		for (int j = i; j &lt; n; j ++) {
			// 更新 最大值和最小值
			maxv = max(maxv, a[j]);
			minv = min(minv, a[j]);
			// 判断是否满足连号区间的条件
			if ((maxv - minv) == (j - i)) res ++;
		}
	}

	printf(&quot;%d\n&quot;, res);

	return 0;
}
</code></pre>
<h3 id="例题-1236-递增三元组">例题 1236. 递增三元组</h3>
<p><a href="https://www.acwing.com/problem/content/1238/">1236. 递增三元组</a></p>
<figure data-type="image" tabindex="69"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230131192135472.png" alt="image-20230131192135472" loading="lazy"></figure>
<figure data-type="image" tabindex="70"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230131194737449.png" alt="image-20230131194737449" loading="lazy"></figure>
<ul>
<li>暴力做法（3重for 循环）</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 10010; //  定义最大值

int n;
int a[N], b[N], c[N];

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;a[i]);
	for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;b[i]);
	for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;c[i]);

	int res = 0;
	
	for (int i = 0; i &lt; n; i ++) {
		for (int j = 0; j &lt; n; j ++) {
			for (int k = 0; k &lt; n; k ++) {
				if (a[i] &lt; b[j] &amp;&amp; b[j] &lt; c[k]) res ++;
			}
		}
	}

	printf(&quot;%d\n&quot;, res);

	return 0;
}
</code></pre>
<ul>
<li>优化-方法1（前缀和）
<ul>
<li>使用cnt数组，cnt[i] 表示在A 中，i 这个值出现多少次</li>
<li>前缀和数组 s， s[i] = cnt[0] + cnt[1] + .. + cnt[i - 1] + cnt[i]，表示A中，从0-i 出现多少次</li>
</ul>
</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 1e5+10;
typedef long long LL;

int n;
int a[N], b[N], c[N];
int as[N], cs[N];
int cnt[N], s[N]; // cnt[a[i]] 表示在数组a[]中a[i] 出现的次数

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	// a[i] 数据范围从0~1e5，故每项++，可以保证数据均大于0
	for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;a[i]), a[i] ++;
	for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;b[i]), b[i] ++;
	for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;c[i]), c[i] ++;

	// 处理A
	for (int i = 0; i &lt; n; i ++) cnt[a[i]] ++;
	for (int i = 1; i &lt; N; i ++) s[i] = s[i - 1] + cnt[i];

	for (int i = 0; i &lt; n; i ++) as[i] = s[b[i] - 1];

	// 清空cnt 与 s，处理C
	memset(cnt, 0, sizeof cnt);
	memset(s, 0, sizeof s);

	for (int i = 0; i &lt; n; i ++) cnt[c[i]] ++;
	for (int i = 1; i &lt; N; i ++) s[i] = s[i - 1] + cnt[i];

	for (int i = 0; i &lt; n; i ++) cs[i] = s[N - 1] - s[b[i]];

	// 统计答案
	LL res = 0;
	
	for (int i = 0; i &lt; n; i ++) res += (LL) as[i] * cs[i];

	cout &lt;&lt; res &lt;&lt; endl;

	return 0;
}
</code></pre>
<ul>
<li>优化-方法2（排序 + 二分）</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

const int N = 1e5 + 5;
int a[N], b[N], c[N];
int n;

int main() {
    long long res = 0;
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i];
    for (int i = 0; i &lt; n; ++i) cin &gt;&gt; b[i];
    for (int i = 0; i &lt; n; ++i) cin &gt;&gt; c[i];

    sort(a, a + n), sort(b, b + n), sort(c, c + n); // 排序
    for (int i = 0; i &lt; n; ++i) {
        // 计算a比b小个数
        int t = b[i];
        int l = 0, r = n - 1;
        long long cnt = 1;
        while (l &lt; r) {
            int mid = l + r &gt;&gt; 1;
            if (a[mid] &gt;= t) r = mid;
            else l = mid + 1;
        }
        if (a[l] &gt;= t)
            cnt *= l;
        else cnt = n;

        // 计算c比b大个数
        t = b[i];
        l = 0, r = n - 1;
        while (l &lt; r) {
            int mid = l + r &gt;&gt; 1;
            if (c[mid] &gt; t) r = mid;
            else l = mid + 1;
        }
        if (c[l] &gt; t)
            cnt *= n - l;
        else continue;

        res += cnt;
    }
    cout &lt;&lt; res &lt;&lt; endl;
}
</code></pre>
<h3 id="例题-1245-特别数的和">例题 1245. 特别数的和</h3>
<p><a href="https://www.acwing.com/problem/content/1247/">1245. 特别数的和</a></p>
<figure data-type="image" tabindex="71"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230131220547202.png" alt="image-20230131220547202" loading="lazy"></figure>
<ul>
<li>暴力做法</li>
<li><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230131221243207.png" alt="image-20230131221243207" loading="lazy"></li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

int n;

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	int res = 0;
	for (int i = 1; i &lt;= n; i ++) {
		int x = i;
		// 将数字的每位取出来
		while (x) {
			int t = x % 10;
			x /= 10;
			if (t == 2 || t == 0 || t == 1 || t == 9) {
				res += i;
				break; // 找到即可退出取数的循环
			}
		}
	}
	printf(&quot;%d&quot;, res);

	return 0;
}
</code></pre>
<h3 id="例题-1204-错误票据">例题 1204. 错误票据</h3>
<p><a href="https://www.acwing.com/problem/content/1206/">1204. 错误票据</a></p>
<p>某涉密单位下发了某种票据，并要在年终全部收回。</p>
<p>每张票据有唯一的ID号。</p>
<p>全年所有票据的ID号是连续的，但ID的开始数码是随机选定的。</p>
<p>因为工作人员疏忽，在录入ID号的时候发生了一处错误，造成了某个ID断号，另外一个ID重号。</p>
<p>你的任务是通过编程，找出断号的ID和重号的ID。</p>
<p>假设断号不可能发生在最大和最小号。</p>
<h4 id="输入格式-7">输入格式</h4>
<p>第一行包含整数 N，表示后面共有 N行数据。</p>
<p>接下来 N行，每行包含空格分开的若干个（不大于100个）正整数（不大于100000），每个整数代表一个ID号。</p>
<h4 id="输出格式-7">输出格式</h4>
<p>要求程序输出1行，含两个整数 m,n，用空格分隔。</p>
<p>其中，m表示断号ID，n表示重号ID。</p>
<h4 id="数据范围-7">数据范围</h4>
<p>1≤N≤100</p>
<h4 id="输入样例-5">输入样例：</h4>
<pre><code>2
5 6 8 11 9 
10 12 9
</code></pre>
<h4 id="输出样例-5">输出样例：</h4>
<pre><code>7 9
</code></pre>
<ul>
<li>暴力做法：
<ul>
<li>设置状态数组，遍历后为true的为重号id</li>
<li>然后找到开始的数，从这个数字开始扫描，找到断号id</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="73"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230131233017462.png" alt="image-20230131233017462" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt; // 使用stringstream

using namespace std;

const int N = 10010, M = 100010; 
int n;
int a[N]; // 用于存放数据
bool st[M]; // 用于存放状态

int main() {
	int cnt;
	cin &gt;&gt; cnt;

	string line;
	getline(cin, line); // 由于第一行读入cnt之后，还剩下换行符

	while (cnt --) {
		getline(cin, line);
		stringstream ssin(line); // 类似cin

		while (ssin &gt;&gt; a[n]) n ++; // 依次读取数据
	}
	// 状态数组法
	int c = 0, d = 0;
	for (int i = 0; i &lt; n; i ++) {
		if (st[a[i]]) {
			c = a[i]; 
		}
		st[a[i]] = true; // 找到重号id
	}
	int start = 0;
	while (!st[start]) start ++; // 找到开始的位置

	for (int i = start; ; i ++) {
		if (!st[i]) {
			d = i; // 找到断号id
			break;
		}
	}

	cout &lt;&lt; d &lt;&lt; ' ' &lt;&lt; c &lt;&lt; endl;

	return 0;
}
</code></pre>
<ul>
<li>排序做法
<ul>
<li>排序后从第二个位置开始扫描，每次与前一个数字进行比较</li>
<li>如果相等则为重号id</li>
<li>如果大于等于前一个数字+2，则为断号id</li>
<li><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230131233524786.png" alt="image-20230131233524786" loading="lazy"></li>
</ul>
</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt; // 使用stringstream

using namespace std;

const int N = 10010, M = 100010; 
int n;
int a[N]; // 用于存放数据

int main() {
	int cnt;
	cin &gt;&gt; cnt;

	string line;
	getline(cin, line); // 由于第一行读入cnt之后，还剩下换行符

	while (cnt --) {
		getline(cin, line);
		stringstream ssin(line); // 类似cin

		while (ssin &gt;&gt; a[n]) n ++; // 依次读取数据
	}
	// 排序法
	sort(a, a + n);
	int d, c;
	for (int i = 1; i &lt; n; i ++) {
		if (a[i] == a[i - 1]) c = a[i];
		else if (a[i] &gt;= a[i - 1] + 2) d = a[i] - 1;
	}

	cout &lt;&lt; d &lt;&lt; ' ' &lt;&lt; c &lt;&lt; endl;

	return 0;
}
</code></pre>
<h3 id="例题-466-回文日期">例题 466. 回文日期</h3>
<p><a href="https://www.acwing.com/problem/content/468/">466. 回文日期</a></p>
<figure data-type="image" tabindex="75"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201000806225.png" alt="image-20230201000806225" loading="lazy"></figure>
<ul>
<li>思路：先枚举回文，然后再判断日期是否合法</li>
<li><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201001612097.png" alt="image-20230201001612097" loading="lazy"></li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

int days[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; // 每个月份对应日期
bool check_valid(int date) {
	// 分离年月日
	int year = date / 10000;
	int month = date % 10000 / 100;
	int day = date % 100;
	if (month == 0 || month &gt; 13) return false; // 无效月份
	if (day == 0 || month != 2 &amp;&amp; day &gt; days[month]) return false; // 非2月的无效日期
	if (month == 2) {
		int leap = year % 100 &amp;&amp; year % 4 == 0 || year % 400 == 0; //闰年为1
		if (day &gt; days[month] + leap) return false; // 2月的无效日期
	}
	return true;
}


int main() {
	int date1, date2;
	cin &gt;&gt; date1 &gt;&gt; date2;

	// 开始枚举年份
	int res = 0;
	for (int i = 1000; i &lt;= 9999; i ++) {
		int date = i, x = i;
		for (int i = 0; i &lt; 4; i ++) {
			// 将年份扩展为回文日期
			date = date * 10 + x % 10;
			x /= 10;
		}
		// 判断是否在所求范围内
		if (date1 &lt;= date  &amp;&amp; date &lt;= date2 &amp;&amp; check_valid(date)) res ++;
	}	
	cout &lt;&lt; res &lt;&lt; endl;

	return 0;
}
</code></pre>
<h2 id="排序">排序</h2>
<h3 id="例题-787-归并排序">例题 787. 归并排序</h3>
<p><a href="https://www.acwing.com/problem/content/789/">787. 归并排序</a></p>
<p>给定你一个长度为 n 的整数数列。</p>
<p>请你使用归并排序对这个数列按照从小到大进行排序。</p>
<p>并将排好序的数列按顺序输出。</p>
<h4 id="输入格式-8">输入格式</h4>
<p>输入共两行，第一行包含整数 n。</p>
<p>第二行包含 n个整数（所有整数均在 1∼1091∼109 范围内），表示整个数列。</p>
<h4 id="输出格式-8">输出格式</h4>
<p>输出共一行，包含 n 个整数，表示排好序的数列。</p>
<h4 id="数据范围-8">数据范围</h4>
<p>1≤n≤100000</p>
<h4 id="输入样例-6">输入样例：</h4>
<pre><code>5
3 1 2 4 5
</code></pre>
<h4 id="输出样例-6">输出样例：</h4>
<pre><code>1 2 3 4 5
</code></pre>
<figure data-type="image" tabindex="77"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201130348824.png" alt="image-20230201130348824" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

const int N = 100010;

int n;
int q[N], tmp[N];

void merge_sort(int q[], int l, int r) {
	// 归并排序
	if (l &gt;= r) return ;
	// 递归排序左、右
	int mid = (l + r) &gt;&gt; 1;
	merge_sort(q, l, mid), merge_sort(q, mid + 1, r);

	// 归并
	int k = 0, i = l, j = mid + 1; // k 表示归并的数量
	while (i &lt;= mid &amp;&amp; j &lt;= r) {
		if (q[i] &lt;= q[j]) tmp[k ++] = q[i ++];
		else tmp[k ++] = q[j ++];
	}
	// 合并归并完剩余的内容
	while (i &lt;= mid) tmp[k ++] = q[i ++];
	while (j &lt;= r) tmp[k ++] = q[j ++];

	// 将tmp数组复制回q数组
	for (int i = l, j = 0; i &lt;= r; i ++, j ++) q[i] = tmp[j];
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;q[i]);

	merge_sort(q, 0, n - 1); // 归并排序
	
	for (int i = 0; i &lt; n; i ++) printf(&quot;%d &quot;, q[i]);

	return 0;
}
</code></pre>
<h3 id="习题-1219-移动距离">习题 1219. 移动距离</h3>
<p><a href="https://www.acwing.com/problem/content/1221/">1219. 移动距离</a></p>
<figure data-type="image" tabindex="78"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201132723359.png" alt="image-20230201132723359" loading="lazy"></figure>
<figure data-type="image" tabindex="79"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201140302231.png" alt="image-20230201140302231" loading="lazy"></figure>
<ul>
<li>每个数减少1，如此数字从0开始，坐到与行号（从0开始）一致</li>
</ul>
<figure data-type="image" tabindex="80"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201140743776.png" alt="image-20230201140743776" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;

int main() {
	int w, m, n;
	scanf(&quot;%d%d%d&quot;, &amp;w, &amp;m, &amp;n);

	// 分别计算m 与 n 的坐标
	m --, n --; 
	int x1, y1, x2, y2;
	x1 = m / w, x2 = n / w;

	if (x1 % 2 == 0) y1 = m % w;
	else y1 = w - 1 - m % w;
	if (x2 % 2 == 0) y2 = n % w;
	else y2 = w - 1 - n % w;

	int res = abs(x1 - x2) + abs(y1 - y2);

	printf(&quot;%d\n&quot;, res);

	return 0;
}
</code></pre>
<h3 id="习题-1229-日期问题">习题 1229. 日期问题</h3>
<p><a href="https://www.acwing.com/problem/content/1231/">1229. 日期问题</a></p>
<p>小明正在整理一批历史文献。这些历史文献中出现了很多日期。</p>
<p>小明知道这些日期都在1960年1月1日至2059年12月31日。</p>
<p>令小明头疼的是，这些日期采用的格式非常不统一，有采用年/月/日的，有采用月/日/年的，还有采用日/月/年的。</p>
<p>更加麻烦的是，年份也都省略了前两位，使得文献上的一个日期，存在很多可能的日期与其对应。</p>
<p>比如02/03/04，可能是2002年03月04日、2004年02月03日或2004年03月02日。</p>
<p>给出一个文献上的日期，你能帮助小明判断有哪些可能的日期对其对应吗？</p>
<h4 id="输入格式-9">输入格式</h4>
<p>一个日期，格式是”AA/BB/CC”。</p>
<p>即每个’/’隔开的部分由两个 0-9 之间的数字（不一定相同）组成。</p>
<h4 id="输出格式-9">输出格式</h4>
<p>输出若干个不相同的日期，每个日期一行，格式是”yyyy-MM-dd”。</p>
<p>多个日期按从早到晚排列。</p>
<h4 id="数据范围-9">数据范围</h4>
<p>0≤A,B,C≤9</p>
<h4 id="输入样例-7">输入样例：</h4>
<pre><code>02/03/04
</code></pre>
<h4 id="输出样例-7">输出样例：</h4>
<pre><code>2002-03-04
2004-02-03
2004-03-02
</code></pre>
<figure data-type="image" tabindex="81"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201142952161.png" alt="image-20230201142952161" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;

int a, b, c;
int days[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

bool check_valid(int year, int month, int day) {
	if (month == 0 || month &gt; 12) return false; // 月份无效
	if (month != 2) {
		// 先判断非2月的天数是否有效
		if (day == 0 || day &gt; days[month]) return false;
	} else {
		// 判断2月
		int leap = year % 100 &amp;&amp; year % 4 == 0 || year % 400 == 0; // 闰年
		if (day == 0 || day &gt; days[month] + leap) return false;
	}
	return true;
}

int main() {
	scanf(&quot;%d/%d/%d&quot;, &amp;a, &amp;b, &amp;c); // 表示从a/b/c取得a、b、c
	for (int i = 19600101; i &lt;= 20591231; i ++) {
		int year = i / 10000, month = i % 10000 / 100, day = i % 100;
		if (check_valid(year, month, day)) {
			if (year % 100 == a &amp;&amp; month == b &amp;&amp; day == c || // 年月日表示法
				month == a &amp;&amp; day == b &amp;&amp; year % 100 == c || // 月日年表示法
				day == a &amp;&amp; month == b &amp;&amp; year % 100 == c // 日月年表示法
				) {
				printf(&quot;%d-%02d-%02d\n&quot;, year, month, day);
			}
		}
	}

	return 0;
}
</code></pre>
<h3 id="习题-1231-航班时间">习题 1231. 航班时间</h3>
<p><a href="https://www.acwing.com/problem/content/1233/">1231. 航班时间</a></p>
<p>小 ℎ 前往美国参加了蓝桥杯国际赛。</p>
<p>小 ℎ 的女朋友发现小 ℎ 上午十点出发，上午十二点到达美国，于是感叹到“现在飞机飞得真快，两小时就能到美国了”。</p>
<p>小 ℎ 对超音速飞行感到十分恐惧。</p>
<p>仔细观察后发现飞机的起降时间都是当地时间。</p>
<p>由于北京和美国东部有 12 小时时差，故飞机总共需要 14小时的飞行时间。</p>
<p>不久后小 ℎ 的女朋友去中东交换。</p>
<p>小 ℎ 并不知道中东与北京的时差。</p>
<p>但是小 ℎ 得到了女朋友来回航班的起降时间。</p>
<p>小 ℎ 想知道女朋友的航班飞行时间是多少。</p>
<p>对于一个可能跨时区的航班，给定来回程的起降时间。</p>
<p>假设飞机来回飞行时间相同，求飞机的飞行时间。</p>
<h4 id="输入格式-10">输入格式</h4>
<p>一个输入包含多组数据。</p>
<p>输入第一行为一个正整数 T，表示输入数据组数。</p>
<p>每组数据包含两行，第一行为去程的起降时间，第二行为回程的起降时间。</p>
<p>起降时间的格式如下:</p>
<ol>
<li>h1:m1:s1 h2:m2:s2</li>
<li>h1:m1:s1 h3:m3:s3 (+1)</li>
<li>h1:m1:s1 h4:m4:s4 (+2)</li>
</ol>
<p>第一种格式表示该航班在<strong>当地</strong>时间h1时m1分s1秒起飞，在<strong>当地</strong>时间<strong>当日</strong>h2时m2分s2秒降落。</p>
<p>第二种格式表示该航班在<strong>当地</strong>时间h1时m1分s1秒起飞，在<strong>当地</strong>时间<strong>次日</strong>h2时m2分s2秒降落。</p>
<p>第三种格式表示该航班在<strong>当地</strong>时间h1时m1分s1秒起飞，在<strong>当地</strong>时间<strong>第三日</strong>h2时m2分s2秒降落。</p>
<h4 id="输出格式-10">输出格式</h4>
<p>对于每一组数据输出一行一个时间hh:mm:ss，表示飞行时间为hh小时mm分ss秒。</p>
<p>注意，当时间为一位数时，要补齐前导零，如三小时四分五秒应写为03:04:05。</p>
<h4 id="数据范围-10">数据范围</h4>
<p>保证输入时间合法（0≤h≤23,0≤m,s≤59），飞行时间不超过24小时。</p>
<h4 id="输入样例-8">输入样例：</h4>
<pre><code>3
17:48:19 21:57:24
11:05:18 15:14:23
17:21:07 00:31:46 (+1)
23:02:41 16:13:20 (+1)
10:19:19 20:41:24
22:19:04 16:41:09 (+1)
</code></pre>
<h4 id="输出样例-8">输出样例：</h4>
<pre><code>04:09:05
12:10:39
14:22:05
</code></pre>
<figure data-type="image" tabindex="82"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201152436097.png" alt="image-20230201152436097" loading="lazy"></figure>
<figure data-type="image" tabindex="83"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201152821548.png" alt="image-20230201152821548" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;

int get_seconds(int h, int m, int s) {
	return h * 3600 + m * 60 + s; // 将时间转化为秒
}

int get_time() {
	string line;
	getline(cin, line);
	if (line.back() != ')') line += &quot; (+0)&quot;; // 格式保持一致
	int h1, m1, s1, h2, m2, s2, d;
	sscanf(line.c_str(), &quot;%d:%d:%d %d:%d:%d (+%d)&quot;, &amp;h1, &amp;m1, &amp;s1, &amp;h2, &amp;m2, &amp;s2, &amp;d);
	return get_seconds(h2, m2, s2) - get_seconds(h1, m1, s1) + 24 * 3600 * d;
}

int main() {
	int n;
	scanf(&quot;%d&quot;, &amp;n);
	string line;
	getline(cin, line); // 读入第一行的换行

	while (n --) {
		int time = (get_time() + get_time()) / 2;
		int h = time / 3600, m = time % 3600 / 60, s = time % 60;
		printf(&quot;%02d:%02d:%02d\n&quot;, h, m, s);
	}

	return 0;
}
</code></pre>
<h3 id="习题-1241-外卖店优先级">习题 1241. 外卖店优先级</h3>
<p><a href="https://www.acwing.com/problem/content/1243/">1241. 外卖店优先级 </a></p>
<p>“饱了么”外卖系统中维护着 N 家外卖店，编号 1∼N。</p>
<p>每家外卖店都有一个优先级，初始时 (0 时刻) 优先级都为 0。</p>
<p>每经过 1 个时间单位，如果外卖店没有订单，则优先级会减少 1，最低减到 0；而如果外卖店有订单，则优先级不减反加，每有一单优先级加 2。</p>
<p>如果某家外卖店某时刻优先级大于 5，则会被系统加入优先缓存中；如果优先级小于等于 3，则会被清除出优先缓存。</p>
<p>给定 T时刻以内的 M 条订单信息，请你计算 T 时刻时有多少外卖店在优先缓存中。</p>
<h4 id="输入格式-11">输入格式</h4>
<p>第一行包含 33 个整数 N,M,T。</p>
<p>以下 M 行每行包含两个整数 ts 和 id，表示 ts 时刻编号 id 的外卖店收到一个订单。</p>
<h4 id="输出格式-11">输出格式</h4>
<p>输出一个整数代表答案。</p>
<h4 id="数据范围-11">数据范围</h4>
<p>1≤N,M,T≤105<br>
1≤ts≤T<br>
1≤id≤N</p>
<h4 id="输入样例-9">输入样例：</h4>
<pre><code>2 6 6
1 1
5 2
3 1
6 2
2 1
6 2
</code></pre>
<h4 id="输出样例-9">输出样例：</h4>
<pre><code>1
</code></pre>
<h4 id="样例解释-3">样例解释</h4>
<p>6 时刻时，1号店优先级降到 3，被移除出优先缓存；2 号店优先级升到 6，加入优先缓存。</p>
<p>所以是有 1家店 (2 号) 在优先缓存中。</p>
<ul>
<li>
<p>暴力模拟</p>
<ul>
<li><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201155717680.png" alt="image-20230201155717680" loading="lazy"></li>
</ul>
</li>
<li>
<p>优化（将连续一段时间没有订单的店铺，统一到下次一有订单时处理）</p>
<ul>
<li><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201161324702.png" alt="image-20230201161324702" loading="lazy"></li>
</ul>
</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

#define x first
#define y second

using namespace std;

typedef pair&lt;int, int&gt; PII;

const int N = 1e5 + 10;

PII order[N]; // 存储订单数组
int score[N], last[N];
bool st[N]; // 是否在有限缓存中

int main() {
	int n, m, T;
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;T);
	for (int i = 0; i &lt; m; i ++) scanf(&quot;%d%d&quot;, &amp;order[i].x, &amp;order[i].y); // 读入订单
	sort(order, order + m); // 对订单数组按时间排序

	for (int i = 0; i &lt; m; ) {
		int j = i;
		while (j &lt; m &amp;&amp; order[j].y == order[i].y) j ++; // 是为了算出来同一时刻同一家店的订单数量，
		int t = order[i].x, id = order[i].y, cnt = j - i; // 数量就是cnt的值，这个数量可能不唯一
		i = j; // 继续下一个时刻的循环

		score[id] -= t - last[id] - 1; 
		if (score[id] &lt; 0) score[id] = 0;
		if (score[id] &lt;= 3) st[id] = false; // 以上处理t 时刻以前的内容


		score[id] += cnt * 2;
		if (score[id] &gt; 5) st[id] = true;
		last[id] = t;
	}

	for (int i = 1; i &lt;= n; i ++) {
		if (last[i] &lt; T) {
			score[i] -= T - last[i];
			if (score[i] &lt;= 3) st[i] = false;
		}
	}
	int res = 0;
	for (int i = 1; i &lt;= n; i ++) res += st[i];

	printf(&quot;%d&quot;, res);

	return 0;
}
</code></pre>
<h3 id="习题-788-逆序对的数量">习题 788. 逆序对的数量</h3>
<p><a href="https://www.acwing.com/problem/content/790/">788. 逆序对的数量</a></p>
<figure data-type="image" tabindex="86"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201171806294.png" alt="image-20230201171806294" loading="lazy"></figure>
<figure data-type="image" tabindex="87"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201172612170.png" alt="image-20230201172612170" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

typedef long long LL;

const int N = 100010;

int n;
int q[N], tmp[N];



LL merge_sort(int l, int r) {
	if (l &gt;= r) return 0; // 终止位置
	int mid = (l + r) &gt;&gt; 1;

	LL res = merge_sort(l, mid) + merge_sort(mid + 1, r);
	// 归并过程
	int k = 0, i = l, j = mid + 1;
	while (i &lt;= mid &amp;&amp; j &lt;= r) {
		if (q[i] &lt;= q[j]) tmp[k ++] = q[i ++];
		else {
			tmp[k ++] = q[j ++];
			res += mid - i + 1;
		}
	}
	// 归并扫尾
	while (i &lt;= mid) tmp[k ++] = q[i ++];
	while (j &lt;= r) tmp[k ++] = q[j ++];

	// 恢复
	for (int i = l, j = 0; i &lt;= r; i ++, j ++) q[i] = tmp[j];

	return res;
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);

	for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;q[i]);

	cout &lt;&lt; merge_sort(0, n - 1) &lt;&lt; endl;

	return 0;
}
</code></pre>
<h1 id="树状数组与线段树">树状数组与线段树</h1>
<h2 id="树状数组">树状数组</h2>
<p>快速求前缀和</p>
<figure data-type="image" tabindex="88"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201195910674.png" alt="image-20230201195910674" loading="lazy"></figure>
<figure data-type="image" tabindex="89"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201201141527.png" alt="image-20230201201141527" loading="lazy"></figure>
<figure data-type="image" tabindex="90"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201201439806.png" alt="image-20230201201439806" loading="lazy"></figure>
<figure data-type="image" tabindex="91"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201204233325.png" alt="image-20230201204233325" loading="lazy"></figure>
<h3 id="树状数组核心函数">树状数组核心函数</h3>
<h4 id="lowbitint-x">lowbit(int x)</h4>
<pre><code class="language-c++">int lowbit(int x) {
	return x &amp; -x;
}
</code></pre>
<h4 id="addint-x-int-v">add(int x, int v)</h4>
<pre><code class="language-c++">void add (int x, int v) {
	// 在x 位置 加上v
	for (int i = x; i &lt;= n; i += lowbit(i)) tr[i] += v;
}
</code></pre>
<h4 id="queryint-x">query(int x)</h4>
<pre><code class="language-c++">int query(int x) {
	// 求前缀和
	int res = 0;
	for (int i = x; i; i -= lowbit(i)) res += tr[i];

	return res;
}
</code></pre>
<h3 id="例题-1264-动态求连续区间和">例题 1264. 动态求连续区间和</h3>
<p><a href="https://www.acwing.com/problem/content/1266/">1264. 动态求连续区间和</a></p>
<figure data-type="image" tabindex="92"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201205457652.png" alt="image-20230201205457652" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 100010;

int n, m;
int a[N], tr[N];

int lowbit(int x) {
	return x &amp; -x;
}

void add (int x, int v) {
	// 在x 位置 加上v
	for (int i = x; i &lt;= n; i += lowbit(i)) tr[i] += v;
}

int query(int x) {
	// 求前缀和
	int res = 0;
	for (int i = x; i; i -= lowbit(i)) res += tr[i];

	return res;
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]); // 读入原数组
	for (int i = 1; i &lt;= n; i ++) add(i, a[i]); // 初始化树状数组

	while (m --) {
		int k, x, y;
		scanf(&quot;%d%d%d&quot;, &amp;k, &amp;x, &amp;y);
		if (k == 0) {
			printf(&quot;%d\n&quot;, query(y) - query(x - 1));
		} else if (k == 1) {
			add(x, y);
		}
	}

	return 0;
}
</code></pre>
<h3 id="例题-1265-数星星">例题 1265. 数星星</h3>
<p><a href="https://www.acwing.com/problem/content/1267/">1265. 数星星</a></p>
<p>天空中有一些星星，这些星星都在不同的位置，每个星星有个坐标。</p>
<p>如果一个星星的左下方（包含正左和正下）有 k 颗星星，就说这颗星星是 k 级的。</p>
<figure data-type="image" tabindex="93"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/19_6f40991a1c-1.png" alt="1.png" loading="lazy"></figure>
<p>例如，上图中星星 5是 3级的（1,2,4在它左下），星星 2,4是 11 级的。</p>
<p>例图中有 1 个 0级，2个 1级，1个 2级，1个 3级的星星。</p>
<p>给定星星的位置，输出各级星星的数目。</p>
<p>换句话说，给定 N 个点，定义每个点的等级是在该点左下方（含正左、正下）的点的数目，试统计每个等级有多少个点。</p>
<h4 id="输入格式-12">输入格式</h4>
<p>第一行一个整数 N，表示星星的数目；</p>
<p>接下来 N行给出每颗星星的坐标，坐标用两个整数 x,y 表示；</p>
<p>不会有星星重叠。星星按 y坐标增序给出，y坐标相同的按 x坐标增序给出。</p>
<h4 id="输出格式-12">输出格式</h4>
<p>N行，每行一个整数，分别是 0 级，1级，2级，……，N−1 级的星星的数目。</p>
<h4 id="数据范围-12">数据范围</h4>
<p>1≤N≤15000<br>
0≤x,y≤320000</p>
<h4 id="输入样例-10">输入样例：</h4>
<pre><code>5
1 1
5 1
7 1
3 3
5 5
</code></pre>
<h4 id="输出样例-10">输出样例：</h4>
<pre><code>1
2
1
1
0
</code></pre>
<figure data-type="image" tabindex="94"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201224648773.png" alt="image-20230201224648773" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 32010;

int n;
int level[N], tr[N];

int lowbit(int x) {
	return x &amp; -x;
}

void add (int x) {
	// 在x 位置 加上v
	for (int i = x; i &lt; N; i += lowbit(i)) tr[i] ++;
}

int query(int x) {
	// 求前缀和
	int res = 0;
	for (int i = x; i; i -= lowbit(i)) res += tr[i];

	return res;
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 0; i &lt; n; i ++) {
		int x, y;
		scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
		x ++;
		level[query(x)]++;
		add(x);
	}

	for (int i = 0; i &lt; n; i ++) printf(&quot;%d\n&quot;, level[i]);

	return 0;
}
</code></pre>
<h3 id="习题-1215-小朋友排队">习题 1215. 小朋友排队</h3>
<p><a href="https://www.acwing.com/problem/content/1217/">1215. 小朋友排队</a></p>
<p>n个小朋友站成一排。</p>
<p>现在要把他们按身高从低到高的顺序排列，但是每次只能交换位置相邻的两个小朋友。</p>
<p>每个小朋友都有一个不高兴的程度。</p>
<p>开始的时候，所有小朋友的不高兴程度都是 0。</p>
<p>如果某个小朋友第一次被要求交换，则他的不高兴程度增加 1，如果第二次要求他交换，则他的不高兴程度增加 2（即不高兴程度为 3），依次类推。当要求某个小朋友第 k次交换时，他的不高兴程度增加 k。</p>
<p>请问，要让所有小朋友按从低到高排队，他们的不高兴程度之和最小是多少。</p>
<p>如果有两个小朋友身高一样，则他们谁站在谁前面是没有关系的。</p>
<h4 id="输入格式-13">输入格式</h4>
<p>输入的第一行包含一个整数 n，表示小朋友的个数。</p>
<p>第二行包含 n个整数 H1,H2,…,Hn，分别表示每个小朋友的身高。</p>
<h4 id="输出格式-13">输出格式</h4>
<p>输出一行，包含一个整数，表示小朋友的不高兴程度和的最小值。</p>
<h4 id="数据范围-13">数据范围</h4>
<p>1≤n≤100000,<br>
0≤Hi≤1000000</p>
<h4 id="输入样例-11">输入样例：</h4>
<pre><code>3
3 2 1
</code></pre>
<h4 id="输出样例-11">输出样例：</h4>
<pre><code>9
</code></pre>
<h4 id="样例解释-4">样例解释</h4>
<p>首先交换身高为3和2的小朋友，再交换身高为3和1的小朋友，再交换身高为2和1的小朋友，每个小朋友的不高兴程度都是3，总和为9。</p>
<figure data-type="image" tabindex="95"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203185220944.png" alt="image-20230203185220944" loading="lazy"></figure>
<figure data-type="image" tabindex="96"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203185758380.png" alt="image-20230203185758380" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;
const int N = 1000010; // 小朋友的身高为0≤Hi≤1000000

int n;
int h[N], tr[N], sum[N]; //sum数组存储每个小朋友的不高兴度

int lowbit(int x) {
	return x &amp; -x;
}

void add(int x, int v) {
	for (int i = x; i &lt; N; i += lowbit(i)) tr[i] += v; 
}

int query(int x) {
	int res = 0;
	for (int i = x; i; i -= lowbit(i)) res += tr[i]; // 由于是个数，所以不需要使用LL

	return res;
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);

	for (int i = 0; i &lt; n; i ++) {
		scanf(&quot;%d&quot;, &amp;h[i]);
		h[i] ++;
	}

	// 求每个数前面有多少比它大
	for (int i = 0; i &lt; n; i ++) {
		sum[i] = query(N - 1) - query(h[i]);
		add(h[i], 1);
	}

	// 求每个数后面有多少比它小
	memset(tr, 0, sizeof tr);

	for (int i = n - 1; i&gt;= 0; i --) {
		sum[i] += query(h[i] - 1);
		add(h[i], 1);
	}

	LL res = 0;
	for (int i = 0; i &lt; n; i ++) res += (LL) sum[i] * (sum[i] + 1) / 2;

	printf(&quot;%lld\n&quot;, res);

	return 0;
}
</code></pre>
<h2 id="线段树">线段树</h2>
<figure data-type="image" tabindex="97"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203161448365.png" alt="image-20230203161448365" loading="lazy"></figure>
<h3 id="线段树-核心操作">线段树 核心操作</h3>
<h4 id="单点修改">单点修改</h4>
<figure data-type="image" tabindex="98"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203163005151.png" alt="image-20230203163005151" loading="lazy"></figure>
<h4 id="区间查询">区间查询</h4>
<figure data-type="image" tabindex="99"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203163210009.png" alt="image-20230203163210009" loading="lazy"></figure>
<h3 id="线段树-核心函数">线段树 核心函数</h3>
<h4 id="pushup用子节点信息更新当前节点信息">pushup：用子节点信息更新当前节点信息</h4>
<pre><code class="language-c++">void pushup(int u) {
	tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum;
	// 左儿子 u &lt;&lt; 1， 右儿子 u &lt;&lt; 1 | 1 之和
}
</code></pre>
<h4 id="build在一段区间上初始化线段树">build：在一段区间上初始化线段树</h4>
<pre><code class="language-c++">void build(int u, int l, int r) {
	lf (l == r) tr[u] = {l, r, w[l]}; // 表示是叶子节点, 注意是w[l] 或w[r]， u 是线段树的下标
	else {
		int mid = l + r &gt;&gt; 1; // 找到分界点
		build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);// 递归建立左右儿子
		pushup(u);
	}
}
</code></pre>
<h4 id="modify修改">modify：修改</h4>
<pre><code class="language-c++">
</code></pre>
<h4 id="query查询">query：查询</h4>
<pre><code class="language-c++">
</code></pre>
<h3 id="例题-1264-动态求连续区间和-2">例题 1264. 动态求连续区间和</h3>
<p><a href="https://www.acwing.com/problem/content/1266/">1264. 动态求连续区间和</a></p>
<figure data-type="image" tabindex="100"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203164712810.png" alt="image-20230203164712810" loading="lazy"></figure>
<figure data-type="image" tabindex="101"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203164328814.png" alt="image-20230203164328814" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;

using namespace std;

const int N = 100010;

int n, m;
int w[N];

struct Node
{
	int l, r; // 左右边界
	int sum; // 求和
} tr[4 * N];


void pushup(int u) {
	tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum;
	// 左儿子 u &lt;&lt; 1， 右儿子 u &lt;&lt; 1 | 1 之和
}

void build(int u, int l, int r) {
	if (l == r) tr[u] = {l, r, w[l]}; // 表示是叶子节点, 注意是w[l] 或w[r]， u 是线段树的下标
	else {
		tr[u] = {l, r}; // /赋左右边界的初值
		int mid = l + r &gt;&gt; 1; // 找到分界点
		build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);// 递归建立左右儿子
		pushup(u);
	}
}

int query(int u, int l, int r) {
	if (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) return tr[u].sum; // 表示已经完全包含
	// 找到分界点
	int mid = tr[u].l + tr[u].r &gt;&gt; 1;
	int sum = 0;
	if (l &lt;= mid) sum += query(u &lt;&lt; 1, l, r);
	if (r &gt;= mid + 1) sum += query(u &lt;&lt; 1 | 1, l, r);

	return sum;
}

void modify(int u, int x, int v) {
	if (tr[u].l == tr[u].r) tr[u].sum += v;
	else {
		int mid = tr[u].l + tr[u].r &gt;&gt; 1; // 分界点
		if (x &lt;= mid) modify(u &lt;&lt; 1, x, v);
		else modify(u &lt;&lt; 1 | 1, x, v);
		pushup(u); // 在父节点出更新
	}
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;w[i]);
	build(1, 1, n); // 初始化线段树

	int k, a, b;
	while (m --) {
		scanf(&quot;%d%d%d&quot;, &amp;k, &amp;a, &amp;b);
		if (k == 0) printf(&quot;%d\n&quot;, query(1, a, b)); // 查询 a, b 区间和
		else {
			modify(1, a, b); 
		}
	}

	return 0;
}
</code></pre>
<h3 id="例题-1270-数列区间最大值">例题 1270. 数列区间最大值</h3>
<p><a href="https://www.acwing.com/problem/content/1272/">1270. 数列区间最大值</a></p>
<figure data-type="image" tabindex="102"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203164122991.png" alt="image-20230203164122991" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;climits&gt;

using namespace std;

const int N = 100010;

int n, m;
int w[N];

struct Node
{
	int l, r; // 左右边界
	int maxv; // 求和
} tr[4 * N];


void pushup(int u) {
	tr[u].maxv = max(tr[u &lt;&lt; 1].maxv, tr[u &lt;&lt; 1 | 1].maxv);
	// 左儿子 u &lt;&lt; 1， 右儿子 u &lt;&lt; 1 | 1 之和
}

void build(int u, int l, int r) {
	if (l == r) tr[u] = {l, r, w[l]}; // 表示是叶子节点, 注意是w[l] 或w[r]， u 是线段树的下标
	else {
		tr[u] = {l, r}; // /赋左右边界的初值
		int mid = l + r &gt;&gt; 1; // 找到分界点
		build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);// 递归建立左右儿子
		pushup(u);
	}
}

int query(int u, int l, int r) {
	if (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) return tr[u].maxv; // 表示已经完全包含
	// 找到分界点
	int mid = tr[u].l + tr[u].r &gt;&gt; 1;
	int maxv = INT_MIN;
	if (l &lt;= mid) maxv = query(u &lt;&lt; 1, l, r);
	if (r &gt;= mid + 1) maxv = max(maxv, query(u &lt;&lt; 1 | 1, l, r));

	return maxv;
}


int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;w[i]);
	build(1, 1, n); // 初始化线段树

	int a, b;
	while (m --) {
		scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
		printf(&quot;%d\n&quot;, query(1, a, b));
	}

	return 0;
}
</code></pre>
<h3 id="习题-1228-油漆面积">习题 1228. 油漆面积</h3>
<p><a href="https://www.acwing.com/problem/content/1230/">1228. 油漆面积</a></p>
<p>X星球的一批考古机器人正在一片废墟上考古。</p>
<p>该区域的地面坚硬如石、平整如镜。</p>
<p>管理人员为方便，建立了标准的直角坐标系。</p>
<p>每个机器人都各有特长、身怀绝技。</p>
<p>它们感兴趣的内容也不相同。</p>
<p>经过各种测量，每个机器人都会报告一个或多个矩形区域，作为优先考古的区域。</p>
<p>矩形的表示格式为 (x1,y1,x2,y2)，代表矩形的两个对角点坐标。</p>
<p>为了醒目，总部要求对所有机器人选中的矩形区域涂黄色油漆。</p>
<p>小明并不需要当油漆工，只是他需要计算一下，一共要耗费多少油漆。</p>
<p>其实这也不难，只要算出所有矩形覆盖的区域一共有多大面积就可以了。</p>
<p>注意，各个矩形间可能重叠。</p>
<h4 id="输入格式-14">输入格式</h4>
<p>第一行，一个整数 n，表示有多少个矩形。</p>
<p>接下来的 n 行，每行有 4 个整数 x1,y1,x2,y2，空格分开，表示矩形的两个对角顶点坐标。</p>
<h4 id="输出格式-14">输出格式</h4>
<p>一行一个整数，表示矩形覆盖的总面积。</p>
<h4 id="数据范围-14">数据范围</h4>
<p>1≤n≤10000,<br>
0≤x1,x2,y2,y2≤10000<br>
数据保证 x1&lt;x2 且 y1&lt;y2。</p>
<h4 id="输入样例1-3">输入样例1：</h4>
<pre><code>3
1 5 10 10
3 1 20 20
2 7 15 17
</code></pre>
<h4 id="输出样例1-3">输出样例1：</h4>
<pre><code>340
</code></pre>
<h4 id="输入样例2-3">输入样例2：</h4>
<pre><code>3
5 2 10 6
2 7 12 10
8 1 15 15
</code></pre>
<h4 id="输出样例2-3">输出样例2：</h4>
<pre><code>128
</code></pre>
<figure data-type="image" tabindex="103"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203204606583.png" alt="image-20230203204606583" loading="lazy"></figure>
<figure data-type="image" tabindex="104"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203204816163.png" alt="image-20230203204816163" loading="lazy"></figure>
<figure data-type="image" tabindex="105"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203205701119.png" alt="image-20230203205701119" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 10010;

int n;

struct Segment{
	int x, y1, y2; // 定义位置信息
	int k; // k 表示是矩形的开始还是结束
	// 重载比较运算符，用来排序
	bool operator&lt; (const Segment &amp;t) {
		return x &lt; t.x; // 根据x进行排序
	}
} seg[N * 2];

struct Node{
	int l, r;
	int cnt, len; // cnt表示结点区间被覆盖次数，len表示结点区间内被覆盖的长度
} tr[N * 4];

// 线段树核心函数
void pushup(int u) {
	// 结点区间被覆盖过一次以上，那len就等于区间长度
	if (tr[u].cnt &gt; 0) tr[u].len = tr[u].r - tr[u].l + 1; 
	else if (tr[u].l == tr[u].r) tr[u].len = 0;
	else tr[u].len = tr[u &lt;&lt; 1].len + tr[u &lt;&lt; 1 | 1].len;
}


void build(int u, int l, int r) {
	tr[u] = {l, r};
	if (l == r) return ;
	// 递归完成初始化
	int mid = l + r &gt;&gt; 1;
	build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);
}

void modify(int u, int l, int r, int k) {
	// 区间完全包含结点，直接修改结点的cnt,修改完cnt会影响到当前节点区间的覆盖性
	if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) {
		tr[u].cnt += k;
		pushup(u);
	} else {
		int mid = tr[u].l + tr[u].r &gt;&gt; 1;
		if (l &lt;= mid) modify(u &lt;&lt; 1, l, r, k);
		if (r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, k);
		pushup(u);
	}
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	int m = 0; // 线段数量

	for (int i = 0; i &lt; n; i ++) {
		int x1, x2, y1, y2;
		scanf(&quot;%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);
		seg[m ++] = {x1, y1, y2, 1}; // 矩形的开始
		seg[m ++] = {x2, y1, y2, -1}; // 矩形的结束
	}
	sort(seg, seg + m);

	build(1, 0, 10000);

	int res = 0;
	for (int i = 0; i &lt; m; i ++) {
		// 开始扫描线
		if (i &gt; 0) res += tr[1].len * (seg[i].x - seg[i - 1].x); // 扫描线，计算面积
		modify(1, seg[i].y1, seg[i].y2 - 1, seg[i].k);
	}

	printf(&quot;%d\n&quot;, res);

	return 0;
}
</code></pre>
<h3 id="习题-1232-三体攻击">习题 1232. 三体攻击</h3>
<p><a href="https://www.acwing.com/problem/content/1234/">1232. 三体攻击</a></p>
<figure data-type="image" tabindex="106"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203231501573.png" alt="image-20230203231501573" loading="lazy"></figure>
<figure data-type="image" tabindex="107"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203232949019.png" alt="image-20230203232949019" loading="lazy"></figure>
<h4 id="三维前缀和">三维前缀和</h4>
<figure data-type="image" tabindex="108"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203233812519.png" alt="image-20230203233812519" loading="lazy"></figure>
<h4 id="一维差分">一维差分</h4>
<figure data-type="image" tabindex="109"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203235912203.png" alt="image-20230203235912203" loading="lazy"></figure>
<h4 id="二维差分">二维差分</h4>
<figure data-type="image" tabindex="110"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203235924900.png" alt="image-20230203235924900" loading="lazy"></figure>
<h4 id="三维差分">三维差分</h4>
<figure data-type="image" tabindex="111"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203235935896.png" alt="image-20230203235935896" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

typedef long long LL;

const int N = 2000010;

int A, B, C, m;
LL s[N];  // 原数组
LL b[N], bp[N];  // 差分数组
int d[8][4] = {  // 差分数组和原数组 相互转换 使用到的偏移量和系数
    {0, 0, 0, 1},
    {0, 0, 1, -1},
    {0, 1, 0, -1},
    {0, 1, 1, 1},
    {1, 0, 0, -1},
    {1, 0, 1, 1},
    {1, 1, 0, 1},
    {1, 1, 1, -1},
};
int op[N / 2][7];

int get(int i, int j, int k) {
	// 将三维坐标转化为一维
    return (i * B + j) * C + k;
}

bool check(int mid) {

    memcpy(b, bp, sizeof bp);
    for (int i = 1; i &lt;= mid; i++) {
        // 给(x1, y1, z1), (x2, y2, z2)之间加上c
        int x1 = op[i][0], x2 = op[i][1];
        int y1 = op[i][2], y2 = op[i][3];
        int z1 = op[i][4], z2 = op[i][5];
        int c = -op[i][6];
        b[get(x1    , y1    , z1)]      += c;
        b[get(x1    , y1    , z2 + 1)]  -= c;
        b[get(x1    , y2 + 1, z1)]      -= c;
        b[get(x1    , y2 + 1, z2 + 1)]  += c;
        b[get(x2 + 1, y1    , z1)]      -= c;
        b[get(x2 + 1, y1    , z2 + 1)]  += c;
        b[get(x2 + 1, y2 + 1, z1)]      += c;
        b[get(x2 + 1, y2 + 1, z2 + 1)]  -= c;
    }

    // 根据差分数组求解原数组
    memset(s, 0, sizeof s);
    for (int i = 1; i &lt;= A; i++)
        for (int j = 1; j &lt;= B; j++)
            for (int k = 1; k &lt;= C; k++) {
                s[get(i, j, k)] += b[get(i, j, k)];
                for (int u = 1; u &lt; 8; u++) {
                    int x = i - d[u][0], y = j - d[u][1], z = k - d[u][2], t = d[u][3];
                    s[get(i, j, k)] -= s[get(x, y, z)] * t;
                }
                if (s[get(i, j, k)] &lt; 0) return true;
            }

    return false;
}

int main() {

    // 读取原数组
    scanf(&quot;%d%d%d%d&quot;, &amp;A, &amp;B, &amp;C, &amp;m);
    for (int i = 1; i &lt;= A; i++)
        for (int j = 1; j &lt;= B; j++)
            for (int k = 1; k &lt;= C; k++)
                scanf(&quot;%lld&quot;, &amp;s[get(i, j, k)]);

    // 根据原数组s计算差分数组
    for (int i = 1; i &lt;= A; i++)
        for (int j = 1; j &lt;= B; j++)
            for (int k = 1; k &lt;= C; k++)
                for (int u = 0; u &lt; 8; u++) {
                    int x = i - d[u][0], y = j - d[u][1], z = k - d[u][2], t = d[u][3];
                    bp[get(i, j, k)] += s[get(x, y, z)] * t;
                }

    // 读取操作
    for (int i = 1; i &lt;= m; i++)
        for (int j = 0; j &lt; 7; j++)
            scanf(&quot;%d&quot;, &amp;op[i][j]);

    // 二分答案
    int l = 1, r = m;
    while (l &lt; r) {
        int mid = l + r &gt;&gt; 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }

    printf(&quot;%d\n&quot;, r);

    return 0;
}
</code></pre>
<h3 id="习题-1237-螺旋折线">习题 1237. 螺旋折线</h3>
<p><a href="https://www.acwing.com/problem/content/1239/">1237. 螺旋折线</a></p>
<figure data-type="image" tabindex="112"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/19_95e6f22816-p1.png" alt="p1.png" loading="lazy"></figure>
<p>对于整点 (X,Y)，我们定义它到原点的距离 dis(X,Y) 是从原点到 (X,Y)的螺旋折线段的长度。</p>
<p>例如 dis(0,1)=3,dis(−2,−1)=9</p>
<p>给出整点坐标 (X,Y)，你能计算出 dis(X,Y) 吗？</p>
<h4 id="输入格式-15">输入格式</h4>
<p>包含两个整数 X,Y。</p>
<h4 id="输出格式-15">输出格式</h4>
<p>输出一个整数，表示 dis(X,Y)。</p>
<h4 id="数据范围-15">数据范围</h4>
<p>−10<sup>9≤X,Y≤10</sup>9</p>
<h4 id="输入样例-12">输入样例：</h4>
<pre><code>0 1
</code></pre>
<h4 id="输出样例-12">输出样例：</h4>
<pre><code>3
</code></pre>
<h4 id="模拟1">模拟1</h4>
<figure data-type="image" tabindex="113"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230205160616558.png" alt="image-20230205160616558" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

int main()
{
    int x, y;
    cin &gt;&gt; x &gt;&gt; y;

    if (abs(x) &lt;= y)  // 在上方
    {
        int n = y;
        cout &lt;&lt; (LL)(2 * n - 1) * (2 * n) + x - (-n) &lt;&lt; endl;
    }
    else if (abs(y) &lt;= x)  // 在右方
    {
        int n = x;
        cout &lt;&lt; (LL)(2 * n) * (2 * n) + n - y &lt;&lt; endl;
    }
    else if (abs(x) &lt;= abs(y) + 1 &amp;&amp; y &lt; 0)  // 在下方
    {
        int n = abs(y);
        cout &lt;&lt; (LL)(2 * n) * (2 * n + 1) + n - x &lt;&lt; endl;
    }
    else  // 在左方
    {
        int n = abs(x);
        cout &lt;&lt; (LL)(2 * n - 1) * (2 * n - 1) + y - (-n + 1) &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
<h4 id="模拟2">模拟2</h4>
<p>找规律可以发现每层的右上角点所需步数为为4k^2，求任意一个点的dis首先找到这个点所在的层数</p>
<ul>
<li>如果在该层的左或上则减去该点到右上角曼哈顿距离，</li>
<li>如果在该层的右或下则加上该点到右上角曼哈顿距离；</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;

typedef long long LL;

int main() {
    int x, y;
    scanf(&quot;%d%d&quot;, &amp;x, &amp;y);

    LL target = max(abs(x), abs(y));
    LL res = 4 * target * target;
    if (x &lt;= y) {
        // 左层
        res -= abs(x - target) + abs(y - target);
    } else {
        // 右层
        res += abs(x - target) + abs(y - target);
    }

    printf(&quot;%lld\n&quot;, res);

    return 0;
}
</code></pre>
<h2 id="差分">差分</h2>
<figure data-type="image" tabindex="114"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230205165616636.png" alt="image-20230205165616636" loading="lazy"></figure>
<h3 id="核心操作">核心操作</h3>
<ul>
<li>将a[L ~ R] 中的全部数字加上C</li>
<li>等价于的差分数组的操作：让b[L] += C， 让b[R + 1] -= C</li>
</ul>
<h4 id="一维差分-2">一维差分</h4>
<figure data-type="image" tabindex="115"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203235912203.png" alt="image-20230203235912203" loading="lazy"></figure>
<h4 id="二维差分-2">二维差分</h4>
<figure data-type="image" tabindex="116"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203235924900.png" alt="image-20230203235924900" loading="lazy"></figure>
<h4 id="三维差分-2">三维差分</h4>
<figure data-type="image" tabindex="117"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203235935896.png" alt="image-20230203235935896" loading="lazy"></figure>
<h3 id="例题-797-差分">例题 797. 差分</h3>
<p><a href="https://www.acwing.com/problem/content/799/">797. 差分</a></p>
<figure data-type="image" tabindex="118"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230205170136353.png" alt="image-20230205170136353" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;


const int N = 100010;

int n, m;
int a[N], b[N];

void insert(int l, int r, int c) {
    // 插入操作
    b[l] +=c, b[r + 1] -= c;
}

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);

    for (int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]);

    for (int i = 1; i &lt;= n; i ++) insert(i, i, a[i]);

    while (m --) {
        int l, r, c;
        scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;c);
        insert(l, r, c);
    }

    for (int i = 1; i &lt;= n; i ++) a[i] = a[i - 1] + b[i];

    for (int i = 1; i &lt;= n; i ++) printf(&quot;%d &quot;, a[i]);
    puts(&quot;&quot;);

    return 0;
}
</code></pre>
<h3 id="例题-798-差分矩阵">例题 798. 差分矩阵</h3>
<p><a href="https://www.acwing.com/problem/content/800/">798. 差分矩阵</a></p>
<figure data-type="image" tabindex="119"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230205170853597.png" alt="image-20230205170853597" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;


const int N = 1010;

int n, m, q;
int a[N][N], b[N][N];

void insert(int x1, int y1, int x2, int y2, int c) {
    b[x1][y1] += c;
    b[x1][y2 + 1] -= c;
    b[x2 + 1][y1] -= c;
    b[x2 + 1][y2 + 1] += c;
}

int main() {
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q);

    for (int i = 1; i &lt;= n; i ++) {
        for (int j = 1; j &lt;= m; j ++) {
            scanf(&quot;%d&quot;, &amp;a[i][j]);
        }
    }

    for (int i = 1; i &lt;= n; i ++) {
        for (int j = 1; j &lt;= m; j ++) {
            insert(i, j, i, j, a[i][j]);
        }
    }

    while (q --) {
        int x1, y1, x2, y2, c;
        scanf(&quot;%d%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;c);
        insert(x1, y1, x2, y2, c);
    }

    for (int i = 1; i &lt;= n; i ++) {
        for (int j = 1; j &lt;= m; j ++) {
            b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];
        }
    }

    for (int i = 1; i &lt;= n; i ++) {
        for (int j = 1; j &lt;= m; j ++) {
            printf(&quot;%d &quot;, b[i][j]);
        }
        printf(&quot;\n&quot;);
    }
      

    return 0;
}
</code></pre>
<h1 id="双指针-bfs与图论">双指针、BFS与图论</h1>
<h2 id="双指针">双指针</h2>
<figure data-type="image" tabindex="120"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230205190024515.png" alt="image-20230205190024515" loading="lazy"></figure>
<h3 id="例题-1238-日志统计">例题 1238. 日志统计</h3>
<p><a href="https://www.acwing.com/problem/content/1240/">1238. 日志统计</a></p>
<p>小明维护着一个程序员论坛。现在他收集了一份”点赞”日志，日志共有 N 行。</p>
<p>其中每一行的格式是：</p>
<pre><code>ts id  
</code></pre>
<p>表示在 ts时刻编号 id的帖子收到一个”赞”。</p>
<p>现在小明想统计有哪些帖子曾经是”热帖”。</p>
<p>如果一个帖子曾在任意一个长度为 D 的时间段内收到不少于 K 个赞，小明就认为这个帖子曾是”热帖”。</p>
<p>具体来说，如果存在某个时刻 T 满足该帖在 [T,T+D) 这段时间内(注意是左闭右开区间)收到不少于 K个赞，该帖就曾是”热帖”。</p>
<p>给定日志，请你帮助小明统计出所有曾是”热帖”的帖子编号。</p>
<h4 id="输入格式-16">输入格式</h4>
<p>第一行包含三个整数 N,D,K。</p>
<p>以下 N 行每行一条日志，包含两个整数 ts 和 id。</p>
<h4 id="输出格式-16">输出格式</h4>
<p>按从小到大的顺序输出热帖 id。</p>
<p>每个 id 占一行。</p>
<h4 id="数据范围-16">数据范围</h4>
<p>1≤K≤N≤105<br>
0≤ts,id≤105<br>
1≤D≤10000</p>
<h4 id="输入样例-13">输入样例：</h4>
<pre><code>7 10 2
0 1
0 10
10 10
10 1
9 1
100 3
100 3
</code></pre>
<h4 id="输出样例-13">输出样例：</h4>
<pre><code>1
3
</code></pre>
<h4 id="暴力做法">暴力做法</h4>
<figure data-type="image" tabindex="121"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230205190644292.png" alt="image-20230205190644292" loading="lazy"></figure>
<h4 id="双指针优化">双指针优化</h4>
<figure data-type="image" tabindex="122"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230205190901710.png" alt="image-20230205190901710" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#define x first
#define y second

using namespace std;

typedef pair&lt;int, int&gt; PII;

const int N = 100010;

int n, d, k;
PII logs[N];  // 存储日志条数, x 表示时间，y 表示id
int cnt[N];  // 表示id为i的文章得到的点赞
bool st[N];  // 表示id为i的文章是否曾为热帖

int main() {
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;d, &amp;k);
    // 输入
    for (int i = 0; i &lt; n; i ++) scanf(&quot;%d%d&quot;, &amp;logs[i].x, &amp;logs[i].y);

    sort(logs, logs + n); // 按照时间顺序排好序
    for (int i = 0, j = 0; i &lt; n; i ++) {
        int id = logs[i].y;
        cnt[id] ++;
        while ((logs[i].x - logs[j].x) &gt;= d) {
            cnt[logs[j].y] --; // 超过d区间，即区间滑动后，在左边的日志
            j ++;
        }
        if (cnt[logs[i].y] &gt;= k) st[id] = true; // 是热帖
    }

    for (int i = 0; i &lt;= 100000; i ++) {
        if (st[i]) printf(&quot;%d\n&quot;, i);
    }

    return 0;
}
</code></pre>
<h3 id="习题-1240-完全二叉树的权值">习题 1240. 完全二叉树的权值</h3>
<p><a href="https://www.acwing.com/problem/content/1242/">1240. 完全二叉树的权值</a></p>
<p>给定一棵包含 N 个节点的完全二叉树，树上每个节点都有一个权值，按从上到下、从左到右的顺序依次是 A1,A2,⋅⋅⋅AN，如下图所示：</p>
<figure data-type="image" tabindex="123"><img src="https://cdn.acwing.com/media/article/image/2019/12/05/19_2f0cae5817-QQ%E6%88%AA%E5%9B%BE20191205124611.png" alt="QQ截图20191205124611.png" loading="lazy"></figure>
<p>现在小明要把相同深度的节点的权值加在一起，他想知道哪个深度的节点权值之和最大？</p>
<p>如果有多个深度的权值和同为最大，请你输出其中最小的深度。</p>
<p>注：根的深度是1 。</p>
<h4 id="输入格式-17">输入格式</h4>
<p>第一行包含一个整数 N。</p>
<p>第二行包含 N个整数 A1,A2,⋅⋅⋅AN。</p>
<h4 id="输出格式-17">输出格式</h4>
<p>输出一个整数代表答案。</p>
<h4 id="数据范围-17">数据范围</h4>
<p>1≤N≤10^5<br>
−10<sup>5≤Ai≤10</sup>5</p>
<h4 id="输入样例-14">输入样例：</h4>
<pre><code>7
1 6 5 4 3 2 1
</code></pre>
<h4 id="输出样例-14">输出样例：</h4>
<pre><code>2
</code></pre>
<figure data-type="image" tabindex="124"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206001346782.png" alt="image-20230206001346782" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cmath&gt;

using namespace std;

typedef long long LL;

const int N = 100010;

int n;
int tr[N];

int main() {
    scanf(&quot;%d&quot;, &amp;n);

    for (int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;tr[i]);

    LL maxv = -1e18;
    int index = 0;
    for (int d = 1, i = 1; i &lt;= n; d ++, i *= 2) {
        // d 表示当前为二叉树的第几层，i 表示坐标
        LL cur = 0;
        for (int j = i; j &lt; i + (1 &lt;&lt; (d - 1)) &amp;&amp; j &lt;= n; j ++) {
            // 循环每层, j &lt;= n 是为了可能最后一层无法取完
            cur += tr[j];
        }
        
        if (cur &gt; maxv) {
            maxv = cur;
            index = d;
        }
    }

    printf(&quot;%d\n&quot;, index);
    return 0;
}
</code></pre>
<h2 id="bfs">BFS</h2>
<figure data-type="image" tabindex="125"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230205194904005.png" alt="image-20230205194904005" loading="lazy"></figure>
<figure data-type="image" tabindex="126"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230205195249530.png" alt="image-20230205195249530" loading="lazy"></figure>
<h3 id="bfs-一般框架">BFS 一般框架</h3>
<figure data-type="image" tabindex="127"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230205195619066.png" alt="image-20230205195619066" loading="lazy"></figure>
<pre><code class="language-c++">queue&lt;int&gt; q;
st[1] = true; // 表示1号点已经被遍历过
q.push(1);

while (q.size())
{
    int t = q.front();
    q.pop();

    for (int i = h[t]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true; // 表示点j已经被遍历过
            q.push(j);
        }
    }
}
</code></pre>
<h3 id="例题-1101-献给阿尔吉侬的花束">例题 1101. 献给阿尔吉侬的花束</h3>
<p><a href="https://www.acwing.com/problem/content/description/1103/">1101. 献给阿尔吉侬的花束</a></p>
<p>阿尔吉侬是一只聪明又慵懒的小白鼠，它最擅长的就是走各种各样的迷宫。</p>
<p>今天它要挑战一个非常大的迷宫，研究员们为了鼓励阿尔吉侬尽快到达终点，就在终点放了一块阿尔吉侬最喜欢的奶酪。</p>
<p>现在研究员们想知道，如果阿尔吉侬足够聪明，它最少需要多少时间就能吃到奶酪。</p>
<p>迷宫用一个 R×C的字符矩阵来表示。</p>
<p>字符 S 表示阿尔吉侬所在的位置，字符 E 表示奶酪所在的位置，字符 # 表示墙壁，字符 . 表示可以通行。</p>
<p>阿尔吉侬在 1 个单位时间内可以从当前的位置走到它上下左右四个方向上的任意一个位置，但不能走出地图边界。</p>
<h4 id="输入格式-18">输入格式</h4>
<p>第一行是一个正整数 T，表示一共有 T 组数据。</p>
<p>每一组数据的第一行包含了两个用空格分开的正整数 R 和 C，表示地图是一个 R×C 的矩阵。</p>
<p>接下来的 R 行描述了地图的具体内容，每一行包含了 C 个字符。字符含义如题目描述中所述。保证有且仅有一个 S 和 E。</p>
<h4 id="输出格式-18">输出格式</h4>
<p>对于每一组数据，输出阿尔吉侬吃到奶酪的最少单位时间。</p>
<p>若阿尔吉侬无法吃到奶酪，则输出“oop!”（只输出引号里面的内容，不输出引号）。</p>
<p>每组数据的输出结果占一行。</p>
<h4 id="数据范围-18">数据范围</h4>
<p>1&lt;T≤10<br>
2≤R,C≤200</p>
<h4 id="输入样例-15">输入样例：</h4>
<pre><code>3
3 4
.S..
###.
..E.
3 4
.S..
.E..
....
3 4
.S..
####
..E.
</code></pre>
<h4 id="输出样例-15">输出样例：</h4>
<pre><code>5
1
oop!
</code></pre>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;
#define x first
#define y second

using namespace std;

typedef pair&lt;int, int&gt; PII;

const int N = 210;

int n, m;
char g[N][N];  // 用来存储迷宫
int dist[N][N];  // 用来存储步数
int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};

int bfs(PII start, PII finish) {
    queue&lt;PII&gt; q;
    memset(dist, -1, sizeof dist);
    dist[start.x][start.y] = 0;
    q.push(start);

    // bfs 
    while (q.size()) {
        PII t = q.front();
        q.pop();  // 弹出
        for (int i = 0; i &lt; 4; i ++) {
            // 4个方向遍历
            int x = dx[i] + t.x, y = dy[i] + t.y;
            if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m) continue;  // 出界
            if (g[x][y] == '#') continue;  // 遇到障碍物
            if (dist[x][y] != -1) continue;  // 由于遍历到的为距离，故若不等于-1， 则表示已经遍历过了
            
            dist[x][y] = dist[t.x][t.y] + 1;  // 当前的距离 + 1
            if (finish == make_pair(x, y)) return dist[x][y];
            q.push({x, y});
        }
    }

    return -1;
}

int main() {
    int T;
    scanf(&quot;%d&quot;, &amp;T);
    while (T --) {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        for (int i = 0; i &lt; n; i ++) scanf(&quot;%s&quot;, &amp;g[i]);  // 读入迷宫

        PII start, finish;
        for (int i = 0;i &lt; n; i ++) {
            for (int j = 0; j &lt; m; j ++) {
                if (g[i][j] == 'S') start = {i, j};
                else if (g[i][j] == 'E') finish = {i, j}; // 找到开始结束位置
            }
        }

        int distance = bfs(start, finish);
        if (distance == -1) printf(&quot;oop!\n&quot;);
        else printf(&quot;%d\n&quot;, distance);
    }
    
    return 0;
}
</code></pre>
<h3 id="习题-1096-地牢大师">习题 1096. 地牢大师</h3>
<p><a href="https://www.acwing.com/problem/content/1098/">1096. 地牢大师</a></p>
<p>你现在被困在一个三维地牢中，需要找到最快脱离的出路！</p>
<p>地牢由若干个单位立方体组成，其中部分不含岩石障碍可以直接通过，部分包含岩石障碍无法通过。</p>
<p>向北，向南，向东，向西，向上或向下移动一个单元距离均需要一分钟。</p>
<p>你不能沿对角线移动，迷宫边界都是坚硬的岩石，你不能走出边界范围。</p>
<p>请问，你有可能逃脱吗？</p>
<p>如果可以，需要多长时间？</p>
<h4 id="输入格式-19">输入格式</h4>
<p>输入包含多组测试数据。</p>
<p>每组数据第一行包含三个整数 L,R,C分别表示地牢层数，以及每一层地牢的行数和列数。</p>
<p>接下来是 L 个 R 行 C 列的字符矩阵，用来表示每一层地牢的具体状况。</p>
<p>每个字符用来描述一个地牢单元的具体状况。</p>
<p>其中, 充满岩石障碍的单元格用”#”表示，不含障碍的空单元格用”.”表示，你的起始位置用”S”表示，终点用”E”表示。</p>
<p>每一个字符矩阵后面都会包含一个空行。</p>
<p>当输入一行为”0 0 0”时，表示输入终止。</p>
<h4 id="输出格式-19">输出格式</h4>
<p>每组数据输出一个结果，每个结果占一行。</p>
<p>如果能够逃脱地牢，则输出”Escaped in x minute(s).”，其中X为逃脱所需最短时间。</p>
<p>如果不能逃脱地牢，则输出”Trapped!”。</p>
<h4 id="数据范围-19">数据范围</h4>
<p>1≤L,R,C≤100</p>
<h4 id="输入样例-16">输入样例：</h4>
<pre><code>3 4 5
S....
.###.
.##..
###.#

#####
#####
##.##
##...

#####
#####
#.###
####E

1 3 3
S##
#E#
###

0 0 0
</code></pre>
<h4 id="输出样例-16">输出样例：</h4>
<pre><code>Escaped in 11 minute(s).
Trapped!
</code></pre>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 110;

struct Point
{
    int x, y, z;  // 表示坐标
};

int L, R, C;
char g[N][N][N];  // 表示地牢
int dist[N][N][N];  // 表示距离
Point q[N * N * N];  // 数组模拟队列, 注意要N * N * N
int dx[6] = {-1, 1, 0, 0, 0, 0};
int dy[6] = {0, 0, -1, 1, 0, 0};
int dz[6] = {0, 0, 0, 0, -1, 1};

int bfs(Point start, Point end) {
    int hh = 0, tt = 0;
    q[0] = start;
    memset(dist, -1, sizeof dist);
    dist[start.x][start.y][start.z] = 0;

    while (hh &lt;= tt) {
        // 取出对头元素
        Point t = q[hh ++];
        for (int i = 0; i &lt; 6; i ++) {
            int a = t.x + dx[i], b = t.y + dy[i], c = t.z + dz[i];
            if (a &lt; 0 || a &gt;= L || b &lt; 0 || b &gt;= R || c &lt; 0 || c &gt;= C) continue;  // 出界
            if (dist[a][b][c] != -1) continue;  // 已经到达
            if (g[a][b][c] == '#') continue;  // 障碍物
            dist[a][b][c] = dist[t.x][t.y][t.z] + 1;

            if (a == end.x &amp;&amp; b == end.y &amp;&amp; c == end.z) return dist[a][b][c];
            q[++ tt] = {a, b, c};
        }
    }

    return -1;
}

int main() {
    while (scanf(&quot;%d%d%d&quot;, &amp;L, &amp;R, &amp;C), L || R || C) {
        Point start, end;

        for (int i = 0; i &lt; L; i ++) {
            for (int j = 0; j &lt; R; j ++) {
                scanf(&quot;%s&quot;, g[i][j]);  // 读入面
                for (int k = 0; k &lt; C; k ++) {
                    // 找到起点和终点
                    if (g[i][j][k] == 'S') start = {i, j, k};
                    else if (g[i][j][k] == 'E') end = {i, j, k};
                }
            }
        }

        // 开始bfs 寻找答案
        int distance = bfs(start, end);
        if (distance == -1) printf(&quot;Trapped!\n&quot;);
        else printf(&quot;Escaped in %d minute(s).\n&quot;, distance);
    }

    return 0;
}
</code></pre>
<h2 id="flood-fill">Flood Fill</h2>
<h3 id="例题-1113-红与黑">例题 1113. 红与黑</h3>
<p><a href="https://www.acwing.com/problem/content/description/1115/">1113. 红与黑</a></p>
<p>有一间长方形的房子，地上铺了红色、黑色两种颜色的正方形瓷砖。</p>
<p>你站在其中一块黑色的瓷砖上，只能向相邻（上下左右四个方向）的黑色瓷砖移动。</p>
<p>请写一个程序，计算你总共能够到达多少块黑色的瓷砖。</p>
<h4 id="输入格式-20">输入格式</h4>
<p>输入包括多个数据集合。</p>
<p>每个数据集合的第一行是两个整数 W 和 H，分别表示 x 方向和 y 方向瓷砖的数量。</p>
<p>在接下来的 H 行中，每行包括 W 个字符。每个字符表示一块瓷砖的颜色，规则如下</p>
<p>1）‘.’：黑色的瓷砖；<br>
2）‘#’：红色的瓷砖；<br>
3）‘@’：黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中唯一出现一次。</p>
<p>当在一行中读入的是两个零时，表示输入结束。</p>
<h4 id="输出格式-20">输出格式</h4>
<p>对每个数据集合，分别输出一行，显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)。</p>
<h4 id="数据范围-20">数据范围</h4>
<p>1≤W,H≤20</p>
<h4 id="输入样例-17">输入样例：</h4>
<pre><code>6 9 
....#. 
.....# 
...... 
...... 
...... 
...... 
...... 
#@...# 
.#..#. 
0 0
</code></pre>
<h4 id="输出样例-17">输出样例：</h4>
<pre><code>45
</code></pre>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 25;

int n, m;
char g[N][N];
bool st[N][N];
int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};

int dfs(int x, int y) {
    int cnt = 1;
    st[x][y] = true;

    for (int i = 0; i &lt; 4; i ++) {
        int a = x + dx[i], b = y + dy[i];
        if (a &lt; 0 || a &gt;= m || b &lt; 0 || b &gt;= n) continue;  // 边界问题
        if (st[a][b]) continue;  // 已经遍历
        if (g[a][b] != '.') continue;  // 只走黑色

        cnt += dfs(a, b);
    }

    return cnt;
}

int main() {
    while (true) {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        if (n == 0 &amp;&amp; m == 0) break;
        for (int i = 0; i &lt; m; i ++) scanf(&quot;%s&quot;, &amp;g[i]);  // 读入迷宫

        // for (int i = 0; i &lt; m; i ++) cout &lt;&lt; g[i] &lt;&lt; endl;

        int x, y;
        for (int i = 0; i &lt; m; i ++) {
            for (int j = 0; j &lt; n; j ++) {
                if (g[i][j] == '@') {
                    x = i, y = j;
                }
            }
        }
        // cout &lt;&lt; x &lt;&lt; y &lt;&lt; endl;

        memset(st, 0, sizeof st);

        int res = dfs(x, y);

        printf(&quot;%d\n&quot;, res);
    }

    return 0;
}
</code></pre>
<h3 id="习题-1233-全球变暖">习题 1233. 全球变暖</h3>
<p><a href="https://www.acwing.com/problem/content/1235/">1233. 全球变暖</a></p>
<p>你有一张某海域 N×N像素的照片，”.”表示海洋、”#”表示陆地，如下所示：</p>
<pre><code>.......
.##....
.##....
....##.
..####.
...###.
.......
</code></pre>
<p>其中”上下左右”四个方向上连在一起的一片陆地组成一座岛屿，例如上图就有 2座岛屿。</p>
<p>由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。</p>
<p>具体来说如果一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋)，它就会被淹没。</p>
<p>例如上图中的海域未来会变成如下样子：</p>
<pre><code>.......
.......
.......
.......
....#..
.......
.......
</code></pre>
<p>请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。</p>
<h4 id="输入格式-21">输入格式</h4>
<p>第一行包含一个整数N。</p>
<p>以下 N 行 N列，包含一个由字符”#”和”.”构成的 N×N字符矩阵，代表一张海域照片，”#”表示陆地，”.”表示海洋。</p>
<p>照片保证第 11 行、第 11 列、第 N行、第 N列的像素都是海洋。</p>
<h4 id="输出格式-21">输出格式</h4>
<p>一个整数表示答案。</p>
<h4 id="数据范围-21">数据范围</h4>
<p>1≤N≤1000</p>
<h4 id="输入样例1-4">输入样例1：</h4>
<pre><code>7
.......
.##....
.##....
....##.
..####.
...###.
.......
</code></pre>
<h4 id="输出样例1-4">输出样例1：</h4>
<pre><code>1
</code></pre>
<h4 id="输入样例2-4">输入样例2：</h4>
<pre><code>9
.........
.##.##...
.#####...
.##.##...
.........
.##.#....
.#.###...
.#..#....
.........
</code></pre>
<h4 id="输出样例2-4">输出样例2：</h4>
<pre><code>1
</code></pre>
<h4 id="找到有多少连通块">找到有多少连通块</h4>
<figure data-type="image" tabindex="128"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206135838113.png" alt="image-20230206135838113" loading="lazy"></figure>
<h4 id="统计多少个会被淹没">统计多少个会被淹没</h4>
<figure data-type="image" tabindex="129"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206140105978.png" alt="image-20230206140105978" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#define x first
#define y second

using namespace std;

typedef pair&lt;int, int&gt; PII;

const int N = 1010;

int n;
int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};
char g[N][N];
bool st[N][N];
PII q[N * N];

void bfs(int x, int y, int &amp;total, int &amp;bound) {
    int hh = 0, tt = 0;
    q[0] = {x, y};
    st[x][y] = true;

    while (hh &lt;= tt) {
        auto t = q[hh ++];
        total ++;  // 总数 ++
        bool is_bound = false;   // 从陆地开始，所以is_bound 为 false
        for (int i = 0; i &lt; 4; i ++) {
            int a = t.x + dx[i], b = t.y + dy[i];
            if (a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= n) continue;  // 出界
            if (st[a][b]) continue;  // 已经遍历过
            if (g[a][b] == '.') {
                is_bound = true;
                continue;  
            }
            q[++ tt] = {a, b};
            st[a][b] = true;
        }
        if (is_bound) bound ++;
    }
}

int main() {
    scanf(&quot;%d&quot;, &amp;n);

    for (int i = 0; i &lt; n; i ++) scanf(&quot;%s&quot;, &amp;g[i]);

    int cnt = 0;  // 表示最终被淹没的岛屿的数量
    for (int i = 0; i &lt; n; i ++) {
        for (int j = 0; j &lt; n; j ++) {
            if (g[i][j] == '#' &amp;&amp; !st[i][j]) {
                int total = 0, bound = 0;
                bfs(i, j, total, bound);

                if (total == bound) cnt ++;
            }
        }
    }
    printf(&quot;%d\n&quot;, cnt);

    return 0;
}
</code></pre>
<h2 id="图论">图论</h2>
<h3 id="例题-1224-交换瓶子">例题 1224. 交换瓶子</h3>
<p><a href="https://www.acwing.com/problem/content/1226/">1224. 交换瓶子</a></p>
<p>有 N个瓶子，编号 1∼N，放在架子上。</p>
<p>比如有 5 个瓶子：</p>
<pre><code>2 1 3 5 4
</code></pre>
<p>要求每次拿起 2个瓶子，交换它们的位置。</p>
<p>经过若干次后，使得瓶子的序号为：</p>
<pre><code>1 2 3 4 5
</code></pre>
<p>对于这么简单的情况，显然，至少需要交换 2 次就可以复位。</p>
<p>如果瓶子更多呢？你可以通过编程来解决。</p>
<h4 id="输入格式-22">输入格式</h4>
<p>第一行包含一个整数 N，表示瓶子数量。</p>
<p>第二行包含 N 个整数，表示瓶子目前的排列状况。</p>
<h4 id="输出格式-22">输出格式</h4>
<p>输出一个正整数，表示至少交换多少次，才能完成排序。</p>
<h4 id="数据范围-22">数据范围</h4>
<p>1≤N≤10000</p>
<h4 id="输入样例1-5">输入样例1：</h4>
<pre><code>5
3 1 2 5 4
</code></pre>
<h4 id="输出样例1-5">输出样例1：</h4>
<pre><code>3
</code></pre>
<h4 id="输入样例2-5">输入样例2：</h4>
<pre><code>5
5 4 3 2 1
</code></pre>
<h4 id="输出样例2-5">输出样例2：</h4>
<pre><code>2
</code></pre>
<figure data-type="image" tabindex="130"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230205223305428.png" alt="image-20230205223305428" loading="lazy"></figure>
<figure data-type="image" tabindex="131"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230205223516132.png" alt="image-20230205223516132" loading="lazy"></figure>
<figure data-type="image" tabindex="132"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230205223947914.png" alt="image-20230205223947914" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 10010;

int n;
bool st[N];  // 用来记录每个瓶子是否被用过
int b[N];  // 用来记录瓶子序列

int main() {
    scanf(&quot;%d&quot;, &amp;n);

    for (int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;b[i]);

    int cnt = 0;  // 环的数量
    for (int i = 1; i &lt;= n; i ++) {
        if (!st[i]) {
            // 没有遍历过
            cnt ++;
            for (int j = i; !st[j]; j = b[j]) {  // j = b[j] 表示 第j位的数字是几
                st[j] = true;  // 将这个环上的数全部设置为true
            }
        }
    }
    printf(&quot;%d\n&quot;, n - cnt);

    return 0;
}

</code></pre>
<h3 id="习题-1207-大臣的旅费">习题 1207. 大臣的旅费</h3>
<p><a href="https://www.acwing.com/problem/content/1209/">1207. 大臣的旅费</a></p>
<p>很久以前，T王国空前繁荣。</p>
<p>为了更好地管理国家，王国修建了大量的快速路，用于连接首都和王国内的各大城市。</p>
<p>为节省经费，T国的大臣们经过思考，制定了一套优秀的修建方案，使得任何一个大城市都能从首都直接或者通过其他大城市间接到达。</p>
<p>同时，如果不重复经过大城市，从首都到达每个大城市的方案都是唯一的。</p>
<p>J是T国重要大臣，他巡查于各大城市之间，体察民情。</p>
<p>所以，从一个城市马不停蹄地到另一个城市成了J最常做的事情。</p>
<p>他有一个钱袋，用于存放往来城市间的路费。</p>
<p>聪明的J发现，如果不在某个城市停下来修整，在连续行进过程中，他所花的路费与他已走过的距离有关，在走第x千米到第x+1千米这一千米中（x是整数），他花费的路费是x+10这么多。也就是说走1千米花费11，走2千米要花费23。</p>
<p>J大臣想知道：他从某一个城市出发，中间不休息，到达另一个城市，所有可能花费的路费中最多是多少呢？</p>
<h4 id="输入格式-23">输入格式</h4>
<p>输入的第一行包含一个整数 n，表示包括首都在内的T王国的城市数。</p>
<p>城市从 1开始依次编号，1 号城市为首都。</p>
<p>接下来 n−1行，描述T国的高速路（T国的高速路一定是 n−1条）。</p>
<p>每行三个整数 Pi,Qi,Di，表示城市 Pi 和城市 Qi 之间有一条<strong>双向</strong>高速路，长度为 Di千米。</p>
<h4 id="输出格式-23">输出格式</h4>
<p>输出一个整数，表示大臣J最多花费的路费是多少。</p>
<h4 id="数据范围-23">数据范围</h4>
<p>1≤n≤105,<br>
1≤Pi,Qi≤n<br>
1≤Di≤1000</p>
<h4 id="输入样例-18">输入样例：</h4>
<pre><code>5 
1  2  2 
1  3  1 
2  4  5 
2  5  4 
</code></pre>
<h4 id="输出样例-18">输出样例：</h4>
<pre><code>135
</code></pre>
<figure data-type="image" tabindex="133"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206143656312.png" alt="image-20230206143656312" loading="lazy"></figure>
<figure data-type="image" tabindex="134"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206143912315.png" alt="image-20230206143912315" loading="lazy"></figure>
<figure data-type="image" tabindex="135"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206145135638.png" alt="image-20230206145135638" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

const int N = 1e5 + 10;

struct Edge{
    int id, w;  // 用来记录每条边的结构体
};


int n;
int dist[N];
vector&lt;Edge&gt; h[N];

void dfs(int u, int father, int distance) {
    dist[u] = distance;

    for (auto node : h[u]) {
        // 遍历 与 当前u 连通的节点
        if (node.id != father) {
            dfs(node.id, u, distance + node.w);
        }
    }
}

int main() {
    scanf(&quot;%d&quot;, &amp;n);

    for (int i = 0; i &lt; n; i ++) {
        int a, b, c;
        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
        h[a].push_back({b, c});
        h[b].push_back({a, c});
    }

    dfs(1, -1, 0);  // 任意从一个点开始dfs

    int u = 1;
    for (int i = 1; i &lt;= n; i ++) {
        if (dist[i] &gt; dist[u]) u = i;
    }

    dfs(u, -1, 0);  // 从距离之前选中点最远的点开始遍历

    for (int i = 1; i &lt;= n; i ++) {
        if (dist[i] &gt; dist[u]) u = i;
    }

    int s = dist[u];

    printf(&quot;%lld\n&quot;, s * 10 + (s + 1ll) * s / 2);   // 防止爆int

    return 0;
}
</code></pre>
<h2 id="数组模拟链表">数组模拟链表</h2>
<figure data-type="image" tabindex="136"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206153654109.png" alt="image-20230206153654109" loading="lazy"></figure>
<h3 id="初始化">初始化</h3>
<pre><code class="language-c++">void init() {
    // 初始化，head 指向空集，idx 为0
    head = -1;
    idx = 0;
}
</code></pre>
<h3 id="将x插到头节点">将x插到头节点</h3>
<figure data-type="image" tabindex="137"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206155146082.png" alt="image-20230206155146082" loading="lazy"></figure>
<pre><code class="language-c++">void add_to_head(int x) {
    // 将要插入的点指向head节点的next节点
    // 将head节点指向要插入的节点
    e[idx] = x, ne[idx] = head, head = idx, idx ++;
    // 分步写法
    // e[idx] = x;
    // ne[idx] = head;
    // head = idx;
    // idx ++;  // 当前idx 已经被使用过，故++
}
</code></pre>
<h3 id="将x插到下标为k的节点后">将x插到下标为k的节点后</h3>
<figure data-type="image" tabindex="138"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206155310128.png" alt="image-20230206155310128" loading="lazy"></figure>
<pre><code class="language-c++">void add(int k, int x) {
    // 将x 插入到下标为k的节点后面
    e[idx] = x, ne[idx] = ne[k], ne[k] = idx, idx ++;
}
</code></pre>
<h3 id="将下标是k的后面的节点删掉">将下标是k的后面的节点删掉</h3>
<figure data-type="image" tabindex="139"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206155551910.png" alt="image-20230206155551910" loading="lazy"></figure>
<pre><code class="language-c++">void remove(int k) {
    // 删除下标为k 的节点后的节点
    ne[k] = ne[ne[k]];
}
</code></pre>
<h3 id="例题-826-单链表">例题 826. 单链表</h3>
<p><a href="https://www.acwing.com/problem/content/description/828/">826. 单链表</a></p>
<p>实现一个单链表，链表初始为空，支持三种操作：</p>
<ol>
<li>向链表头插入一个数；</li>
<li>删除第 k 个插入的数后面的数；</li>
<li>在第 k个插入的数后插入一个数。</li>
</ol>
<p>现在要对该链表进行 M 次操作，进行完所有操作后，从头到尾输出整个链表。</p>
<p><strong>注意</strong>:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1个插入的数，第 2 个插入的数，…第 n 个插入的数。</p>
<h4 id="输入格式-24">输入格式</h4>
<p>第一行包含整数 M，表示操作次数。</p>
<p>接下来 M行，每行包含一个操作命令，操作命令可能为以下几种：</p>
<ol>
<li><code>H x</code>，表示向链表头插入一个数 x。</li>
<li><code>D k</code>，表示删除第 k 个插入的数后面的数（当 k 为 0 时，表示删除头结点）。</li>
<li><code>I k x</code>，表示在第 k 个插入的数后面插入一个数 x（此操作中 k 均大于 0）。</li>
</ol>
<h4 id="输出格式-24">输出格式</h4>
<p>共一行，将整个链表从头到尾输出。</p>
<h4 id="数据范围-24">数据范围</h4>
<p>1≤M≤100000<br>
所有操作保证合法。</p>
<h4 id="输入样例-19">输入样例：</h4>
<pre><code>10
H 9
I 1 1
D 1
D 0
H 6
I 3 6
I 4 5
I 4 5
I 3 4
D 6
</code></pre>
<h4 id="输出样例-19">输出样例：</h4>
<pre><code>6 4 6 5
</code></pre>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 100010;

int n;
// head 表示头节点
// e[i] 表示节点i对应的值
// ne[i] 表示节点i对应的next节点
// idx 表示当前用到了多少个指针
int head, e[N], ne[N], idx;

void init() {
    // 初始化，head 指向空集，idx 为0
    head = -1;
    idx = 0;
}

void add_to_head(int x) {
    // 将要插入的点指向head节点的next节点
    // 将head节点指向要插入的节点
    e[idx] = x, ne[idx] = head, head = idx, idx ++;
    // 分步写法
    // e[idx] = x;
    // ne[idx] = head;
    // head = idx;
    // idx ++;  // 当前idx 已经被使用过，故++
}

void insert(int k, int x) {
    // 将x 插入到下标为k的节点后面
    e[idx] = x, ne[idx] = ne[k], ne[k] = idx, idx ++;
}

void remove(int k) {
    // 删除下标为k 的节点后的节点
    ne[k] = ne[ne[k]];
}

int main() {
    scanf(&quot;%d\n&quot;, &amp;n);

    init();
    while (n --) {
        char op;
        int k, x;
        scanf(&quot;%c&quot;, &amp;op);
        if (op == 'H') {
            scanf(&quot;%d\n&quot;, &amp;x);
            add_to_head(x);
        } else if (op == 'I') {
            scanf(&quot;%d%d\n&quot;, &amp;k, &amp;x);
            insert(k - 1, x);
        } else if (op == 'D') {
            scanf(&quot;%d\n&quot;, &amp;k);
            if (!k) head = ne[head];
            else remove(k - 1);
        }
    }

    // 遍历整个链表输出
    for (int i = head; i != -1; i = ne[i]) printf(&quot;%d &quot;, e[i]);
    printf(&quot;\n&quot;);

    return 0;
}
</code></pre>
<h3 id="习题-1243-糖果">习题 1243. 糖果</h3>
<p><a href="https://www.acwing.com/problem/content/1245/">1243. 糖果</a></p>
<p>糖果店的老板一共有 M 种口味的糖果出售。</p>
<p>为了方便描述，我们将 M 种口味编号 1∼M。</p>
<p>小明希望能品尝到所有口味的糖果。</p>
<p>遗憾的是老板并不单独出售糖果，而是 K 颗一包整包出售。</p>
<p>幸好糖果包装上注明了其中 K 颗糖果的口味，所以小明可以在买之前就知道每包内的糖果口味。</p>
<p>给定 N 包糖果，请你计算小明最少买几包，就可以品尝到所有口味的糖果。</p>
<h4 id="输入格式-25">输入格式</h4>
<p>第一行包含三个整数 N,M,K。</p>
<p>接下来 N 行每行 K 个整数 T1,T2,⋅⋅⋅,TK，代表一包糖果的口味。</p>
<h4 id="输出格式-25">输出格式</h4>
<p>一个整数表示答案。</p>
<p>如果小明无法品尝所有口味，输出 −1。</p>
<h4 id="数据范围-25">数据范围</h4>
<p>1≤N≤100,<br>
1≤M,K≤20,<br>
1≤Ti≤M</p>
<h4 id="输入样例-20">输入样例：</h4>
<pre><code>6 5 3
1 1 2
1 2 3
1 1 3
2 3 5
5 4 2
5 1 2
</code></pre>
<h4 id="输出样例-20">输出样例：</h4>
<pre><code>2
</code></pre>
<figure data-type="image" tabindex="140"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230208163636558.png" alt="image-20230208163636558" loading="lazy"></figure>
<figure data-type="image" tabindex="141"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230208164317619.png" alt="image-20230208164317619" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

const int N = 110, M = 1 &lt;&lt; 20;

vector&lt;int&gt; col[N];  // 用来记录col中每一列可选择的行数有哪些
int n, m, k;
int log2[M];  // 预处理，方便计算log2(2的n次方)

int lowbit(int x) {
    return x &amp; -x;
}

int h(int state) {
    // 估价函数，计算此时state最少需要用几行来完成
    int res = 0;
    for (int i = (1 &lt;&lt; m) - 1 - state; i; i -=lowbit(i)) {
        // 选择了某一列， 则表示选择了这一列的所有的方案数
        int c = log2[lowbit(i)];
        res ++;
        for (auto row: col[c]) {
            i &amp;= ~row;  //row表示哪一列有1，每次选择一种方案，等价于将这种方案对应的位变为0
        }
    }

    return res;
}

bool dfs(int depth, int state) {  // depth 表示层数， state 用来表示当前选了哪些糖果
    if (!depth || h(state) &gt; depth) {
        // 若可选择的方案为0或者最小需要选择的方案数都小于当前可选的方案数的话，则判断是否合法
        //判断方法：看state是否全为1
        return state == (1 &lt;&lt; m) - 1;  // (1&lt;&lt;m)-1表示m位全是一， 即2^m-1
    }
    int t = -1;  // 找选择数最少的一列
    for (int i = (1 &lt;&lt; m) - 1 - state; i; i -=lowbit(i)) {
        int c = log2[lowbit(i)];  
        if (t == -1 || col[t].size() &gt; col[c].size()) {
            t = c;
        }
    }
    // 枚举接下来选哪一行
    for (auto row : col[t]) {
        if (dfs(depth - 1, state | row)) return true;
    }

    return false;
}


int main() {
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);

    // 预处理log2数组
    for (int i = 0; i &lt; m; i ++) log2[1 &lt;&lt; i] = i;

    for (int i = 0; i &lt; n; i ++) {
        int state = 0;
        
        for (int j = 0; j &lt; k; j ++) {
            // 将这一包所包含的糖果的位置变成1
            int c;
            scanf(&quot;%d&quot;, &amp;c);
            state |= 1 &lt;&lt; c - 1;  // 位运算
        }

        for (int j = 0; j &lt; m; j ++) {
            // 找出这一包中哪些位置 还可以 填1
            if (state &gt;&gt; j &amp; 1) {
                //  第 j 位有1
                col[j].push_back(state);
            }
        }
    }

    for (int i = 0; i &lt; m; i ++ ) {
        sort(col[i].begin(), col[i].end());
        col[i].erase(unique(col[i].begin(), col[i].end()), col[i].end());
    }

    int depth = 0;
    while (depth &lt;= m &amp;&amp; !dfs(depth, 0)) depth ++;

    if (depth &gt; m) depth = -1;   // 无解
    printf(&quot;%d\n&quot;, depth);

    return 0;
}
</code></pre>
<h1 id="贪心">贪心</h1>
<h3 id="例题-1055-股票买卖-ii">例题 1055. 股票买卖 II</h3>
<p><a href="https://www.acwing.com/problem/content/1057/">1055. 股票买卖 II</a></p>
<p>给定一个长度为 N 的数组，数组中的第 i 个数字表示一个给定股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<h4 id="输入格式-26">输入格式</h4>
<p>第一行包含整数 N，表示数组长度。</p>
<p>第二行包含 N 个不大于 10000的正整数，表示完整的数组。</p>
<h4 id="输出格式-26">输出格式</h4>
<p>输出一个整数，表示最大利润。</p>
<h4 id="数据范围-26">数据范围</h4>
<p>1≤N≤10^5</p>
<h4 id="输入样例1-6">输入样例1：</h4>
<pre><code>6
7 1 5 3 6 4
</code></pre>
<h4 id="输出样例1-6">输出样例1：</h4>
<pre><code>7
</code></pre>
<h4 id="输入样例2-6">输入样例2：</h4>
<pre><code>5
1 2 3 4 5
</code></pre>
<h4 id="输出样例2-6">输出样例2：</h4>
<pre><code>4
</code></pre>
<h4 id="输入样例3">输入样例3：</h4>
<pre><code>5
7 6 4 3 1
</code></pre>
<h4 id="输出样例3">输出样例3：</h4>
<pre><code>0
</code></pre>
<h4 id="样例解释-5">样例解释</h4>
<p>样例1：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。共得利润 4+3 = 7。</p>
<p>样例2：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p>
<p>样例3：在这种情况下, 不进行任何交易, 所以最大利润为 0。</p>
<figure data-type="image" tabindex="142"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206163716435.png" alt="image-20230206163716435" loading="lazy"></figure>
<figure data-type="image" tabindex="143"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206163944673.png" alt="image-20230206163944673" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 1e5 + 10;

int n;
int price[N];

int main() {
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;price[i]);

    int res = 0;
    for (int i = 0; i + 1 &lt; n; i ++) {
        int dt = price[i + 1] - price[i];
        if (dt &gt; 0) res += dt;
    }

    printf(&quot;%d\n&quot;, res);

    return 0;
}
</code></pre>
<h3 id="例题-104-货仓选址">例题 104. 货仓选址</h3>
<p><a href="https://www.acwing.com/problem/content/106/">104. 货仓选址</a></p>
<figure data-type="image" tabindex="144"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206184220685.png" alt="image-20230206184220685" loading="lazy"></figure>
<figure data-type="image" tabindex="145"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206184140873.png" alt="image-20230206184140873" loading="lazy"></figure>
<figure data-type="image" tabindex="146"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206185146859.png" alt="image-20230206185146859" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

const int N = 100010;

int n;
int x[N];

int main() {
    scanf(&quot;%d&quot;, &amp;n);

    for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;x[i]);
    sort(x, x + n);

    int c = x[n &gt;&gt; 1];  // n/2 下取整可同时满足n为奇数与偶数的情况
    LL res = 0;
    for (int i = 0; i &lt; n; i++) res += abs(x[i] - c);

    printf(&quot;%lld\n&quot;, res);

    return 0;
}
</code></pre>
<h3 id="例题-122-糖果传递">例题 122. 糖果传递</h3>
<p><a href="https://www.acwing.com/problem/content/124/">122. 糖果传递</a></p>
<figure data-type="image" tabindex="147"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206190110987.png" alt="image-20230206190110987" loading="lazy"></figure>
<figure data-type="image" tabindex="148"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206192331156.png" alt="image-20230206192331156" loading="lazy"></figure>
<figure data-type="image" tabindex="149"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206192305305.png" alt="image-20230206192305305" loading="lazy"></figure>
<figure data-type="image" tabindex="150"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206191857702.png" alt="image-20230206191857702" loading="lazy"></figure>
<figure data-type="image" tabindex="151"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206192526594.png" alt="image-20230206192526594" loading="lazy"></figure>
<figure data-type="image" tabindex="152"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206193426328.png" alt="image-20230206193426328" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

const int N = 1000010;

int n;
int a[N];
int c[N];

int main() {
    scanf(&quot;%d&quot;, &amp;n);

    LL s = 0;
    for (int i = 1; i &lt;= n; i ++) {
        scanf(&quot;%d&quot;, &amp;a[i]);
        s += a[i];
    }
    LL avg = s / n;

    for (int i = n; i &gt;= 1; i --) {
        c[i] = c[i + 1] + avg - a[i];
    }
    c[1] = 0;
    sort(c + 1, c + n + 1);
    LL cen = c[(n + 1) / 2];
    LL res = 0;
    for (int i = 1; i &lt;= n; i ++) res += abs(c[i] - cen);

    printf(&quot;%lld\n&quot;, res);

    return 0;
}
</code></pre>
<h3 id="例题-112-雷达设备">例题 112. 雷达设备</h3>
<p><a href="https://www.acwing.com/problem/content/114/">112. 雷达设备</a></p>
<p>假设海岸是一条无限长的直线，陆地位于海岸的一侧，海洋位于另外一侧。</p>
<p>每个小岛都位于海洋一侧的某个点上。</p>
<p>雷达装置均位于海岸线上，且雷达的监测范围为 d，当小岛与某雷达的距离不超过 d 时，该小岛可以被雷达覆盖。</p>
<p>我们使用笛卡尔坐标系，定义海岸线为 x 轴，海的一侧在 x 轴上方，陆地一侧在 x 轴下方。</p>
<p>现在给出每个小岛的具体坐标以及雷达的检测范围，请你求出能够使所有小岛都被雷达覆盖所需的最小雷达数目。</p>
<h4 id="输入格式-27">输入格式</h4>
<p>第一行输入两个整数 n 和 d，分别代表小岛数目和雷达检测范围。</p>
<p>接下来 n 行，每行输入两个整数，分别代表小岛的 x，y 轴坐标。</p>
<p>同一行数据之间用空格隔开。</p>
<h4 id="输出格式-27">输出格式</h4>
<p>输出一个整数，代表所需的最小雷达数目，若没有解决方案则所需数目输出 −1−1。</p>
<h4 id="数据范围-27">数据范围</h4>
<p>1≤n≤1000,<br>
−1000≤x,y≤1000</p>
<h4 id="输入样例-21">输入样例：</h4>
<pre><code>3 2
1 2
-3 1
2 1
</code></pre>
<h4 id="输出样例-21">输出样例：</h4>
<pre><code>2
</code></pre>
<figure data-type="image" tabindex="153"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206195750341.png" alt="image-20230206195750341" loading="lazy"></figure>
<figure data-type="image" tabindex="154"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206200401138.png" alt="image-20230206200401138" loading="lazy"></figure>
<figure data-type="image" tabindex="155"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206200810332.png" alt="image-20230206200810332" loading="lazy"></figure>
<figure data-type="image" tabindex="156"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206201032953.png" alt="image-20230206201032953" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;

const int N = 1010;

struct Segment
{
    double l, r;
    bool operator&lt; (const Segment &amp;t) {
        return r &lt; t.r;  // 重载运算符， 按照右端点排序
    }
} segs[N];

int n, r;  // 数量与半径

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;r);

    bool failed = false;  // 如果y坐标大于半径，则
    for (int i = 0; i &lt; n; i ++) {
        int x, y;
        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
        if (y &gt; r) failed = true;
        else {
            double l = sqrt(r * r - y * y);
            segs[i] = {x - l , x + l};
        }
    }

    if (failed) printf(&quot;-1&quot;);
    else {
        int cnt = 0;
        sort(segs, segs + n);  // 先将线段按照右端点排序
        double last = -1e20;
        for (int i = 0; i &lt; n; i ++) {
            if (segs[i].l &gt; last){
                cnt ++;
                last = segs[i].r;
            }
        }
        printf(&quot;%d\n&quot;, cnt);
    }

    return 0;
}
</code></pre>
<h3 id="习题-1235-付账问题">习题 1235. 付账问题</h3>
<p><a href="https://www.acwing.com/problem/content/1237/">1235. 付账问题</a></p>
<p>几个人一起出去吃饭是常有的事。</p>
<p>但在结帐的时候，常常会出现一些争执。</p>
<p>现在有 n个人出去吃饭，他们总共消费了 S元。</p>
<p>其中第 i 个人带了 ai元。</p>
<p>幸运的是，所有人带的钱的总数是足够付账的，但现在问题来了：每个人分别要出多少钱呢？</p>
<p>为了公平起见，我们希望在总付钱量恰好为 S 的前提下，最后每个人付的钱的标准差最小。</p>
<p>这里我们约定，每个人支付的钱数可以是任意非负实数，即可以不是 1 分钱的整数倍。</p>
<p>你需要输出最小的标准差是多少。</p>
<p>标准差的介绍：标准差是多个数与它们平均数差值的平方平均数，一般用于刻画这些数之间的“偏差有多大”。</p>
<p>形式化地说，设第 i 个人付的钱为 bi 元，那么标准差为 :</p>
<figure data-type="image" tabindex="157"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/19_6734517a16-p1.png" alt="p1.png" loading="lazy"></figure>
<h4 id="输入格式-28">输入格式</h4>
<p>第一行包含两个整数 n、S；</p>
<p>第二行包含 n个非负整数 a1, …, an。</p>
<h4 id="输出格式-28">输出格式</h4>
<p>输出最小的标准差，四舍五入保留 44 位小数。</p>
<h4 id="数据范围-28">数据范围</h4>
<p>1≤n≤5×10^5<br>
0≤ai≤10^9<br>
0≤S≤10^15</p>
<h4 id="输入样例1-7">输入样例1：</h4>
<pre><code>5 2333
666 666 666 666 666
</code></pre>
<h4 id="输出样例1-7">输出样例1：</h4>
<pre><code>0.0000
</code></pre>
<h4 id="输入样例2-7">输入样例2：</h4>
<pre><code>10 30
2 1 4 7 4 8 3 6 4 7
</code></pre>
<h4 id="输出样例2-7">输出样例2：</h4>
<pre><code>0.7928
</code></pre>
<figure data-type="image" tabindex="158"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206232123854.png" alt="image-20230206232123854" loading="lazy"></figure>
<figure data-type="image" tabindex="159"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206232418446.png" alt="image-20230206232418446" loading="lazy"></figure>
<figure data-type="image" tabindex="160"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206232821145.png" alt="image-20230206232821145" loading="lazy"></figure>
<figure data-type="image" tabindex="161"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206233147227.png" alt="image-20230206233147227" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;

const int N = 5e5 + 10;

int n;
int a[N];  // 用来存储 每个同学所携带的钱数

int main() {
    long double s;
    scanf(&quot;%d%Lf&quot;, &amp;n, &amp;s);

    for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;a[i]);

    sort(a, a + n);  // ** 注意一定要排序
    long double res = 0, avg = s / n;
    for (int i = 0; i &lt; n; i ++) {
        double cur = s / (n - i);  // cur 表示当前的同学应该平摊的费用
        if (cur &gt; a[i]) cur = a[i];
        s -= cur;
        res += (cur - avg) * (cur - avg);
    }

    printf(&quot;%.4Lf\n&quot;, sqrt(res / n));

    return 0;
}
</code></pre>
<h3 id="习题-1239-乘积最大">习题 1239. 乘积最大</h3>
<p><a href="https://www.acwing.com/problem/content/1241/">1239. 乘积最大</a></p>
<p>给定 N 个整数 A1,A2,…AN</p>
<p>请你从中选出 K 个数，使其乘积最大。</p>
<p>请你求出最大的乘积，由于乘积可能超出整型范围，你只需输出乘积除以 1000000009的余数。</p>
<p>注意，如果 X&lt;0， 我们定义 X 除以 1000000009的余数是负(−X)除以 1000000009的余数，即：0−((0−x)%1000000009)</p>
<h4 id="输入格式-29">输入格式</h4>
<p>第一行包含两个整数 N 和 K。</p>
<p>以下 N 行每行一个整数 Ai。</p>
<h4 id="输出格式-29">输出格式</h4>
<p>输出一个整数，表示答案。</p>
<h4 id="数据范围-29">数据范围</h4>
<p>1≤K≤N≤10^5<br>
−10<sup>5≤Ai≤10</sup>5</p>
<h4 id="输入样例1-8">输入样例1：</h4>
<pre><code>5 3
-100000
-10000
2
100000
10000
</code></pre>
<h4 id="输出样例1-8">输出样例1：</h4>
<pre><code>999100009
</code></pre>
<h4 id="输入样例2-8">输入样例2：</h4>
<pre><code>5 3
-100000
-100000
-2
-100000
-100000
</code></pre>
<h4 id="输出样例2-8">输出样例2：</h4>
<pre><code>-999999829
</code></pre>
<figure data-type="image" tabindex="162"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207123412429.png" alt="image-20230207123412429" loading="lazy"></figure>
<figure data-type="image" tabindex="163"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207123827239.png" alt="image-20230207123827239" loading="lazy"></figure>
<p>首先我们知道 如果 k == n ,那么就证明所有的数字是全部都选,<br>
如果 k &lt; n , 那么就要思考怎样去选择了:</p>
<ol>
<li>k 如果是偶数的话,选出来的结果一定是非负数 , 原因如下:<br>
(1) # 负数的个数是偶数个的话,负负得正,那么一定是非负数<br>
(2) # 负数的个数如果是奇数个的话,那么我们就只选偶数个绝对值最大的负数</li>
<li>k 如果是奇数个的话,<br>
(1)# 所有的数字如果都是负数,那么选出来的结果也一定都是负数<br>
(2)# 否则的话,则一定至少有 1个非负数, 那么我们将最大的数取出来, 此时要选的个数就是 k--,<br>
则 # k-- 是偶数,那么就又转化为 k-- 是偶数的情况思考</li>
</ol>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;

typedef long long LL;

const int N = 100010, MOD = 1000000009;

int n, k;
int a[N];

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
    for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]);
    sort(a, a + n);

    int l = 0, r = n - 1;  // 双指针初始化
    LL res = 1;
    int sign = 1;

    if (k % 2) {
        // k 是奇数，需要特殊处理符号后，转化为偶数处理方法
        res = a[r];
        r --, k --;
        if (res &lt; 0) sign = -1; 
    } 
    while (k) {
        LL x = (LL)a[l] * a[l + 1] , y = (LL)a[r] * a[r - 1];
        if (x * sign &gt; y *sign) {
            res = x % MOD * res % MOD;
            l += 2;        
        } else {
            res = y % MOD * res % MOD;
            r -= 2;
        }
        k -= 2;
    }
    printf(&quot;%lld\n&quot;, res);

    return 0;
}
</code></pre>
<h3 id="习题-1247-后缀表达式">习题 1247. 后缀表达式</h3>
<p><a href="https://www.acwing.com/problem/content/1249/">1247. 后缀表达式</a></p>
<figure data-type="image" tabindex="164"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207133636934.png" alt="image-20230207133636934" loading="lazy"></figure>
<figure data-type="image" tabindex="165"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207164610743.png" alt="image-20230207164610743" loading="lazy"></figure>
<figure data-type="image" tabindex="166"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207165137652.png" alt="image-20230207165137652" loading="lazy"></figure>
<figure data-type="image" tabindex="167"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207165531264.png" alt="image-20230207165531264" loading="lazy"></figure>
<p>给题意翻译翻译，其实就是有n个加号，m个减号，n+m+1个数，可以加括号，问组成表达式的最大值。</p>
<ul>
<li>特殊情况：m=0，直接输出和</li>
<li>一般情况：把所有数排个序，最大的拿出来，放首项，把最小的数拿出来，给他一个减号，再套一个括号，那么现在还未完成的表达式长这样：</li>
</ul>
<p>可以发现，现在如果我想加一个数的话，给它一个加号，放在括号外面，也可以给它一个减号，放在括号里面；减一个数同理。换句话说，只要用一个减号，一个最大值，一个最小值，其他数我想加就加，想减就减。那么为了使结果最大，我加上正数，减去负数，就是直接加上所有剩下数的绝对值，那么就解决了。</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;

typedef long long LL;

const int N = 200010;

int n, m;
int a[N];

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    int k = n + m + 1;
    for (int i = 0; i &lt; k; i ++) scanf(&quot;%d&quot;, &amp;a[i]);
    sort(a, a + k);
    
    LL res = 0;
    if (!m) {
        for (int i = 0; i &lt; k; i ++) res += a[i]; 
    } else {
        res = a[k - 1] - a[0];
        for (int i = 1; i &lt; k - 1; i ++) res += abs(a[i]);
    }

    printf(&quot;%lld\n&quot;, res);

    return 0;
}
</code></pre>
<h3 id="习题-1248-灵能传输">习题 1248. 灵能传输</h3>
<p><a href="https://www.acwing.com/problem/content/1250/">1248. 灵能传输</a></p>
<p>在游戏《星际争霸 II》中，高阶圣堂武士作为星灵的重要 AOE 单位，在游戏的中后期发挥着重要的作用，其技能”灵能风暴“可以消耗大量的灵能对一片区域内的敌军造成毁灭性的伤害。</p>
<p>经常用于对抗人类的生化部队和虫族的刺蛇飞龙等低血量单位。</p>
<p>你控制着 n 名高阶圣堂武士，方便起见标为 1,2,⋅⋅⋅,n。</p>
<p>每名高阶圣堂武士需要一定的灵能来战斗，每个人有一个灵能值 ai 表示其拥有的灵能的多少（ai 非负表示这名高阶圣堂武士比在最佳状态下多余了 ai点灵能，ai 为负则表示这名高阶圣堂武士还需要 −ai点灵能才能到达最佳战斗状态）。</p>
<p>现在系统赋予了你的高阶圣堂武士一个能力，传递灵能，每次你可以选择一个 i∈[2,n−1]，若 ai≥0则其两旁的高阶圣堂武士，也就是 i−1、i+1 这两名高阶圣堂武士会从 i这名高阶圣堂武士这里各抽取 ai 点灵能；若 ai&lt;0 则其两旁的高阶圣堂武士，也就是 i−1,i+1这两名高阶圣堂武士会给 i 这名高阶圣堂武士 −ai 点灵能。</p>
<p>形式化来讲就是 ai−1+=ai,ai+1+=ai,ai−=2ai。</p>
<p>灵能是非常高效的作战工具，同时也非常危险且不稳定，一位高阶圣堂武士拥有的灵能过多或者过少都不好，定义一组高阶圣堂武士的不稳定度为 maxni=1|ai|，请你通过不限次数的传递灵能操作使得你控制的这一组高阶圣堂武士的不稳定度最小。</p>
<h4 id="输入格式-30">输入格式</h4>
<p>本题包含多组询问。输入的第一行包含一个正整数 T 表示询问组数。</p>
<p>接下来依次输入每一组询问。</p>
<p>每组询问的第一行包含一个正整数 n，表示高阶圣堂武士的数量。</p>
<p>接下来一行包含 n 个数 a1,a2,⋅⋅⋅,an。</p>
<h4 id="输出格式-30">输出格式</h4>
<p>输出 T 行。</p>
<p>每行一个整数依次表示每组询问的答案。</p>
<h4 id="数据范围-30">数据范围</h4>
<p>1≤T≤3,</p>
<p>3≤n≤300000,</p>
<p>|ai|≤10^9</p>
<p>每个评测用例的限制如下：</p>
<figure data-type="image" tabindex="168"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207133848999.png" alt="image-20230207133848999" loading="lazy"></figure>
<h4 id="输入样例1-9">输入样例1：</h4>
<pre><code>3
3
5 -2 3
4
0 0 0 0
3
1 2 3
</code></pre>
<h4 id="输出样例1-9">输出样例1：</h4>
<pre><code>3
0
3
</code></pre>
<h4 id="输入样例2-9">输入样例2：</h4>
<pre><code>3
4
-1 -2 -3 7
4
2 3 4 -8
5
-1 -1 6 -1 -1
</code></pre>
<h4 id="输出样例2-9">输出样例2：</h4>
<pre><code>5
7
4
</code></pre>
<h4 id="样例解释-6">样例解释</h4>
<p>样例一<br>
对于第一组询问：<br>
对 22 号高阶圣堂武士进行传输操作后 a1=3，a2=2，a3=1。答案为 3。<br>
对于第二组询问：<br>
这一组高阶圣堂武士拥有的灵能都正好可以让他们达到最佳战斗状态。</p>
<figure data-type="image" tabindex="169"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207171055995.png" alt="image-20230207171055995" loading="lazy"></figure>
<figure data-type="image" tabindex="170"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207171618554.png" alt="image-20230207171618554" loading="lazy"></figure>
<figure data-type="image" tabindex="171"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207172831680.png" alt="image-20230207172831680" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;

typedef long long LL;

const int N = 300010;

int T, n;
LL a[N], s[N];
bool st[N];

int main() {
    scanf(&quot;%d&quot;, &amp;T);
    while (T --) {
        scanf(&quot;%d&quot;, &amp;n);
        s[0] = 0;

        memset(st, 0, sizeof st);
        for (int i = 1; i &lt;= n; i ++) {
            scanf(&quot;%lld&quot;, &amp;a[i]);
            s[i] = s[i - 1] + a[i];  // 初始化
        }
        LL s0 = s[0], sn = s[n];
        if (s0 &gt; sn) swap(s0, sn);
        sort(s, s + n + 1);

        // 查找下标
        for (int i = 0; i &lt;= n; i ++) {
            if (s0 == s[i]) {
                s0 = i;
                break;
            }
        }
        for (int i = n; i &gt;= 0; i --) {
            if (sn == s[i]) {
                sn = i;
                break;
            }
        }
        
        int l = 0, r = n;
        LL res = 0;  // s0 往左
        for (int i = s0; i &gt;= 0; i -= 2) {
            a[l ++] = s[i];
            st[i] = true;
        }  // sn 往右
        for (int i = sn; i &lt;= n; i += 2) {
            a[r --] = s[i];
            st[i] = true;
        }

        for (int i = 0; i &lt;= n; i++)
            if (!st[i])
                a[l ++] = s[i];

        for (int i = 1; i &lt;= n; i ++) {
            res = max(res, abs(a[i] - a[i - 1]));
        }

        printf(&quot;%lld\n&quot;, res);
    }

    return 0;
}
</code></pre>
<h1 id="数论">数论</h1>
<h2 id="最大公约数-辗转相除法">最大公约数-辗转相除法</h2>
<figure data-type="image" tabindex="172"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207202714414.png" alt="image-20230207202714414" loading="lazy"></figure>
<h3 id="gcd函数">gcd函数</h3>
<pre><code class="language-c++">int gcd(int a, int b) {
    // 求最大公约数
    // 如果b != 0， 则等价于求(b, a % b)的最大公约数
    // 如果b == 0， 则最大公约数为a
    return b ? gcd(b, a % b) : a;
}
</code></pre>
<h3 id="例题-1246-等差数列">例题 1246. 等差数列</h3>
<p><a href="https://www.acwing.com/problem/content/1248/">1246. 等差数列</a></p>
<p>数学老师给小明出了一道等差数列求和的题目。</p>
<p>但是粗心的小明忘记了一部分的数列，只记得其中 N 个整数。</p>
<p>现在给出这 N 个整数，小明想知道包含这 N 个整数的最短的等差数列有几项？</p>
<h4 id="输入格式-31">输入格式</h4>
<p>输入的第一行包含一个整数 N。</p>
<p>第二行包含 N 个整数 A1,A2,⋅⋅⋅,AN。(注意 A1∼AN 并不一定是按等差数<br>
列中的顺序给出)</p>
<h4 id="输出格式-31">输出格式</h4>
<p>输出一个整数表示答案。</p>
<h4 id="数据范围-31">数据范围</h4>
<p>2≤N≤100000,<br>
0≤Ai≤10^9</p>
<h4 id="输入样例-22">输入样例：</h4>
<pre><code>5
2 6 4 10 20
</code></pre>
<h4 id="输出样例-22">输出样例：</h4>
<pre><code>10
</code></pre>
<h4 id="样例解释-7">样例解释</h4>
<p>包含 2、6、4、10、20 的最短的等差数列是 2、4、6、8、10、12、14、16、18、20。</p>
<figure data-type="image" tabindex="173"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207204205206.png" alt="image-20230207204205206" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;

const int N = 100010;

int n;
int a[N], d[N];

int gcd(int a, int b) {
    // 求最大公约数
    // 如果b != 0， 则等价于求(b, a % b)的最大公约数
    // 如果b == 0， 则最大公约数为a
    return b ? gcd(b, a % b) : a;
}

int main() {
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;a[i]);
    sort(a, a + n);
    
    int gd;
    for (int i = 1; i &lt; n; i ++) gd = gcd(gd, a[i] - a[0]);


    // 如果公差为0， 则为常熟列，故长度为n
    if (gd != 0) printf(&quot;%d\n&quot;, ((a[n - 1] - a[0]) / gd) + 1);
    else printf(&quot;%d\n&quot;, n);
    
    return 0;
}
</code></pre>
<h2 id="最大公约数-辗转相减法">最大公约数-辗转相减法</h2>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo><mo>=</mo><mo>(</mo><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mo>−</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a, b) = (b, a - b)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></span></p>
<p>指数相减 = 两个数相除</p>
<pre><code class="language-c++">LL gcd_sub(LL a, LL b) {
    if (a &lt; b) swap(a,b);  //更相减损术总是大减小（它们的底数是一样的）
    if (b == 1) return a;
    return gcd_sub(b, a / b);
}
</code></pre>
<h3 id="习题-1223-最大比例">习题 1223. 最大比例</h3>
<p><a href="https://www.acwing.com/problem/content/1225/">1223. 最大比例</a></p>
<p>X星球的某个大奖赛设了 M 级奖励。</p>
<p>每个级别的奖金是一个正整数。</p>
<p>并且，相邻的两个级别间的比例是个固定值。</p>
<p>也就是说：所有级别的奖金数构成了一个等比数列。</p>
<p>比如：16,24,36,5416,24,36,54，其等比值为：3/23/2。</p>
<p>现在，我们随机调查了一些获奖者的奖金数。</p>
<p>请你据此推算可能的最大的等比值。</p>
<h4 id="输入格式-32">输入格式</h4>
<p>第一行为数字 N ，表示接下的一行包含 N 个正整数。</p>
<p>第二行 N 个正整数 Xi，用空格分开，每个整数表示调查到的某人的奖金数额。</p>
<h4 id="输出格式-32">输出格式</h4>
<p>一个形如 A/B 的分数，要求 A、B 互质，表示可能的最大比例系数。</p>
<h4 id="数据范围-32">数据范围</h4>
<p>0&lt;N&lt;100<br>
0&lt;Xi&lt;10^12<br>
数据保证一定有解。</p>
<h4 id="输入样例1-10">输入样例1：</h4>
<pre><code>3
1250 200 32
</code></pre>
<h4 id="输出样例1-10">输出样例1：</h4>
<pre><code>25/4
</code></pre>
<h4 id="输入样例2-10">输入样例2：</h4>
<pre><code>4
3125 32 32 200
</code></pre>
<h4 id="输出样例2-10">输出样例2：</h4>
<pre><code>5/2
</code></pre>
<h4 id="输入样例3-2">输入样例3：</h4>
<pre><code>3
549755813888 524288 2
</code></pre>
<h4 id="输出样例3-2">输出样例3：</h4>
<pre><code>4/1
</code></pre>
<figure data-type="image" tabindex="174"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230208145106117.png" alt="image-20230208145106117" loading="lazy"></figure>
<figure data-type="image" tabindex="175"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230208145646993.png" alt="image-20230208145646993" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

const int N = 110;

LL x[N], a[N], b[N];
int n, cnt;

LL gcd(LL a, LL b) {
    return b ? gcd(b, a % b) : a; 
}

LL gcd_sub(LL a, LL b) {
    if (a &lt; b) swap(a,b);  //更相减损术总是大减小（它们的底数是一样的）
    if (b == 1) return a;
    return gcd_sub(b, a / b);
}

int main() {
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 0; i &lt; n; i ++) scanf(&quot;%lld&quot;, &amp;x[i]);
    sort(x, x + n);

    for (int i = 1; i &lt; n; i ++) {
        if (x[i] != x[i - 1]) {  // 判重
            LL d = gcd(x[i], x[0]);  // x[i] / x[0]
            a[cnt] = x[i] / d;  // x[i] / d
            b[cnt] = x[0] / d;  // x[0] / d
            cnt ++;
        }
    }

    LL up = a[0], down = b[0];  // 初始化
    for (int i = 1; i &lt; cnt; i ++) {
        up = gcd_sub(up, a[i]);
        down = gcd_sub(down, b[i]);  // 两两求最大公约数
    }

    printf(&quot;%lld/%lld\n&quot;, up, down);

    return 0;
}
</code></pre>
<h2 id="算数基本定理">算数基本定理</h2>
<figure data-type="image" tabindex="176"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207210004353.png" alt="image-20230207210004353" loading="lazy"></figure>
<figure data-type="image" tabindex="177"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207211158309.png" alt="" loading="lazy"></figure>
<h2 id="线性筛质数法">线性筛质数法</h2>
<figure data-type="image" tabindex="178"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207211318536.png" alt="image-20230207211318536" loading="lazy"></figure>
<pre><code class="language-c++">int primes[N], cnt;  // primes 用来存素数， cnt 是素数的数量
bool st[N];  // st 数组用来判断是否被筛选过, 被筛过表示是某个数的倍数

void get_primes(int n) {  // 时间复杂度为O（n）
    for (int i = 2; i &lt;= n; i ++) {
        if (!st[i]) primes[cnt ++] = i;  // 如果没有被筛选过，则是素数并加入
        for (int j = 0; primes[j] * i &lt;= n; j ++) {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
</code></pre>
<h3 id="例题-1295-x的因子链">例题 1295. X的因子链</h3>
<p><a href="https://www.acwing.com/problem/content/1297/">1295. X的因子链</a></p>
<p>输入正整数 X，求 X的大于 11 的因子组成的满足任意前一项都能整除后一项的严格递增序列的最大长度，以及满足最大长度的序列的个数。</p>
<h4 id="输入格式-33">输入格式</h4>
<p>输入包含多组数据，每组数据占一行，包含一个正整数表示 X。</p>
<h4 id="输出格式-33">输出格式</h4>
<p>对于每组数据，输出序列的最大长度以及满足最大长度的序列的个数。</p>
<p>每个结果占一行。</p>
<h4 id="数据范围-33">数据范围</h4>
<p>1≤X≤2^20</p>
<h4 id="输入样例-23">输入样例：</h4>
<pre><code>2
3
4
10
100
</code></pre>
<h4 id="输出样例-23">输出样例：</h4>
<pre><code>1 1
1 1
2 1
2 2
4 6
</code></pre>
<figure data-type="image" tabindex="179"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207211158309.png" alt="image-20230207211158309" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;

typedef long long LL;

const int N = (1 &lt;&lt; 20) + 10;

int primes[N], cnt;  // primes 用来存素数， cnt 是素数的数量
int minp[N];
bool st[N];  // st 数组用来判断是否被筛选过, 被筛过表示是某个数的倍数

void get_primes(int n) {
    for (int i = 2; i &lt;= n; i ++) {
        if (!st[i]) {
            primes[cnt ++] = i;  // 如果没有被筛选过，则是素数并加入
            minp[i] = i;  // 素数的最小质因子是他本身
        }
        for (int j = 0; primes[j] * i &lt;= n; j ++) {
            // 从小到大枚举所有的质数，把这个质数的i倍筛掉
            st[primes[j] * i] = true;  // 筛掉的一定是合数
            minp[primes[j] * i] = primes[j];
            if (i % primes[j] == 0) break;  // 保证primes[j] 一定不大于 i 的最小质因子
        }
    }
}

int main() {
    // 首先将求出有哪些素数
    get_primes(N - 1);
    int x;
    int fact[30], sums[30];  // fact[] 数组存储不同的质因子, sums[i] 存储不用因子的个数
    while (scanf(&quot;%d&quot;, &amp;x) != -1) {
        int k = 0, total = 0;  // ， total 存储分解的总个数
        while (x &gt; 1) {
            int p = minp[x];  // p 为 x 的最小质因子
            fact[k] = p, sums[k] = 0;  // 找到第k个因子为p，初始化次数为0
            while (x % p == 0) {
                x /= p;
                sums[k] ++;
                total ++;
            }
            k ++;  // 开始计算下一个质因子
        }

        LL res = 1;
        for (int i = 1; i &lt;= total; i ++) res *= i;  
        for (int i = 0; i &lt; k; i ++) {
            for (int j = 1; j &lt;= sums[i]; j ++) {
                res /= j;
            }
        } 
        printf(&quot;%d %lld\n&quot;, total, res);
    }

    return 0;
}
</code></pre>
<h2 id="约数个数与约数和">约数个数与约数和</h2>
<figure data-type="image" tabindex="180"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207235607569.png" alt="image-20230207235607569" loading="lazy"></figure>
<h3 id="例题-1296-聪明的燕姿">例题 1296. 聪明的燕姿</h3>
<p><a href="https://www.acwing.com/problem/content/1298/">1296. 聪明的燕姿</a></p>
<p>城市中人们总是拿着号码牌，不停寻找，不断匹配，可是谁也不知道自己等的那个人是谁。</p>
<p>可是燕姿不一样，燕姿知道自己等的人是谁，因为燕姿数学学得好！</p>
<p>燕姿发现了一个神奇的算法：假设自己的号码牌上写着数字 S，那么自己等的人手上的号码牌数字的所有正约数之和必定等于 S。</p>
<p>所以燕姿总是拿着号码牌在地铁和人海找数字（喂！这样真的靠谱吗）。</p>
<p>可是她忙着唱《绿光》，想拜托你写一个程序能够快速地找到所有自己等的人。</p>
<h4 id="输入格式-34">输入格式</h4>
<p>输入包含 k 组数据。</p>
<p>对于每组数据，输入包含一个号码牌 S。</p>
<h4 id="输出格式-34">输出格式</h4>
<p>对于每组数据，输出有两行。</p>
<p>第一行包含一个整数 m，表示有 m 个等的人。</p>
<p>第二行包含相应的 m 个数，表示所有等的人的号码牌。</p>
<p>注意：你输出的号码牌必须按照升序排列。</p>
<h4 id="数据范围-34">数据范围</h4>
<p>1≤k≤100,<br>
1≤S≤2×10^9</p>
<h4 id="输入样例-24">输入样例：</h4>
<pre><code>42
</code></pre>
<h4 id="输出样例-24">输出样例：</h4>
<pre><code>3
20 26 41
</code></pre>
<figure data-type="image" tabindex="181"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230208001523174.png" alt="image-20230208001523174" loading="lazy"></figure>
<figure data-type="image" tabindex="182"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230208001859309.png" alt="image-20230208001859309" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 50010;

int primes[N], cnt;
int ans[N], len;
bool st[N];

void get_primes(int n) {
    for (int i = 2; i &lt;= n; i ++) {
        if (!st[i]) primes[cnt ++] = i;  // 如果没被筛过
        for (int j = 0; primes[j] * i &lt;= n; j ++) {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}

bool is_primes(int n) {
    if (n &lt; N) return !st[n];  // 如果没被筛选过 说明是质数
    for (int i = 0; primes[i] &lt;= n / primes[i]; i ++) {
        if (n % primes[i] == 0) return false;  // 用质数进行筛选
    }
    return true;
}

void dfs(int last, int prod, int s) {
    // last 表示上一个质数用的下标，prod 表示当前最高次的结果，s 表示每次处理后剩余多少
    if (s == 1) {
        // 表示如果s == 1， 则递归到了最后
        ans[len ++] = prod;  // 即将当前乘积放到最后一个中
        return ;
    }

    if (s - 1 &gt; ((last &lt; 0) ? 0 : primes[last]) &amp;&amp; is_primes(s - 1)) {
        // s - 1 需要大于上一个质数, 并且判断是否为质数
        ans[len ++] = prod * (s - 1);  // 如果为质数，则无法再分，直接加上答案
    }

    for (int i = last + 1; primes[i] &lt;= s / primes[i]; i ++) {
        int p = primes[i];
        for (int j = 1 + p, t = p; j &lt;= s; t *= p, j += t) {
            // 初始化 j = 1 + p, t = p
            // 更新 t =&gt; p * p, j =&gt; 1 + p + p * p
            if (s % j == 0) {
                dfs (i, prod * t, s / j);
            }
        }
    }
}

int main() {
    get_primes(N - 1);

    int s;
    while(scanf(&quot;%d&quot;, &amp;s) != -1) {
        len = 0;
        dfs(-1, 1, s);

        printf(&quot;%d\n&quot;, len);

        sort(ans, ans + len);
        if (len) {
            for (int i = 0; i &lt; len; i ++) printf(&quot;%d &quot;, ans[i]);
        printf(&quot;\n&quot;);
        }
    }

    return 0;
}
</code></pre>
<h2 id="裴蜀定理-扩展欧几里得定理">裴蜀定理-扩展欧几里得定理</h2>
<figure data-type="image" tabindex="183"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230208133324852.png" alt="image-20230208133324852" loading="lazy"></figure>
<figure data-type="image" tabindex="184"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230208134013644.png" alt="image-20230208134013644" loading="lazy"></figure>
<figure data-type="image" tabindex="185"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230208134200366.png" alt="image-20230208134200366" loading="lazy"></figure>
<figure data-type="image" tabindex="186"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230208134341439.png" alt="image-20230208134341439" loading="lazy"></figure>
<h3 id="例题-1299-五指山">例题 1299. 五指山</h3>
<p><a href="https://www.acwing.com/problem/content/1301/">1299. 五指山</a></p>
<p>大圣在佛祖的手掌中。</p>
<p>我们假设佛祖的手掌是一个圆圈，圆圈的长为 n，逆时针记为：0,1,2,…,n−1，而大圣每次飞的距离为 d。</p>
<p>现在大圣所在的位置记为 x，而大圣想去的地方在 y。</p>
<p>要你告诉大圣至少要飞多少次才能到达目的地。</p>
<p><strong>注意</strong>：孙悟空的筋斗云只沿着逆时针方向翻。</p>
<h4 id="输入格式-35">输入格式</h4>
<p>有多组测试数据。</p>
<p>第一行是一个正整数 T，表示测试数据的组数；</p>
<p>每组测试数据包括一行，四个非负整数，分别为如来手掌圆圈的长度 n，筋斗所能飞的距离 d，大圣的初始位置 x 和大圣想去的地方 y。</p>
<h4 id="输出格式-35">输出格式</h4>
<p>对于每组测试数据，输出一行，给出大圣最少要翻多少个筋斗云才能到达目的地。</p>
<p>如果无论翻多少个筋斗云也不能到达，输出 Impossible。</p>
<h4 id="数据范围-35">数据范围</h4>
<p>1≤T≤5<br>
2&lt;n&lt;10^9<br>
0&lt;d&lt;n<br>
0≤x,y&lt;n</p>
<h4 id="输入样例-25">输入样例：</h4>
<pre><code>2
3 2 0 2
3 2 0 1
</code></pre>
<h4 id="输出样例-25">输出样例：</h4>
<pre><code>1
2
</code></pre>
<figure data-type="image" tabindex="187"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230208140512726.png" alt="image-20230208140512726" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

LL exgcd(LL a, LL b, LL &amp;x, LL &amp;y) {
    // ax+by=gcd(a,b)  //x, y为待求整数,返回值为gcd(a,b)
    if (!b) {
        // 当b == 0时，a和b的最大公约数为a.则x = 1
        x = 1, y = 0;
        return a;
    }
    // 当b != 0时，by+(a mod b)x = gcd(a,b)
    LL d = exgcd(b, a % b, y, x);
    // 上式化为by+(a - a/b * b)x = gcd(a,b)  -&gt;  ax+b(y - a/b * x) = gcd(a,b)
    // 由以上变换得：欧几里得定理每递归一次x不用变,y = y-a/b * x
    y -= a / b * x;
    return d;
}

int main() {
    int T;

    scanf(&quot;%d&quot;, &amp;T);
    while (T --) {
        LL n, d, x, y, a, b;
        scanf(&quot;%lld%lld%lld%lld&quot;, &amp;n, &amp;d, &amp;x, &amp;y);
        LL gcd = exgcd(n, d, a, b);  // exgcd 求 an + bd = gcd
        if ((y - x) % gcd != 0)  // 无解
            printf(&quot;Impossible\n&quot;);
        else {
            // 恢复原式子
            b *= (y - x) / gcd;
            n /= gcd;
            b = (b % n + n) % n;
            printf(&quot;%d\n&quot;, b);
        }
    }

    return 0;
}
</code></pre>
<h3 id="习题-1301-c-循环">习题 1301. C 循环</h3>
<p><a href="https://www.acwing.com/problem/content/1303/">1301. C 循环</a></p>
<p>对于 C 语言的循环语句，形如：</p>
<pre><code>for (variable = A; variable != B; variable += C)
  statement;
</code></pre>
<p>请问在 k 位存储系统中循环几次才会结束。</p>
<p>若在有限次内结束，则输出循环次数。否则输出死循环。</p>
<h4 id="输入格式-36">输入格式</h4>
<p>多组数据，每组数据一行四个整数 A,B,C,k</p>
<p>读入以 0 0 0 0 结束。</p>
<h4 id="输出格式-36">输出格式</h4>
<p>若在有限次内结束，则输出循环次数。</p>
<p>否则输出 FOREVER。</p>
<h4 id="数据范围-36">数据范围</h4>
<p>1≤k≤32<br>
0≤A,B,C&lt;2k</p>
<h4 id="输入样例-26">输入样例：</h4>
<pre><code>3 3 2 16
3 7 2 16
7 3 2 16
3 4 2 16
0 0 0 0
</code></pre>
<h4 id="输出样例-26">输出样例：</h4>
<pre><code>0
2
32766
FOREVER
</code></pre>
<figure data-type="image" tabindex="188"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230208152942586.png" alt="image-20230208152942586" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

const int N = 110;

LL a, b, c, k, x, y;

LL exgcd(LL a, LL b, LL &amp;x, LL &amp;y) {
    if (b == 0) {
        x = 1, y = 0;
        return a;
    }
    LL d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}

int main() {
    while (true) {
        scanf(&quot;%lld%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;c, &amp;k);
        if (a == 0 &amp;&amp; b == 0 &amp; c == 0 &amp; k == 0) break;
        LL t = 1ll &lt;&lt; k;
        LL d = exgcd(c, t, x, y);
        if ((b - a) % d) printf(&quot;FOREVER\n&quot;);
        else {
            x *= (b - a) / d;
            t /= d;
            printf(&quot;%lld\n&quot;, (x % t + t) % t);
        }
    }

    return 0;
}
</code></pre>
<h1 id="复杂dp">复杂DP</h1>
<h2 id="线性dp">线性DP</h2>
<h3 id="例题-1050-鸣人的影分身">例题 1050. 鸣人的影分身</h3>
<p><a href="https://www.acwing.com/problem/content/1052/">1050. 鸣人的影分身</a></p>
<p>在火影忍者的世界里，令敌人捉摸不透是非常关键的。</p>
<p>我们的主角漩涡鸣人所拥有的一个招数——多重影分身之术——就是一个很好的例子。</p>
<p>影分身是由鸣人身体的查克拉能量制造的，使用的查克拉越多，制造出的影分身越强。</p>
<p>针对不同的作战情况，鸣人可以选择制造出各种强度的影分身，有的用来佯攻，有的用来发起致命一击。</p>
<p>那么问题来了，假设鸣人的查克拉能量为 M，他影分身的个数最多为 N，那么制造影分身时有多少种不同的分配方法？</p>
<p><strong>注意</strong>：</p>
<ol>
<li>影分身可以分配0点能量。</li>
<li>分配方案不考虑顺序，例如：M=7,N=3，那么 (2,2,3)和 (2,3,2) 被视为同一种方案。</li>
</ol>
<h4 id="输入格式-37">输入格式</h4>
<p>第一行是测试数据的数目 t。</p>
<p>以下每行均包含二个整数 M 和 N，以空格分开。</p>
<h4 id="输出格式-37">输出格式</h4>
<p>对输入的每组数据 M 和 N，用一行输出分配的方法数。</p>
<h4 id="数据范围-37">数据范围</h4>
<p>0≤t≤20<br>
1≤M,N≤10</p>
<h4 id="输入样例-27">输入样例：</h4>
<pre><code>1
7 3
</code></pre>
<h4 id="输出样例-27">输出样例：</h4>
<pre><code>8
</code></pre>
<figure data-type="image" tabindex="189"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230208225414280.png" alt="image-20230208225414280" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 11;
int f[N][N];
int t, n, m;

int main() {
    scanf(&quot;%d&quot;, &amp;t);

    while (t --) {
        scanf(&quot;%d%d&quot;, &amp;m, &amp;n);

        f[0][0] = 1;
        for (int i = 0; i &lt;= m; i ++) {  // f[0][j] 是有意义的，表示取j个0
            for (int j = 1; j &lt;= n; j ++) {  // 由于f[0][0] 已经定义过，故j 从 1 开始
                f[i][j] = f[i][j - 1];
                if (i &gt;= j) f[i][j] += f[i - j][j];
            }
        }
        printf(&quot;%d\n&quot;, f[m][n]);
    }

    return 0;
}
</code></pre>
<h2 id="背包模型">背包模型</h2>
<h3 id="例题-1047-糖果">例题 1047. 糖果</h3>
<p><a href="https://www.acwing.com/problem/content/1049/">1047. 糖果</a></p>
<p>由于在维护世界和平的事务中做出巨大贡献，Dzx被赠予糖果公司2010年5月23日当天无限量糖果免费优惠券。</p>
<p>在这一天，Dzx可以从糖果公司的 N 件产品中任意选择若干件带回家享用。</p>
<p>糖果公司的 N 件产品每件都包含数量不同的糖果。</p>
<p>Dzx希望他选择的产品包含的糖果总数是 K 的整数倍，这样他才能平均地将糖果分给帮助他维护世界和平的伙伴们。</p>
<p>当然，在满足这一条件的基础上，糖果总数越多越好。</p>
<p>Dzx最多能带走多少糖果呢？</p>
<p>注意：Dzx只能将糖果公司的产品整件带走。</p>
<h4 id="输入格式-38">输入格式</h4>
<p>第一行包含两个整数 N和 K。</p>
<p>以下 N 行每行 1 个整数，表示糖果公司该件产品中包含的糖果数目，不超过 1000000。</p>
<h4 id="输出格式-38">输出格式</h4>
<p>符合要求的最多能达到的糖果总数，如果不能达到 K 的倍数这一要求，输出 0。</p>
<h4 id="数据范围-38">数据范围</h4>
<p>1≤N≤100,<br>
1≤K≤100,</p>
<h4 id="输入样例-28">输入样例：</h4>
<pre><code>5 7
1
2
3
4
5
</code></pre>
<h4 id="输出样例-28">输出样例：</h4>
<pre><code>14
</code></pre>
<h4 id="样例解释-8">样例解释</h4>
<p>Dzx的选择是2+3+4+5=14，这样糖果总数是7的倍数，并且是总数最多的选择。</p>
<figure data-type="image" tabindex="190"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230208233331083.png" alt="image-20230208233331083" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 110;

int f[N][N];
int n, k;

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);

    // 由于f[0][1],f[0][2] 均无意义，故需要先初始化
    memset(f, -0x3f, sizeof f);
    f[0][0] = 0;
    for (int i = 1; i &lt;= n; i ++) {
        int w;
        scanf(&quot;%d&quot;, &amp;w);
        for (int j = 0; j &lt; k; j ++) {
            f[i][j] = max(f[i - 1][j], f[i - 1][(j + k - w % k) % k] + w);
        }
    }
    printf(&quot;%d\n&quot;, f[n][0]);

    return 0;
}
</code></pre>
<h3 id="习题-1226-包子凑数">习题 1226. 包子凑数</h3>
<p><a href="https://www.acwing.com/problem/content/1228/">1226. 包子凑数</a></p>
<p>小明几乎每天早晨都会在一家包子铺吃早餐。</p>
<p>他发现这家包子铺有 N 种蒸笼，其中第 i 种蒸笼恰好能放 Ai 个包子。</p>
<p>每种蒸笼都有非常多笼，可以认为是无限笼。</p>
<p>每当有顾客想买 X 个包子，卖包子的大叔就会迅速选出若干笼包子来，使得这若干笼中恰好一共有 X 个包子。</p>
<p>比如一共有 3种蒸笼，分别能放 3、4和 5 个包子。</p>
<p>当顾客想买 11个包子时，大叔就会选 2 笼 3 个的再加 1笼 5 个的（也可能选出 1笼 3个的再加 2 笼 4个的）。</p>
<p>当然有时包子大叔无论如何也凑不出顾客想买的数量。</p>
<p>比如一共有 33种蒸笼，分别能放 4、5和 6个包子。</p>
<p>而顾客想买 7 个包子时，大叔就凑不出来了。</p>
<p>小明想知道一共有多少种数目是包子大叔凑不出来的。</p>
<h4 id="输入格式-39">输入格式</h4>
<p>第一行包含一个整数 N。</p>
<p>接下来 N 行，每行包含一个整数 Ai。</p>
<h4 id="输出格式-39">输出格式</h4>
<p>输出一个整数代表答案。</p>
<p>如果凑不出的数目有无限多个，输出INF。</p>
<h4 id="数据范围-39">数据范围</h4>
<p>1≤N≤100<br>
1≤Ai≤100</p>
<h4 id="输入样例1-11">输入样例1：</h4>
<pre><code>2
4
5
</code></pre>
<h4 id="输出样例1-11">输出样例1：</h4>
<pre><code>6
</code></pre>
<h4 id="输入样例2-11">输入样例2：</h4>
<pre><code>2
4
6
</code></pre>
<h4 id="输出样例2-11">输出样例2：</h4>
<pre><code>INF
</code></pre>
<h4 id="样例解释-9">样例解释</h4>
<p>对于样例1，凑不出的数目包括：1, 2, 3, 6, 7, 11。<br>
对于样例2，所有奇数都凑不出来，所以有无限多个。</p>
<figure data-type="image" tabindex="191"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230209190723768.png" alt="image-20230209190723768" loading="lazy"></figure>
<p>买不到的数目 + 完全背包</p>
<p>根据买不到的数目 可知，体积最大是100，因此不能凑出的最大的数是N = (99 - 1) * (100 - 1) - 1,即最大体积是N</p>
<ol>
<li>
<p>判断给定的所有数最大公约数是否是1，若不是则返回INF</p>
</li>
<li>
<p>若是</p>
<ul>
<li>
<p>状态表示	-</p>
<ul>
<li><code>f[i][j]</code> 表示：是否能从前i个物品中选,且能恰好能凑出体积是j</li>
</ul>
</li>
<li>
<p>状态计算</p>
<ul>
<li><code>f[i][j] = f[i - 1][j] || f[i - 1][j - v] || f[i - 1][j - 2v]...</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<figure data-type="image" tabindex="192"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230209191418490.png" alt="image-20230209191418490" loading="lazy"></figure>
<h4 id="二维代码">二维代码</h4>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 10010;

int n;
int a[110];  // 用来存储Ai
bool f[110][N];  // dp

int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}

int main() {
    scanf(&quot;%d&quot;, &amp;n);
    int d = 0;
    for (int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]);

    for (int i = 1; i &lt;= n; i ++) d = gcd(d, a[i]);

    if (d != 1) printf(&quot;INF&quot;);
    else {
        f[0][0] = true;
        for (int i = 1; i &lt;= n; i ++) {
            for (int j = 0; j &lt; N; j ++) {
                // f[i][j] 表示从前i个中选，凑出j
                f[i][j] = f[i - 1][j];
                if (j &gt;= a[i]) f[i][j] |= f[i][j - a[i]];
            }
        }
        int res = 0;
        for (int i = 0; i &lt; N; i ++) {
            if (!f[n][i]) res ++;
        }
        printf(&quot;%d\n&quot;, res);
    }
    return 0;
}
</code></pre>
<h4 id="优化后的一维代码">优化后的一维代码</h4>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 10010;

int n;
int a[110];  // 用来存储Ai
bool f[N];  // dp

int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}

int main() {
    scanf(&quot;%d&quot;, &amp;n);
    int d = 0;
    for (int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]);

    for (int i = 1; i &lt;= n; i ++) d = gcd(d, a[i]);

    if (d != 1) printf(&quot;INF&quot;);
    else {
        f[0] = true;
        for (int i = 1; i &lt;= n; i ++) {
            for (int j = 0; j &lt; N; j ++) {
                f[j] |= f[j - a[i]];
            }
        }
        int res = 0;
        for (int i = 0; i &lt; N; i ++) {
            if (!f[i]) res ++;
        }
        printf(&quot;%d\n&quot;, res);
    }
    return 0;
}
</code></pre>
<h2 id="区间dp">区间DP</h2>
<h3 id="例题-1222-密码脱落">例题 1222. 密码脱落</h3>
<p><a href="https://www.acwing.com/problem/content/1224/">1222. 密码脱落</a></p>
<figure data-type="image" tabindex="193"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230209142156000.png" alt="image-20230209142156000" loading="lazy"></figure>
<p>从当前样子变成初始状态需要添加叶子的数量 <strong>等价于</strong> 当前样子变成最大的回文串需要剪去的叶子的数量<br>
即至少脱落多少个种子 等价于 <strong>总数量 - 最大回文子序列的长度</strong></p>
<figure data-type="image" tabindex="194"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230209144325271.png" alt="image-20230209144325271" loading="lazy"></figure>
<figure data-type="image" tabindex="195"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230209150654672.png" alt="image-20230209150654672" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &quot;string.h&quot;

using namespace std;

const int N = 1010;

char s[N];
int f[N][N];

int main() {
    scanf(&quot;%s&quot;, s);
    int n = strlen(s);

    // 对于区间dp来说，通常以区间长度进行循环
    for (int len = 1; len &lt;= n; len ++) {
        for (int l = 0; l + len - 1 &lt; n; l ++) {
            // 从区间左端点进行枚举，然后计算右
            int r = l + len - 1;
            if (len == 1) f[l][r] = 1;
            else {
                if (s[l] == s[r]) f[l][r] = f[l + 1][r - 1] + 2;
                if (f[l][r - 1] &gt; f[l][r]) f[l][r] = f[l][r - 1];
                if (f[l + 1][r] &gt; f[l][r]) f[l][r] = f[l + 1][r];
            }
        }
    }
    printf(&quot;%d\n&quot;, n - f[0][n - 1]);

    return 0;
}
</code></pre>
<h3 id="习题-1070-括号配对">习题 1070. 括号配对</h3>
<p><a href="https://www.acwing.com/problem/content/1072/">1070. 括号配对</a></p>
<p>Hecy 又接了个新任务：BE 处理。</p>
<p>BE 中有一类被称为 GBE。</p>
<p>以下是 GBE 的定义：</p>
<ul>
<li>空表达式是 GBE</li>
<li>如果表达式 A 是 GBE，则 [A] 与 (A) 都是 GBE</li>
<li>如果 A 与 B 都是 GBE，那么 AB 是 GBE</li>
</ul>
<p>下面给出一个 BE，求至少添加多少字符能使这个 BE 成为 GBE。</p>
<p>注意：BE 是一个仅由<code>(</code>、<code>)</code>、<code>[</code>、<code>]</code>四种字符中的若干种构成的字符串。</p>
<h4 id="输入格式-40">输入格式</h4>
<p>输入仅一行，为字符串 BE。</p>
<h4 id="输出格式-40">输出格式</h4>
<p>输出仅一个整数，表示增加的最少字符数。</p>
<h4 id="数据范围-40">数据范围</h4>
<p>对于所有输入字符串，其长度小于100。</p>
<h4 id="输入样例-29">输入样例：</h4>
<pre><code>[])
</code></pre>
<h4 id="输出样例-29">输出样例：</h4>
<pre><code>1
</code></pre>
<figure data-type="image" tabindex="196"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230209205347534.png" alt="image-20230209205347534" loading="lazy"></figure>
<h4 id="代码实现">代码实现</h4>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 110, INF = 10000000;

int f[N][N];

bool is_match(char l, char r) {
    if (l == '(' &amp;&amp; r == ')') return true;
    if (l == '[' &amp;&amp; r == ']') return true;
    return false;
}

int main() {
    string s;
    cin &gt;&gt; s;
    int n = s.size();

    for (int len = 1; len &lt;= n; len ++) {
        for (int l = 0; l + len - 1 &lt; n; l ++) {
            int r = l + len - 1;
            f[l][r] = INF;
            if (is_match(s[l], s[r])) f[l][r] = f[l + 1][r - 1];  // 左右匹配，表示不需要加字符
            f[l][r] = min(f[l][r], min(f[l + 1][r], f[l][r - 1]) + 1);

            for (int k = l; k &lt; r; k ++) {
                f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r]);
            }
        }
    }
    printf(&quot;%d\n&quot;, f[0][n - 1]);

    return 0;
}
</code></pre>
<h2 id="树形dp">树形DP</h2>
<h3 id="例题-1220-生命之树">例题 1220. 生命之树</h3>
<p><a href="https://www.acwing.com/problem/content/1222/">1220. 生命之树</a></p>
<p>在X森林里，上帝创建了生命之树。</p>
<p>他给每棵树的每个节点（叶子也称为一个节点）上，都标了一个整数，代表这个点的和谐值。</p>
<p>上帝要在这棵树内选出一个非空节点集 S，使得对于 S 中的任意两个点 a,b，都存在一个点列 {a,v1,v2,…,vk,b} 使得这个点列中的每个点都是 S 里面的元素，且序列中相邻两个点间有一条边相连。</p>
<p>在这个前提下，上帝要使得 S 中的点所对应的整数的和尽量大。</p>
<p>这个最大的和就是上帝给生命之树的评分。</p>
<p>经过 atm 的努力，他已经知道了上帝给每棵树上每个节点上的整数。</p>
<p>但是由于 atm 不擅长计算，他不知道怎样有效的求评分。</p>
<p>他需要你为他写一个程序来计算一棵树的分数。</p>
<h4 id="输入格式-41">输入格式</h4>
<p>第一行一个整数 n 表示这棵树有 n 个节点。</p>
<p>第二行 n 个整数，依次表示每个节点的评分。</p>
<p>接下来 n−1，每行 2 个整数 u,v，表示存在一条 u到 v的边。</p>
<p>由于这是一棵树，所以是不存在环的。</p>
<p>树的节点编号从 1到 n。</p>
<h4 id="输出格式-41">输出格式</h4>
<p>输出一行一个数，表示上帝给这棵树的分数。</p>
<h4 id="数据范围-41">数据范围</h4>
<p>1≤n≤10^5<br>
每个节点的评分的绝对值均不超过 10^6。</p>
<h4 id="输入样例-30">输入样例：</h4>
<pre><code>5
1 -2 -3 4 5
4 2
3 1
1 2
2 5
</code></pre>
<h4 id="输出样例-30">输出样例：</h4>
<pre><code>8
</code></pre>
<p>一般使用f[u]表示树形dp</p>
<ul>
<li>本题中,f[u]表示的是以u为根节点的连通块的sum的最大值</li>
<li>f[u]=w[u]+max(子树的情况，0)</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

const int N = 100010, M = 2 * N;

int n;
int w[N];
int h[N], e[M], ne[M], idx;
LL f[N];

void add(int a, int b) {
    // 数组实现邻接表来存储图
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

void dfs(int u, int father) {
    // u 表示当前节点，father 表示上一个节点
    f[u] = w[u];  // f[u]=w[u]+max(子树的情况，0)
    for (int i = h[u]; i != -1; i = ne[i]) {
        //  以u为头节点，遍历其
        int j = e[i];
        if (j != father) {
            dfs(j, u);  // 继续遍历
            f[u] += max(0ll, f[j]);  // 如果&lt;=0, 则没必要加上
        }
    }
}

int main() {
    scanf(&quot;%d&quot;, &amp;n);
    memset(h, -1, sizeof h);// 记得h数组置-1

    for (int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;w[i]);

    for (int i = 0; i &lt; n - 1; i ++) {
        int a, b;
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        add(a, b);
        add(b, a);
    }

    dfs(1, -1);

    LL res = 0;
    for (int i = 1; i &lt;= n; i ++) res = max(res, f[i]);
    printf(&quot;%lld\n&quot;, res);

    return 0;
}
</code></pre>
<h3 id="习题-1078-旅游规划">习题 1078. 旅游规划</h3>
<p><a href="https://www.acwing.com/problem/content/1080/">1078. 旅游规划</a></p>
<p>W 市的交通规划出现了重大问题，市政府下定决心在全市各大交通路口安排疏导员来疏导密集的车流。</p>
<p>但由于人员不足，W 市市长决定只在最需要安排人员的路口安排人员。</p>
<p>具体来说，W 市的交通网络十分简单，由 n 个交叉路口和 n−1 条街道构成，交叉路口路口编号依次为 0,1,…,n−1 。</p>
<p>任意一条街道连接两个交叉路口，且任意两个交叉路口间都存在一条路径互相连接。</p>
<p>经过长期调查，结果显示，如果一个交叉路口位于 W 市交通网最长路径上，那么这个路口必定拥挤不堪。</p>
<p>所谓最长路径，定义为某条路径 p=(v1,v2,…,vk)，路径经过的路口各不相同，且城市中不存在长度大于 k 的路径（因此最长路径可能不唯一）。</p>
<p>因此 W 市市长想知道哪些路口位于城市交通网的最长路径上。</p>
<h4 id="输入格式-42">输入格式</h4>
<p>第一行包含一个整数 n。</p>
<p>之后 n−1行每行两个整数 u,v，表示编号为 u 和 v 的路口间存在着一条街道。</p>
<h4 id="输出格式-42">输出格式</h4>
<p>输出包括若干行，每行包括一个整数——某个位于最长路径上的路口编号。</p>
<p>为了确保解唯一，请将所有最长路径上的路口编号按编号顺序由小到大依次输出。</p>
<h4 id="数据范围-42">数据范围</h4>
<p>1≤n≤2×10^5</p>
<h4 id="输入样例-31">输入样例：</h4>
<pre><code>10
0 1
0 2
0 4
0 6
0 7
1 3
2 5
4 8
6 9
</code></pre>
<h4 id="输出样例-31">输出样例：</h4>
<pre><code>0
1
2
3
4
5
6
8
9
</code></pre>
<figure data-type="image" tabindex="197"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230209225007447.png" alt="image-20230209225007447" loading="lazy"></figure>
<figure data-type="image" tabindex="198"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230209234928728.png" alt="image-20230209234928728" loading="lazy"></figure>
<img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230209235109290.png" alt="image-20230209235109290" style="zoom:50%;" />
<figure data-type="image" tabindex="199"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230209235205019.png" alt="image-20230209235205019" loading="lazy"></figure>
<h4 id="代码实现-2">代码实现</h4>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 200010, M = N * 2;

int n;
int h[N], e[M], ne[M], idx;
int d1[N], d2[N], p1[N], up[N];
int maxd;  // 直径

void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

void dfs_d(int u, int father) {
    for (int i = h[u]; ~i; i = ne[i]) {
        int j = e[i];
        if (j != father) {
            dfs_d(j, u);
            int distance = d1[j] + 1;
            if (distance &gt; d1[u]) {
                d2[u] = d1[u], d1[u] = distance;  // 更新最大值和次大值
                p1[u] = j;
            } else if (distance &gt; d2[u]) {
                d2[u] = distance;  // 更新次大值
            }
        }
    }
    maxd = max(maxd, d1[u] + d2[u]);
}

void dfs_u(int u, int father) {
    for (int i = h[u]; ~i; i = ne[i]) {
        int j = e[i];
        if (j != father) {
            up[j] = up[u] + 1;
            if (p1[u] == j) {
                up[j] = max(up[j], d2[u] + 1);
            } else {
                up[j] = max(up[j], d1[u] + 1);
            }
            dfs_u(j, u);
        }
    }
}

int main() {
    scanf(&quot;%d&quot;, &amp;n);
    memset(h, -1, sizeof h);  

    for (int i = 0; i &lt; n; i ++) {
        int a, b;
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        add(a, b), add(b, a);
    }

    dfs_d(0, -1);
    dfs_u(0, -1);

    for (int i = 0; i &lt; n; i ++) {
        int d[3] = {d1[i], d2[i], up[i]};
        sort(d, d + 3);
        if (d[1] + d[2] == maxd) printf(&quot;%d\n&quot;, i);  // 如果最大的等于直径，则输出
    }

    return 0;
}
</code></pre>
<h2 id="矩阵快速幂">矩阵快速幂</h2>
<figure data-type="image" tabindex="200"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230209160940486.png" alt="image-20230209160940486" loading="lazy"></figure>
<h3 id="例题-1303-斐波那契前-n-项和">例题 1303. 斐波那契前 n 项和</h3>
<p><a href="https://www.acwing.com/problem/content/1305/">1303. 斐波那契前 n 项和</a></p>
<figure data-type="image" tabindex="201"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230209154925248.png" alt="image-20230209154925248" loading="lazy"></figure>
<figure data-type="image" tabindex="202"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230209160940486.png" alt="image-20230209160940486" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

const int N = 3;

int n, m;

void mul(int c[], int a[], int b[][N]) {
    int tmp[N] = {0};
    for (int i = 0; i &lt; N; i ++) {
        for (int j = 0; j &lt; N; j ++) {
            tmp[i] = (tmp[i] + (LL)a[j] * b[j][i]) % m;
        }
    }

    memcpy(c, tmp, sizeof tmp);
}

void mul(int c[][N], int a[][N], int b[][N]) {
    int tmp[N][N] = {0};
    for (int i = 0; i &lt; N; i ++) {
        for (int j = 0; j &lt; N; j ++) {
            for (int k = 0; k &lt; N; k ++) {
                tmp[i][j] = (tmp[i][j] + (LL)a[i][k] * b[k][j]) % m;
            }
        }
    }
    memcpy(c, tmp, sizeof tmp);
}

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);

    int f1[N] = {1, 1, 1};  // {f1, f2, s1}
    int a[N][N] = {
        {0, 1, 0},
        {1, 1, 1},
        {0, 0, 1}
    };

    n --;  // f1*A^(n - 1) = fn
    for (int i = n; i; i &gt;&gt;= 1) {
        if (i &amp; 1) mul(f1, f1, a);   // res = res * a
        mul(a, a, a);
    }
    printf(&quot;%d\n&quot;, f1[2]);
    return 0;
}
</code></pre>
<h3 id="习题-1217-垒骰子">习题 1217. 垒骰子</h3>
<p><a href="https://www.acwing.com/problem/content/description/1219/">1217. 垒骰子</a></p>
<p>赌圣atm晚年迷恋上了垒骰子，就是把骰子一个垒在另一个上边，不能歪歪扭扭，要垒成方柱体。</p>
<p>经过长期观察，atm 发现了稳定骰子的奥秘：有些数字的面贴着会互相排斥！</p>
<p>我们先来规范一下骰子：1 的对面是 4，2 的对面是 5，3 的对面是 6。</p>
<p>假设有 m 组互斥现象，每组中的那两个数字的面紧贴在一起，骰子就不能稳定的垒起来。</p>
<p>atm想计算一下有多少种不同的可能的垒骰子方式。</p>
<p>两种垒骰子方式相同，当且仅当这两种方式中对应高度的骰子的对应数字的朝向都相同。</p>
<p>由于方案数可能过多，请输出模 10^9+7的结果。</p>
<h4 id="输入格式-43">输入格式</h4>
<p>第一行包含两个整数 n,m，分别表示骰子的数目和排斥的组数。</p>
<p>接下来 m 行，每行两个整数 a,b，表示 a 和 b 数字不能紧贴在一起。</p>
<h4 id="输出格式-43">输出格式</h4>
<p>共一个数，表示答案模 109+7109+7 的结果。</p>
<h4 id="数据范围-43">数据范围</h4>
<p>1≤n≤10^9,<br>
1≤m≤36<br>
1≤a,b≤6</p>
<h4 id="输入样例-32">输入样例：</h4>
<pre><code>2 1
1 2
</code></pre>
<h4 id="输出样例-32">输出样例：</h4>
<pre><code>544
</code></pre>
<figure data-type="image" tabindex="203"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230210003118369.png" alt="image-20230210003118369" loading="lazy"></figure>
<figure data-type="image" tabindex="204"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230210003325577.png" alt="image-20230210003325577" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

const int N = 6, MOD = 1e9 + 7;

int n, m;

int get_op(int x) {
    if (x &gt;= 3) return x -= 3;  // 4 - 1, 5 - 2, 6 - 3, 且坐标从0开始
    else return x += 3;
}

void mul(int c[][N], int a[][N], int b[][N]) {
    int tmp[N][N];
    memset(tmp, 0, sizeof tmp);
    for (int i = 0; i &lt; N; i ++) {
        for (int j = 0; j &lt; N; j ++) {
            for (int k = 0; k &lt; N; k ++) {
                tmp[i][j] = (tmp[i][j] + (LL)a[i][k] * b[k][j]) % MOD;
            }
        }
    }
    memcpy(c, tmp, sizeof tmp);
}

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);

    int a[N][N];
    // A 矩阵初始化
    for (int i = 0; i &lt; N; i ++) {
        for (int j = 0; j &lt; N; j ++) {
            a[i][j] = 4;
        }
    }
    while (m --) {
        // 对立面空集
        int x, y;
        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
        x --, y --;  // 下标从0开始
        a[x][get_op(y)] = 0;
        a[y][get_op(x)] = 0;
    }

    int f1[N][N] = {4, 4, 4, 4, 4, 4};  // F1 
    for (int k = n - 1; k; k &gt;&gt;= 1) {
        if (k &amp; 1) mul(f1, f1, a);  // F = F * A
        mul(a, a, a);  // A = A * A
    }

    int res = 0;
    for (int i = 0; i &lt; N; i ++) {
        res = (res + f1[0][i]) % MOD;
    }
    printf(&quot;%d\n&quot;, res);

    return 0;
}
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E9%80%92%E5%BD%92%E4%B8%8E%E9%80%92%E6%8E%A8">递归与递推</a>
<ul>
<li><a href="#%E9%80%92%E5%BD%92">递归</a>
<ul>
<li><a href="#%E4%BE%8B%E9%A2%98-92-%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8C%87%E6%95%B0%E5%9E%8B%E6%9E%9A%E4%B8%BE">例题 92. 递归实现指数型枚举</a></li>
<li><a href="#%E4%BE%8B%E9%A2%98-94-%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%88%97%E5%9E%8B%E6%9E%9A%E4%B8%BE">例题 94. 递归实现排列型枚举</a></li>
<li><a href="#%E4%B9%A0%E9%A2%98-93-%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E7%BB%84%E5%90%88%E5%9E%8B%E6%9E%9A%E4%B8%BE">习题 93. 递归实现组合型枚举</a></li>
<li><a href="#%E4%B9%A0%E9%A2%98-1209-%E5%B8%A6%E5%88%86%E6%95%B0">习题 1209. 带分数</a></li>
<li><a href="#%E4%B9%A0%E9%A2%98-1225-%E6%AD%A3%E5%88%99%E9%97%AE%E9%A2%98">习题 1225. 正则问题</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B">输入样例：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B">输出样例：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%80%92%E6%8E%A8">递推</a>
<ul>
<li><a href="#%E4%BE%8B%E9%A2%98-717-%E7%AE%80%E5%8D%95%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91">例题 717. 简单斐波那契</a></li>
<li><a href="#%E4%BE%8B%E9%A2%98-95-%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3">例题 95. 费解的开关</a>
<ul>
<li><a href="#%E6%80%9D%E8%B7%AF%E5%BD%93%E7%AC%AC%E4%B8%80%E8%A1%8C%E7%A1%AE%E5%AE%9A%E4%B9%8B%E5%90%8E%E6%8E%A5%E4%B8%8B%E6%9D%A5%E7%9A%84%E6%93%8D%E4%BD%9C%E9%83%BD%E5%94%AF%E4%B8%80%E7%A1%AE%E5%AE%9A">思路：当第一行确定之后，接下来的操作都唯一确定</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%85%B3%E9%94%AE%E7%82%B9">代码关键点</a></li>
</ul>
</li>
<li><a href="#%E4%B9%A0%E9%A2%98-116-%E9%A3%9E%E8%A1%8C%E5%91%98%E5%85%84%E5%BC%9F">习题 116. 飞行员兄弟</a>
<ul>
<li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li>
</ul>
</li>
<li><a href="#%E4%B9%A0%E9%A2%98-1208-%E7%BF%BB%E7%A1%AC%E5%B8%81">习题 1208. 翻硬币</a>
<ul>
<li><a href="#%E6%80%9D%E8%B7%AF-2">思路</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E5%88%86%E4%B8%8E%E5%89%8D%E7%BC%80%E5%92%8C">二分与前缀和</a>
<ul>
<li><a href="#%E4%BA%8C%E5%88%86">二分</a>
<ul>
<li><a href="#%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86%E7%9A%84%E6%A8%A1%E6%9D%BF">整数二分的模板</a>
<ul>
<li><a href="#%E7%AC%AC%E4%B8%80%E7%B1%BB%E7%9B%AE%E6%A0%87%E5%80%BC%E4%B8%BA%E5%B7%A6%E4%BE%A7%E5%8C%BA%E9%97%B4%E7%9A%84%E5%8F%B3%E7%AB%AF%E7%82%B9%E8%90%BD%E5%9C%A8%E5%B7%A6%E4%BE%A7">第一类：目标值为左侧区间的右端点（落在左侧）</a></li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E7%B1%BB%E7%9B%AE%E6%A0%87%E5%80%BC%E4%B8%BA%E5%8F%B3%E4%BE%A7%E5%8C%BA%E9%97%B4%E7%9A%84%E5%B7%A6%E7%AB%AF%E7%82%B9%E8%90%BD%E5%9C%A8%E5%8F%B3%E4%BE%A7">第二类：目标值为右侧区间的左端点（落在右侧）</a></li>
</ul>
</li>
<li><a href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E4%BA%8C%E5%88%86%E7%9A%84%E6%A8%A1%E6%9D%BF">浮点数二分的模板</a></li>
<li><a href="#%E4%BE%8B%E9%A2%98-789-%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4">例题 789. 数的范围</a>
<ul>
<li><a href="#%E6%80%9D%E8%B7%AF-3">思路</a></li>
</ul>
</li>
<li><a href="#%E4%BE%8B%E9%A2%98-790-%E6%95%B0%E7%9A%84%E4%B8%89%E6%AC%A1%E6%96%B9%E6%A0%B9">例题 790. 数的三次方根</a></li>
<li><a href="#%E4%B9%A0%E9%A2%98-730-%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%B7%B3%E8%B7%83%E9%97%AE%E9%A2%98">习题 730. 机器人跳跃问题</a></li>
<li><a href="#%E4%B9%A0%E9%A2%98-1221-%E5%9B%9B%E5%B9%B3%E6%96%B9%E5%92%8C">习题 1221. 四平方和</a></li>
<li><a href="#%E4%B9%A0%E9%A2%98-1227-%E5%88%86%E5%B7%A7%E5%85%8B%E5%8A%9B">习题 1227. 分巧克力</a></li>
</ul>
</li>
<li><a href="#%E5%89%8D%E7%BC%80%E5%92%8C">前缀和</a>
<ul>
<li><a href="#%E4%B8%80%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C">一维前缀和</a></li>
<li><a href="#%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C">二维前缀和</a></li>
<li><a href="#%E4%BE%8B%E9%A2%98-795-%E5%89%8D%E7%BC%80%E5%92%8C">例题 795. 前缀和</a></li>
<li><a href="#%E4%BE%8B%E9%A2%98-796-%E5%AD%90%E7%9F%A9%E9%98%B5%E7%9A%84%E5%92%8C">例题 796. 子矩阵的和</a></li>
<li><a href="#%E4%B9%A0%E9%A2%98-99-%E6%BF%80%E5%85%89%E7%82%B8%E5%BC%B9">习题 99. 激光炸弹</a></li>
<li><a href="#%E4%B9%A0%E9%A2%98-1230-k%E5%80%8D%E5%8C%BA%E9%97%B4">习题 1230. K倍区间</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%95%B0%E5%AD%A6%E4%B8%8E%E7%AE%80%E5%8D%95dp">数学与简单DP</a>
<ul>
<li><a href="#%E6%95%B0%E5%AD%A6">数学</a>
<ul>
<li><a href="#%E4%BE%8B%E9%A2%98-1205-%E4%B9%B0%E4%B8%8D%E5%88%B0%E7%9A%84%E6%95%B0%E7%9B%AE">例题 1205. 买不到的数目</a></li>
<li><a href="#%E4%BE%8B%E9%A2%98-1211-%E8%9A%82%E8%9A%81%E6%84%9F%E5%86%92">例题 1211. 蚂蚁感冒</a></li>
<li><a href="#%E4%BE%8B%E9%A2%98-1216-%E9%A5%AE%E6%96%99%E6%8D%A2%E8%B4%AD">例题 1216. 饮料换购</a></li>
</ul>
</li>
<li><a href="#%E7%AE%80%E5%8D%95dp">简单DP</a>
<ul>
<li><a href="#01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98">01背包问题</a></li>
<li><a href="#%E4%BE%8B%E9%A2%98-2-01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98">例题 2. 01背包问题</a></li>
<li><a href="#%E4%BE%8B%E9%A2%98-1015-%E6%91%98%E8%8A%B1%E7%94%9F">例题 1015. 摘花生</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-2">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-2">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-2">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-2">输入样例：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-2">输出样例：</a></li>
</ul>
</li>
<li><a href="#%E4%BE%8B%E9%A2%98-895-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97">例题 895. 最长上升子序列</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-3">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-3">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-3">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-3">输入样例：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-3">输出样例：</a></li>
</ul>
</li>
<li><a href="#%E4%B9%A0%E9%A2%98-1212-%E5%9C%B0%E5%AE%AB%E5%8F%96%E5%AE%9D">习题 1212. 地宫取宝</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-4">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-4">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-4">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B1">输入样例1：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B1">输出样例1：</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B2">输入样例2：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B2">输出样例2：</a></li>
</ul>
</li>
<li><a href="#%E4%B9%A0%E9%A2%98-1214-%E6%B3%A2%E5%8A%A8%E6%95%B0%E5%88%97">习题 1214. 波动数列</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-5">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-5">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-5">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-4">输入样例：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-4">输出样例：</a></li>
<li><a href="#%E6%A0%B7%E4%BE%8B%E8%A7%A3%E9%87%8A">样例解释</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%9E%9A%E4%B8%BE-%E6%A8%A1%E6%8B%9F%E4%B8%8E%E6%8E%92%E5%BA%8F">枚举、模拟与排序</a>
<ul>
<li><a href="#%E6%9E%9A%E4%B8%BE">枚举</a>
<ul>
<li><a href="#%E4%BE%8B%E9%A2%98-1210-%E8%BF%9E%E5%8F%B7%E5%8C%BA%E9%97%B4%E6%95%B0">例题 1210. 连号区间数</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-6">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-6">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-6">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B1-2">输入样例1：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B1-2">输出样例1：</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B2-2">输入样例2：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B2-2">输出样例2：</a></li>
<li><a href="#%E6%A0%B7%E4%BE%8B%E8%A7%A3%E9%87%8A-2">样例解释</a></li>
</ul>
</li>
<li><a href="#%E4%BE%8B%E9%A2%98-1236-%E9%80%92%E5%A2%9E%E4%B8%89%E5%85%83%E7%BB%84">例题 1236. 递增三元组</a></li>
<li><a href="#%E4%BE%8B%E9%A2%98-1245-%E7%89%B9%E5%88%AB%E6%95%B0%E7%9A%84%E5%92%8C">例题 1245. 特别数的和</a></li>
<li><a href="#%E4%BE%8B%E9%A2%98-1204-%E9%94%99%E8%AF%AF%E7%A5%A8%E6%8D%AE">例题 1204. 错误票据</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-7">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-7">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-7">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-5">输入样例：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-5">输出样例：</a></li>
</ul>
</li>
<li><a href="#%E4%BE%8B%E9%A2%98-466-%E5%9B%9E%E6%96%87%E6%97%A5%E6%9C%9F">例题 466. 回文日期</a></li>
</ul>
</li>
<li><a href="#%E6%8E%92%E5%BA%8F">排序</a>
<ul>
<li><a href="#%E4%BE%8B%E9%A2%98-787-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">例题 787. 归并排序</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-8">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-8">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-8">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-6">输入样例：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-6">输出样例：</a></li>
</ul>
</li>
<li><a href="#%E4%B9%A0%E9%A2%98-1219-%E7%A7%BB%E5%8A%A8%E8%B7%9D%E7%A6%BB">习题 1219. 移动距离</a></li>
<li><a href="#%E4%B9%A0%E9%A2%98-1229-%E6%97%A5%E6%9C%9F%E9%97%AE%E9%A2%98">习题 1229. 日期问题</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-9">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-9">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-9">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-7">输入样例：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-7">输出样例：</a></li>
</ul>
</li>
<li><a href="#%E4%B9%A0%E9%A2%98-1231-%E8%88%AA%E7%8F%AD%E6%97%B6%E9%97%B4">习题 1231. 航班时间</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-10">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-10">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-10">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-8">输入样例：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-8">输出样例：</a></li>
</ul>
</li>
<li><a href="#%E4%B9%A0%E9%A2%98-1241-%E5%A4%96%E5%8D%96%E5%BA%97%E4%BC%98%E5%85%88%E7%BA%A7">习题 1241. 外卖店优先级</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-11">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-11">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-11">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-9">输入样例：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-9">输出样例：</a></li>
<li><a href="#%E6%A0%B7%E4%BE%8B%E8%A7%A3%E9%87%8A-3">样例解释</a></li>
</ul>
</li>
<li><a href="#%E4%B9%A0%E9%A2%98-788-%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E6%95%B0%E9%87%8F">习题 788. 逆序对的数量</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%B8%8E%E7%BA%BF%E6%AE%B5%E6%A0%91">树状数组与线段树</a>
<ul>
<li><a href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84">树状数组</a>
<ul>
<li><a href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0">树状数组核心函数</a>
<ul>
<li><a href="#lowbitint-x">lowbit(int x)</a></li>
<li><a href="#addint-x-int-v">add(int x, int v)</a></li>
<li><a href="#queryint-x">query(int x)</a></li>
</ul>
</li>
<li><a href="#%E4%BE%8B%E9%A2%98-1264-%E5%8A%A8%E6%80%81%E6%B1%82%E8%BF%9E%E7%BB%AD%E5%8C%BA%E9%97%B4%E5%92%8C">例题 1264. 动态求连续区间和</a></li>
<li><a href="#%E4%BE%8B%E9%A2%98-1265-%E6%95%B0%E6%98%9F%E6%98%9F">例题 1265. 数星星</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-12">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-12">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-12">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-10">输入样例：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-10">输出样例：</a></li>
</ul>
</li>
<li><a href="#%E4%B9%A0%E9%A2%98-1215-%E5%B0%8F%E6%9C%8B%E5%8F%8B%E6%8E%92%E9%98%9F">习题 1215. 小朋友排队</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-13">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-13">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-13">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-11">输入样例：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-11">输出样例：</a></li>
<li><a href="#%E6%A0%B7%E4%BE%8B%E8%A7%A3%E9%87%8A-4">样例解释</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%BA%BF%E6%AE%B5%E6%A0%91">线段树</a>
<ul>
<li><a href="#%E7%BA%BF%E6%AE%B5%E6%A0%91-%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C">线段树 核心操作</a>
<ul>
<li><a href="#%E5%8D%95%E7%82%B9%E4%BF%AE%E6%94%B9">单点修改</a></li>
<li><a href="#%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2">区间查询</a></li>
</ul>
</li>
<li><a href="#%E7%BA%BF%E6%AE%B5%E6%A0%91-%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0">线段树 核心函数</a>
<ul>
<li><a href="#pushup%E7%94%A8%E5%AD%90%E8%8A%82%E7%82%B9%E4%BF%A1%E6%81%AF%E6%9B%B4%E6%96%B0%E5%BD%93%E5%89%8D%E8%8A%82%E7%82%B9%E4%BF%A1%E6%81%AF">pushup：用子节点信息更新当前节点信息</a></li>
<li><a href="#build%E5%9C%A8%E4%B8%80%E6%AE%B5%E5%8C%BA%E9%97%B4%E4%B8%8A%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91">build：在一段区间上初始化线段树</a></li>
<li><a href="#modify%E4%BF%AE%E6%94%B9">modify：修改</a></li>
<li><a href="#query%E6%9F%A5%E8%AF%A2">query：查询</a></li>
</ul>
</li>
<li><a href="#%E4%BE%8B%E9%A2%98-1264-%E5%8A%A8%E6%80%81%E6%B1%82%E8%BF%9E%E7%BB%AD%E5%8C%BA%E9%97%B4%E5%92%8C-2">例题 1264. 动态求连续区间和</a></li>
<li><a href="#%E4%BE%8B%E9%A2%98-1270-%E6%95%B0%E5%88%97%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%80%BC">例题 1270. 数列区间最大值</a></li>
<li><a href="#%E4%B9%A0%E9%A2%98-1228-%E6%B2%B9%E6%BC%86%E9%9D%A2%E7%A7%AF">习题 1228. 油漆面积</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-14">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-14">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-14">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B1-3">输入样例1：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B1-3">输出样例1：</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B2-3">输入样例2：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B2-3">输出样例2：</a></li>
</ul>
</li>
<li><a href="#%E4%B9%A0%E9%A2%98-1232-%E4%B8%89%E4%BD%93%E6%94%BB%E5%87%BB">习题 1232. 三体攻击</a>
<ul>
<li><a href="#%E4%B8%89%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C">三维前缀和</a></li>
<li><a href="#%E4%B8%80%E7%BB%B4%E5%B7%AE%E5%88%86">一维差分</a></li>
<li><a href="#%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86">二维差分</a></li>
<li><a href="#%E4%B8%89%E7%BB%B4%E5%B7%AE%E5%88%86">三维差分</a></li>
</ul>
</li>
<li><a href="#%E4%B9%A0%E9%A2%98-1237-%E8%9E%BA%E6%97%8B%E6%8A%98%E7%BA%BF">习题 1237. 螺旋折线</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-15">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-15">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-15">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-12">输入样例：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-12">输出样例：</a></li>
<li><a href="#%E6%A8%A1%E6%8B%9F1">模拟1</a></li>
<li><a href="#%E6%A8%A1%E6%8B%9F2">模拟2</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%B7%AE%E5%88%86">差分</a>
<ul>
<li><a href="#%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C">核心操作</a>
<ul>
<li><a href="#%E4%B8%80%E7%BB%B4%E5%B7%AE%E5%88%86-2">一维差分</a></li>
<li><a href="#%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86-2">二维差分</a></li>
<li><a href="#%E4%B8%89%E7%BB%B4%E5%B7%AE%E5%88%86-2">三维差分</a></li>
</ul>
</li>
<li><a href="#%E4%BE%8B%E9%A2%98-797-%E5%B7%AE%E5%88%86">例题 797. 差分</a></li>
<li><a href="#%E4%BE%8B%E9%A2%98-798-%E5%B7%AE%E5%88%86%E7%9F%A9%E9%98%B5">例题 798. 差分矩阵</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%8F%8C%E6%8C%87%E9%92%88-bfs%E4%B8%8E%E5%9B%BE%E8%AE%BA">双指针、BFS与图论</a>
<ul>
<li><a href="#%E5%8F%8C%E6%8C%87%E9%92%88">双指针</a>
<ul>
<li><a href="#%E4%BE%8B%E9%A2%98-1238-%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1">例题 1238. 日志统计</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-16">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-16">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-16">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-13">输入样例：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-13">输出样例：</a></li>
<li><a href="#%E6%9A%B4%E5%8A%9B%E5%81%9A%E6%B3%95">暴力做法</a></li>
<li><a href="#%E5%8F%8C%E6%8C%87%E9%92%88%E4%BC%98%E5%8C%96">双指针优化</a></li>
</ul>
</li>
<li><a href="#%E4%B9%A0%E9%A2%98-1240-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9D%83%E5%80%BC">习题 1240. 完全二叉树的权值</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-17">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-17">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-17">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-14">输入样例：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-14">输出样例：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#bfs">BFS</a>
<ul>
<li><a href="#bfs-%E4%B8%80%E8%88%AC%E6%A1%86%E6%9E%B6">BFS 一般框架</a></li>
<li><a href="#%E4%BE%8B%E9%A2%98-1101-%E7%8C%AE%E7%BB%99%E9%98%BF%E5%B0%94%E5%90%89%E4%BE%AC%E7%9A%84%E8%8A%B1%E6%9D%9F">例题 1101. 献给阿尔吉侬的花束</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-18">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-18">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-18">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-15">输入样例：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-15">输出样例：</a></li>
</ul>
</li>
<li><a href="#%E4%B9%A0%E9%A2%98-1096-%E5%9C%B0%E7%89%A2%E5%A4%A7%E5%B8%88">习题 1096. 地牢大师</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-19">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-19">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-19">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-16">输入样例：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-16">输出样例：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#flood-fill">Flood Fill</a>
<ul>
<li><a href="#%E4%BE%8B%E9%A2%98-1113-%E7%BA%A2%E4%B8%8E%E9%BB%91">例题 1113. 红与黑</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-20">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-20">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-20">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-17">输入样例：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-17">输出样例：</a></li>
</ul>
</li>
<li><a href="#%E4%B9%A0%E9%A2%98-1233-%E5%85%A8%E7%90%83%E5%8F%98%E6%9A%96">习题 1233. 全球变暖</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-21">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-21">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-21">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B1-4">输入样例1：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B1-4">输出样例1：</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B2-4">输入样例2：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B2-4">输出样例2：</a></li>
<li><a href="#%E6%89%BE%E5%88%B0%E6%9C%89%E5%A4%9A%E5%B0%91%E8%BF%9E%E9%80%9A%E5%9D%97">找到有多少连通块</a></li>
<li><a href="#%E7%BB%9F%E8%AE%A1%E5%A4%9A%E5%B0%91%E4%B8%AA%E4%BC%9A%E8%A2%AB%E6%B7%B9%E6%B2%A1">统计多少个会被淹没</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%9B%BE%E8%AE%BA">图论</a>
<ul>
<li><a href="#%E4%BE%8B%E9%A2%98-1224-%E4%BA%A4%E6%8D%A2%E7%93%B6%E5%AD%90">例题 1224. 交换瓶子</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-22">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-22">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-22">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B1-5">输入样例1：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B1-5">输出样例1：</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B2-5">输入样例2：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B2-5">输出样例2：</a></li>
</ul>
</li>
<li><a href="#%E4%B9%A0%E9%A2%98-1207-%E5%A4%A7%E8%87%A3%E7%9A%84%E6%97%85%E8%B4%B9">习题 1207. 大臣的旅费</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-23">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-23">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-23">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-18">输入样例：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-18">输出样例：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%93%BE%E8%A1%A8">数组模拟链表</a>
<ul>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a></li>
<li><a href="#%E5%B0%86x%E6%8F%92%E5%88%B0%E5%A4%B4%E8%8A%82%E7%82%B9">将x插到头节点</a></li>
<li><a href="#%E5%B0%86x%E6%8F%92%E5%88%B0%E4%B8%8B%E6%A0%87%E4%B8%BAk%E7%9A%84%E8%8A%82%E7%82%B9%E5%90%8E">将x插到下标为k的节点后</a></li>
<li><a href="#%E5%B0%86%E4%B8%8B%E6%A0%87%E6%98%AFk%E7%9A%84%E5%90%8E%E9%9D%A2%E7%9A%84%E8%8A%82%E7%82%B9%E5%88%A0%E6%8E%89">将下标是k的后面的节点删掉</a></li>
<li><a href="#%E4%BE%8B%E9%A2%98-826-%E5%8D%95%E9%93%BE%E8%A1%A8">例题 826. 单链表</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-24">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-24">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-24">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-19">输入样例：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-19">输出样例：</a></li>
</ul>
</li>
<li><a href="#%E4%B9%A0%E9%A2%98-1243-%E7%B3%96%E6%9E%9C">习题 1243. 糖果</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-25">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-25">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-25">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-20">输入样例：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-20">输出样例：</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%B4%AA%E5%BF%83">贪心</a><br>
*
<ul>
<li><a href="#%E4%BE%8B%E9%A2%98-1055-%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96-ii">例题 1055. 股票买卖 II</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-26">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-26">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-26">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B1-6">输入样例1：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B1-6">输出样例1：</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B2-6">输入样例2：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B2-6">输出样例2：</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B3">输入样例3：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B3">输出样例3：</a></li>
<li><a href="#%E6%A0%B7%E4%BE%8B%E8%A7%A3%E9%87%8A-5">样例解释</a></li>
</ul>
</li>
<li><a href="#%E4%BE%8B%E9%A2%98-104-%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80">例题 104. 货仓选址</a></li>
<li><a href="#%E4%BE%8B%E9%A2%98-122-%E7%B3%96%E6%9E%9C%E4%BC%A0%E9%80%92">例题 122. 糖果传递</a></li>
<li><a href="#%E4%BE%8B%E9%A2%98-112-%E9%9B%B7%E8%BE%BE%E8%AE%BE%E5%A4%87">例题 112. 雷达设备</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-27">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-27">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-27">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-21">输入样例：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-21">输出样例：</a></li>
</ul>
</li>
<li><a href="#%E4%B9%A0%E9%A2%98-1235-%E4%BB%98%E8%B4%A6%E9%97%AE%E9%A2%98">习题 1235. 付账问题</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-28">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-28">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-28">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B1-7">输入样例1：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B1-7">输出样例1：</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B2-7">输入样例2：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B2-7">输出样例2：</a></li>
</ul>
</li>
<li><a href="#%E4%B9%A0%E9%A2%98-1239-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7">习题 1239. 乘积最大</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-29">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-29">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-29">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B1-8">输入样例1：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B1-8">输出样例1：</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B2-8">输入样例2：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B2-8">输出样例2：</a></li>
</ul>
</li>
<li><a href="#%E4%B9%A0%E9%A2%98-1247-%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F">习题 1247. 后缀表达式</a></li>
<li><a href="#%E4%B9%A0%E9%A2%98-1248-%E7%81%B5%E8%83%BD%E4%BC%A0%E8%BE%93">习题 1248. 灵能传输</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-30">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-30">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-30">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B1-9">输入样例1：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B1-9">输出样例1：</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B2-9">输入样例2：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B2-9">输出样例2：</a></li>
<li><a href="#%E6%A0%B7%E4%BE%8B%E8%A7%A3%E9%87%8A-6">样例解释</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%95%B0%E8%AE%BA">数论</a>
<ul>
<li><a href="#%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0-%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95">最大公约数-辗转相除法</a>
<ul>
<li><a href="#gcd%E5%87%BD%E6%95%B0">gcd函数</a></li>
<li><a href="#%E4%BE%8B%E9%A2%98-1246-%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97">例题 1246. 等差数列</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-31">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-31">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-31">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-22">输入样例：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-22">输出样例：</a></li>
<li><a href="#%E6%A0%B7%E4%BE%8B%E8%A7%A3%E9%87%8A-7">样例解释</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0-%E8%BE%97%E8%BD%AC%E7%9B%B8%E5%87%8F%E6%B3%95">最大公约数-辗转相减法</a>
<ul>
<li><a href="#%E4%B9%A0%E9%A2%98-1223-%E6%9C%80%E5%A4%A7%E6%AF%94%E4%BE%8B">习题 1223. 最大比例</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-32">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-32">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-32">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B1-10">输入样例1：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B1-10">输出样例1：</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B2-10">输入样例2：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B2-10">输出样例2：</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B3-2">输入样例3：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B3-2">输出样例3：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AE%97%E6%95%B0%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86">算数基本定理</a></li>
<li><a href="#%E7%BA%BF%E6%80%A7%E7%AD%9B%E8%B4%A8%E6%95%B0%E6%B3%95">线性筛质数法</a>
<ul>
<li><a href="#%E4%BE%8B%E9%A2%98-1295-x%E7%9A%84%E5%9B%A0%E5%AD%90%E9%93%BE">例题 1295. X的因子链</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-33">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-33">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-33">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-23">输入样例：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-23">输出样例：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E4%B8%8E%E7%BA%A6%E6%95%B0%E5%92%8C">约数个数与约数和</a>
<ul>
<li><a href="#%E4%BE%8B%E9%A2%98-1296-%E8%81%AA%E6%98%8E%E7%9A%84%E7%87%95%E5%A7%BF">例题 1296. 聪明的燕姿</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-34">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-34">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-34">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-24">输入样例：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-24">输出样例：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86-%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E5%AE%9A%E7%90%86">裴蜀定理-扩展欧几里得定理</a>
<ul>
<li><a href="#%E4%BE%8B%E9%A2%98-1299-%E4%BA%94%E6%8C%87%E5%B1%B1">例题 1299. 五指山</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-35">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-35">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-35">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-25">输入样例：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-25">输出样例：</a></li>
</ul>
</li>
<li><a href="#%E4%B9%A0%E9%A2%98-1301-c-%E5%BE%AA%E7%8E%AF">习题 1301. C 循环</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-36">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-36">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-36">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-26">输入样例：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-26">输出样例：</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%A4%8D%E6%9D%82dp">复杂DP</a>
<ul>
<li><a href="#%E7%BA%BF%E6%80%A7dp">线性DP</a>
<ul>
<li><a href="#%E4%BE%8B%E9%A2%98-1050-%E9%B8%A3%E4%BA%BA%E7%9A%84%E5%BD%B1%E5%88%86%E8%BA%AB">例题 1050. 鸣人的影分身</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-37">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-37">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-37">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-27">输入样例：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-27">输出样例：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B">背包模型</a>
<ul>
<li><a href="#%E4%BE%8B%E9%A2%98-1047-%E7%B3%96%E6%9E%9C">例题 1047. 糖果</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-38">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-38">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-38">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-28">输入样例：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-28">输出样例：</a></li>
<li><a href="#%E6%A0%B7%E4%BE%8B%E8%A7%A3%E9%87%8A-8">样例解释</a></li>
</ul>
</li>
<li><a href="#%E4%B9%A0%E9%A2%98-1226-%E5%8C%85%E5%AD%90%E5%87%91%E6%95%B0">习题 1226. 包子凑数</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-39">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-39">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-39">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B1-11">输入样例1：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B1-11">输出样例1：</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B2-11">输入样例2：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B2-11">输出样例2：</a></li>
<li><a href="#%E6%A0%B7%E4%BE%8B%E8%A7%A3%E9%87%8A-9">样例解释</a></li>
<li><a href="#%E4%BA%8C%E7%BB%B4%E4%BB%A3%E7%A0%81">二维代码</a></li>
<li><a href="#%E4%BC%98%E5%8C%96%E5%90%8E%E7%9A%84%E4%B8%80%E7%BB%B4%E4%BB%A3%E7%A0%81">优化后的一维代码</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%8C%BA%E9%97%B4dp">区间DP</a>
<ul>
<li><a href="#%E4%BE%8B%E9%A2%98-1222-%E5%AF%86%E7%A0%81%E8%84%B1%E8%90%BD">例题 1222. 密码脱落</a></li>
<li><a href="#%E4%B9%A0%E9%A2%98-1070-%E6%8B%AC%E5%8F%B7%E9%85%8D%E5%AF%B9">习题 1070. 括号配对</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-40">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-40">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-40">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-29">输入样例：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-29">输出样例：</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%A0%91%E5%BD%A2dp">树形DP</a>
<ul>
<li><a href="#%E4%BE%8B%E9%A2%98-1220-%E7%94%9F%E5%91%BD%E4%B9%8B%E6%A0%91">例题 1220. 生命之树</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-41">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-41">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-41">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-30">输入样例：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-30">输出样例：</a></li>
</ul>
</li>
<li><a href="#%E4%B9%A0%E9%A2%98-1078-%E6%97%85%E6%B8%B8%E8%A7%84%E5%88%92">习题 1078. 旅游规划</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-42">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-42">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-42">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-31">输入样例：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-31">输出样例：</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2">代码实现</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82">矩阵快速幂</a>
<ul>
<li><a href="#%E4%BE%8B%E9%A2%98-1303-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%89%8D-n-%E9%A1%B9%E5%92%8C">例题 1303. 斐波那契前 n 项和</a></li>
<li><a href="#%E4%B9%A0%E9%A2%98-1217-%E5%9E%92%E9%AA%B0%E5%AD%90">习题 1217. 垒骰子</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-43">输入格式</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-43">输出格式</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-43">数据范围</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-32">输入样例：</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-32">输出样例：</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://CNZedChou.github.io/post/ubuntu-2004-pei-zhi/">
              <h3 class="post-title">
                Ubuntu 20.04 配置
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank"> Gridea </a>
  <a class="rss" href="https://CNZedChou.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
