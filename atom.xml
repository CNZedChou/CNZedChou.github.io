<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://CNZedChou.github.io</id>
    <title>ZedChou&apos;s Blog</title>
    <updated>2023-02-12T17:29:23.399Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://CNZedChou.github.io"/>
    <link rel="self" href="https://CNZedChou.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://CNZedChou.github.io/images/avatar.png</logo>
    <icon>https://CNZedChou.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, ZedChou&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[AcWing算法提高课-第六章 基础算法]]></title>
        <id>https://CNZedChou.github.io/post/acwing-ti-gao-ji-chu-suan-fa/</id>
        <link href="https://CNZedChou.github.io/post/acwing-ti-gao-ji-chu-suan-fa/">
        </link>
        <updated>2023-02-11T16:29:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第六章-基础算法">第六章 基础算法</h1>
<h2 id="前缀和与差分">前缀和与差分</h2>
<h3 id="前缀和习题-acwing-99-激光炸弹">前缀和习题 AcWing 99. 激光炸弹</h3>
<p><a href="https://www.acwing.com/problem/content/description/101/">AcWing 99. 激光炸弹</a></p>
<h4 id="题目描述">题目描述</h4>
<p>地图上有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>个目标，用整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>Y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X_i,Y_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示目标在地图上的位置，每个目标都有一个价值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>W</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">W_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<p><strong>注意</strong>：不同目标可能在同一位置。</p>
<p>现在有一种新型的激光炸弹，可以摧毁一个包含 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>×</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">R×R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> 个位置的正方形内的所有目标。</p>
<p>激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个正方形的边必须和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mi mathvariant="normal">，</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">x，y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 轴平行。</p>
<p>求一颗炸弹最多能炸掉地图上总价值为多少的目标。</p>
<h4 id="样例">样例</h4>
<h6 id="输入格式">输入格式</h6>
<p>第一行输入正整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>，分别代表地图上的目标数目和正方形包含的横纵位置数量，数据用空格隔开。</p>
<p>接下来 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 行，每行输入一组数据，每组数据包括三个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>Y</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>W</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X_i,Y_i,W_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，分别代表目标的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 坐标，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 坐标和价值，数据用空格隔开。</p>
<pre><code>2 1
0 0 1
1 1 1
</code></pre>
<h6 id="输出格式">输出格式</h6>
<p>输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。</p>
<pre><code>1
</code></pre>
<h6 id="数据范围">数据范围</h6>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>R</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">0≤R≤10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>N</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">0&lt;N≤10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>,<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>X</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>Y</mi><mi>i</mi></msub><mo>≤</mo><mn>5000</mn></mrow><annotation encoding="application/x-tex">0≤X_i,Y_i≤5000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>W</mi><mi>i</mi></msub><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">0≤W_i≤1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
<hr>
<h4 id="算法">算法</h4>
<h5 id="二维前缀和">二维前缀和</h5>
<p>R的范围远大于区间的范围，所以<code>R</code>最多只能取到<code>5001</code>,否则就会数组越界<code>Segmentation Fault</code></p>
<h5 id="c-代码">C++ 代码</h5>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 5010;

int t, n, m, r;
int s[N][N];

int main() {
	scanf(&quot;%d%d&quot;, &amp;t, &amp;r);
	r = min(5001, r);
	n = m = r;

	for (int i = 0; i &lt; t; i ++) {
		// 由于坐标从0开始，故++使其从1开始
		int x, y, w;
		scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;w);
		x ++, y ++;
		n = max(x, n), m = max(y, m);  // 找到最大的x, y 作为边界
		s[x][y] += w;  // += 是因为可能不只有一个权值
	}

	// 初始化前缀和矩阵
	for (int i = 1; i &lt;= n; i ++) {
		for (int j = 1; j &lt;= m; j ++) {
			s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];
			// s[i][j] = a[i][j] + s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1]
		}
	}

	// 遍历整个地图查找最大值
	int res = 0;
	for (int i = r; i &lt;= n; i ++) {
		for (int j = r; j &lt;= m; j ++) {
			res = max(res, s[i][j] - s[i - r][j] - s[i][j - r] + s[i - r][j - r]);
			// s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]
		}
	}
	printf(&quot;%d\n&quot;, res);

	return 0;
}
</code></pre>
<h3 id="差分习题-acwing-100-增减序列">差分习题 AcWing 100. 增减序列</h3>
<p><a href="https://www.acwing.com/problem/content/102/">AcWing 100. 增减序列</a></p>
<h4 id="题目描述-2">题目描述</h4>
<p>给定一个长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的数列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mn>1</mn><mo separator="true">,</mo><mi>a</mi><mn>2</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>a</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">a1,a2,…,an</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span></span></span></span>，每次可以选择一个区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>，使下标在这个区间内的数都加一或者都减一。</p>
<p>求至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列可能有多少种。</p>
<h4 id="样例-2">样例</h4>
<h6 id="输入格式-2">输入格式</h6>
<p>第一行输入正整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>。</p>
<p>接下来 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 行，每行输入一个整数，第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 行的整数代表 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<pre><code>4
1
1
2
2
</code></pre>
<h6 id="输出格式-2">输出格式</h6>
<p>第一行输出最少操作次数。</p>
<p>第二行输出最终能得到多少种结果。</p>
<pre><code>1
2
</code></pre>
<h6 id="数据范围-2">数据范围</h6>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">0&lt;n≤10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>,<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>&lt;</mo><mn>2147483648</mn></mrow><annotation encoding="application/x-tex">0≤a_i&lt;2147483648</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">1</span><span class="mord">4</span><span class="mord">7</span><span class="mord">4</span><span class="mord">8</span><span class="mord">3</span><span class="mord">6</span><span class="mord">4</span><span class="mord">8</span></span></span></span></p>
<hr>
<h4 id="算法-2">算法</h4>
<h5 id="方法名称">方法名称</h5>
<h5 id="c-代码-2">C++ 代码</h5>
<pre><code class="language-c++">
</code></pre>
<h2 id="二分">二分</h2>
<h3 id="例题-acwing-102-最佳牛围栏">例题 AcWing 102. 最佳牛围栏</h3>
<p><a href="https://www.acwing.com/problem/content/104/">AcWing 102. 最佳牛围栏</a></p>
<h4 id="题目描述-3">题目描述</h4>
<p>农夫约翰的农场由 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 块田地组成，每块地里都有一定数量的牛，其数量不会少于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 头，也不会超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2000</mn></mrow><annotation encoding="application/x-tex">2000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 头。</p>
<p>约翰希望用围栏将一部分连续的田地围起来，并使得围起来的区域内每块地包含的牛的数量的平均值达到最大。</p>
<p>围起区域内至少需要包含 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span> 块地，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span> 会在输入中给出。</p>
<p>在给定条件下，计算围起区域内每块地包含的牛的数量的平均值可能的最大值是多少。</p>
<h4 id="样例-3">样例</h4>
<h6 id="输入格式-3">输入格式</h6>
<p>第一行输入整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span>，数据间用空格隔开。</p>
<p>接下来 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 行，每行输入一个整数，第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 行输入的整数代表第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 片区域内包含的牛的数目。</p>
<pre><code>10 6
6 
4
2
10
3
8
5
9
4
1
</code></pre>
<h6 id="输出格式-3">输出格式</h6>
<p>输出一个整数，表示平均值的最大值乘以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1000</mn></mrow><annotation encoding="application/x-tex">1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 再 <strong>向下取整</strong> 之后得到的结果。</p>
<pre><code>6500
</code></pre>
<h6 id="数据范围-3">数据范围</h6>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">1≤N≤100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>F</mi><mo>≤</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">1≤F≤N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></p>
<hr>
<h4 id="算法-3">算法</h4>
<h5 id="二分-前缀和-双指针">二分 + 前缀和 + 双指针</h5>
<p>答案可二分性</p>
<p>在原序列中是否存在一段，它的平均值大于等于mid</p>
<ol>
<li>将各个元素减去mid之后，得到一个新的序列</li>
<li>在新的序列中，是否存在一个长度大于等于F的子序列，它的和是非负的</li>
<li>使用前缀和处理，<code>s[j] - s[i] &gt;= 0</code> 转化为 <code>s[j] &gt;= s[i]</code>， 其中 <code>i</code>是要小于<code>j - F</code>，找出满足条件的<code>s[i]</code> 最小值</li>
</ol>
<h5 id="c-代码-3">C++ 代码</h5>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 100010;

int n, f;
double a[N], s[N];  // 存储前缀和

bool check(double avg) {
	// 处理均值与前缀和
	for (int i = 1; i &lt;= n; i ++) s[i] = s[i - 1] + a[i] - avg;
	double minv = 0;
	for (int i = 0, j = f; j &lt;= n; i ++, j ++) {
		minv = min(minv, s[i]);  // 
		if (s[j] &gt;= minv) return true;  // s[j] &gt;= 前缀最小值，则可以达成
	}
	return false;
}


int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;f);
	double l = 0, r = 0;
	for (int i = 1; i &lt;= n; i ++) {
		scanf(&quot;%lf&quot;, &amp;a[i]);
		r = max(r, a[i]);
	}
	
	while ((r - l) &gt; 1e-5) {
		double mid = (l + r) / 2;
		if (check(mid)) l = mid;
		else r = mid;
	}
	printf(&quot;%d\n&quot;, (int) (r * 1000));

	return 0;
}
</code></pre>
<h3 id="例题-acwing-113-特殊排序">例题 AcWing 113. 特殊排序</h3>
<p><a href="https://www.acwing.com/problem/content/115/">AcWing 113. 特殊排序</a></p>
<h4 id="题目描述-4">题目描述</h4>
<p>有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 个元素，编号 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>2..</mn><mi>N</mi></mrow><annotation encoding="application/x-tex">1,2..N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>，每一对元素之间的大小关系是确定的，关系具有反对称性，但不具有传递性。</p>
<p><strong>注意</strong>：不存在两个元素大小相等的情况。</p>
<p>也就是说，元素的大小关系是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 个点与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>N</mi><mo>×</mo><mo>(</mo><mi>N</mi><mi mathvariant="normal">−</mi><mn>1</mn><mo>)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{N×(N−1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">×</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mord mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 条有向边构成的任意有向图。</p>
<p>然而，这是一道交互式试题，这些关系不能一次性得知，你必须通过不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10000</mn></mrow><annotation encoding="application/x-tex">10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 次提问来获取信息，每次提问只能了解某两个元素之间的关系。</p>
<p>现在请你把这 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 个元素排成一行，使得每个元素都小于右边与它相邻的元素。</p>
<p>你可以通过我们预设的 bool 函数 compare 来获得两个元素之间的大小关系。</p>
<p>例如，编号为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 的两个元素，如果元素 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 小于元素 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>a</mi><mi>r</mi><mi>e</mi><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">compare(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span> 返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">true</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span></span></span></span>，否则返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">false</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span></span></span></span>。</p>
<p>将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 个元素排好序后，把他们的编号以数组的形式输出，如果答案不唯一，则输出任意一个均可。</p>
<h4 id="样例-4">样例</h4>
<h6 id="输入格式-4">输入格式</h6>
<pre><code>[[0, 1, 0], [0, 0, 0], [1, 1, 0]]
</code></pre>
<h6 id="输出格式-4">输出格式</h6>
<pre><code>[3, 1, 2]
</code></pre>
<h6 id="数据范围-4">数据范围</h6>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">1≤N≤1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
<hr>
<h4 id="算法-4">算法</h4>
<h5 id="二分-插入排序">二分 插入排序</h5>
<pre><code>样例的意思
[[0, 1, 0], 
 [0, 0, 0], 
 [1, 1, 0]]
指的是对于3个数的每组compare
compare（1，1）=0, compare（1，2）=1, compare（1，3）=0
compare（2，1）=0, compare（2，2）=0, compare（2，3）=0
compare（3，1）=1, compare（3，2）=1, compare（3，3）=0
其中 对角线不用看，只看上三角即可
compare（1，2）=1, 1 &lt; 2， compare（1，3）=0， 1 &gt; 3, compare（2，3）=0， 2 &gt; 3
对 1&lt;2, 1&gt;3, 2&gt;3 进行排序
</code></pre>
<p>首先假设vector中有排好序的一组元素：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo separator="true">,</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">a, b, c, d, e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span></span></span></span><br>
现在我们要在vector中插入f，如何确定f的位置？直接二分<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mi>d</mi><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">midd=c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>，如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>&gt;</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">f&gt;c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi mathvariant="normal">，</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">c，e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">e</span></span></span></span>之间，反之在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">，</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">a，c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">c</span></span></span></span>之间。</p>
<h5 id="c-代码-4">C++ 代码</h5>
<pre><code class="language-c++">// Forward declaration of compare API.
// bool compare(int a, int b);
// return bool means whether a is less than b.

class Solution {
public:
    vector&lt;int&gt; specialSort(int N) { //N表示N个数，分别为1~N
        vector&lt;int&gt; res;  //用于排序的vector
        res.push_back(1);  // 先将1插入，后面的元素可以和1进行比较
        for (int i = 2; i &lt;= N; i ++) {
        	int l = 0, r = res.size() - 1;
        	while(l &lt; r) {
        		int mid = (l + r + 1) &gt;&gt; 1;
        		if (compare(res[mid], i)) l = mid;
        		else r = mid - 1;
        	}
        	res.push_back(i);
        	for (int j = res.size() - 2; j &gt; r; j --) swap(res[j], res[j + 1]);
        	if (compare(i, res[r])) swap(res[r], res[r + 1]);
        }
        return res;
    }
};
</code></pre>
<h3 id=""></h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[蓝桥杯每日一题]]></title>
        <id>https://CNZedChou.github.io/post/lan-qiao-bei-mei-ri-yi-ti/</id>
        <link href="https://CNZedChou.github.io/post/lan-qiao-bei-mei-ri-yi-ti/">
        </link>
        <updated>2023-02-11T06:06:15.000Z</updated>
        <summary type="html"><![CDATA[<p>@Description:   用于AcWing上蓝桥杯集训·每日一题的学习过程</p>
<p>@Author:    Zed Chou</p>
<p>@LastModified:    Mon 13 Feb 2023</p>
]]></summary>
        <content type="html"><![CDATA[<p>@Description:   用于AcWing上蓝桥杯集训·每日一题的学习过程</p>
<p>@Author:    Zed Chou</p>
<p>@LastModified:    Mon 13 Feb 2023</p>
<!-- more -->
<h1 id="知识点">知识点</h1>
<table>
<thead>
<tr>
<th>日期</th>
<th>知识点</th>
</tr>
</thead>
<tbody>
<tr>
<td>2月13日</td>
<td>前缀和</td>
</tr>
<tr>
<td>2月14日</td>
<td>差分</td>
</tr>
<tr>
<td>2月15日</td>
<td>二分</td>
</tr>
<tr>
<td>2月16日</td>
<td>双指针</td>
</tr>
<tr>
<td>2月17日</td>
<td>递推</td>
</tr>
<tr>
<td>2月20日</td>
<td>递归</td>
</tr>
<tr>
<td>2月21日</td>
<td>并查集</td>
</tr>
<tr>
<td>2月22日</td>
<td>哈希</td>
</tr>
<tr>
<td>2月23日</td>
<td>单调队列</td>
</tr>
<tr>
<td>2月24日</td>
<td>KMP</td>
</tr>
<tr>
<td>2月27日</td>
<td>Trie</td>
</tr>
<tr>
<td>2月28日</td>
<td>BFS</td>
</tr>
<tr>
<td>3月1日</td>
<td>DFS</td>
</tr>
<tr>
<td>3月2日</td>
<td>拓扑排序</td>
</tr>
<tr>
<td>3月3日</td>
<td>Dijkstra</td>
</tr>
<tr>
<td>3月6日</td>
<td>SPFA</td>
</tr>
<tr>
<td>3月7日</td>
<td>Floyd</td>
</tr>
<tr>
<td>3月8日</td>
<td>最小生成树</td>
</tr>
<tr>
<td>3月9日</td>
<td>最近公共祖先</td>
</tr>
<tr>
<td>3月10日</td>
<td>二分图</td>
</tr>
<tr>
<td>3月13日</td>
<td>筛质数</td>
</tr>
<tr>
<td>3月14日</td>
<td>最大公约数</td>
</tr>
<tr>
<td>3月15日</td>
<td>快速幂</td>
</tr>
<tr>
<td>3月16日</td>
<td>组合计数</td>
</tr>
<tr>
<td>3月17日</td>
<td>博弈论</td>
</tr>
<tr>
<td>3月20日</td>
<td>背包DP</td>
</tr>
<tr>
<td>3月21日</td>
<td>线性DP</td>
</tr>
<tr>
<td>3月22日</td>
<td>区间DP</td>
</tr>
<tr>
<td>3月23日</td>
<td>树形DP</td>
</tr>
<tr>
<td>3月24日</td>
<td>树状数组</td>
</tr>
<tr>
<td>3月27日</td>
<td>线段树</td>
</tr>
<tr>
<td>3月28日</td>
<td>矩阵乘法</td>
</tr>
</tbody>
</table>
<h1 id="前缀和">前缀和</h1>
<p>Wiki可见  <a href="https://oi-wiki.org/basic/prefix-sum/">前缀和 &amp; 差分</a></p>
<h2 id="一维前缀和">一维前缀和</h2>
<p>前缀和可以快速地求出一个<strong>静态数组</strong>（不会被修改）中某一个区间内所有数的和，有效提高运行效率。</p>
<h3 id="算法思路">算法思路</h3>
<p>定义原数组<code>a[ ]</code>和前缀和数组<code>s[ ]</code></p>
<pre><code class="language-c++">//a[]为原数组，s[]为前缀和数组 
s[0] = 0 //特殊规定 
s[i] = a[1] + a[2] + ... + a[i] //s[i]表示原数组的前i个数的和 
...
s[n] = a[1] + a[2] + ... +a[n]
</code></pre>
<ol>
<li>预处理前缀和数组，时间复杂度O(N)</li>
</ol>
<pre><code class="language-c++">//预处理s数组，O(N)的时间复杂度很快 
for (int i = 1; i &lt;= n; i++) s[i] = s[i - 1] + a[i];
</code></pre>
<ol start="2">
<li>查询，时间复杂度O(1)</li>
</ol>
<pre><code class="language-c++">//查询 [l,r] ,O(1)的时间复杂度 
a[l] + a[l + 1] + a[l + 2] + ... + a[r] = s[r] - s[l - 1] 
// s[r]     = a[1]+a[2]+...+a[l - 1] + a[l]+a[l + 1]+a[l + 2]+...+a[r]
// s[l - 1] = a[1]+a[2]+...+a[l - 1]
</code></pre>
<h3 id="代码模板">代码模板</h3>
<pre><code class="language-c++">S[i] = a[1] + a[2] + ... a[i]
a[l] + ... + a[r] = S[r] - S[l - 1]
</code></pre>
<h3 id="例题-acwing-795-前缀和">例题 AcWing 795. 前缀和</h3>
<p><a href="https://www.acwing.com/problem/content/797/">AcWing 795. 前缀和</a></p>
<h4 id="题目描述">题目描述</h4>
<p>输入一个长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的整数序列。</p>
<p>接下来再输入 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 个询问，每个询问输入一对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo separator="true">,</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l,r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>。</p>
<p>对于每个询问，输出原序列中从第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 个数到第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 个数的和。</p>
<h4 id="样例">样例</h4>
<h6 id="输入格式">输入格式</h6>
<p>第一行包含两个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>。</p>
<p>第二行包含 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个整数，表示整数数列。</p>
<p>接下来 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 行，每行包含两个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>，表示一个询问的区间范围。</p>
<pre><code>5 3
2 1 3 6 4
1 2
1 3
2 4
</code></pre>
<h6 id="输出格式">输出格式</h6>
<p>共 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 行，每行输出一个询问的结果。</p>
<pre><code>3
6
10
</code></pre>
<h6 id="数据范围">数据范围</h6>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>l</mi><mo>≤</mo><mi>r</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1≤l≤r≤n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>,<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">1≤n,m≤100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>,<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">−</mi><mn>1000</mn><mo>≤</mo><mi mathvariant="normal">数</mi><mi mathvariant="normal">列</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">元</mi><mi mathvariant="normal">素</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">值</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">−1000≤数列中元素的值≤1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">列</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">元</span><span class="mord cjk_fallback">素</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">值</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
<hr>
<h4 id="算法">算法</h4>
<h5 id="一维前缀和-2">一维前缀和</h5>
<h5 id="c-代码">C++ 代码</h5>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 100010;

int n, m;
int a[N], s[N];

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);

	for (int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]);

	// 初始化前缀和数组
	for (int i = 1; i &lt;= n; i ++) s[i] = s[i - 1] + a[i];

	// 处理m次询问
	while (m --) {
		int l, r;
		scanf(&quot;%d%d&quot;, &amp;l, &amp;r);
		printf(&quot;%d\n&quot;, s[r] - s[l - 1]);
	}

	return 0;
}
</code></pre>
<h3 id="习题-acwing-1230-k倍区间">习题 AcWing 1230. K倍区间</h3>
<p><a href="https://www.acwing.com/problem/content/description/1232/">AcWing 1230. K倍区间</a></p>
<h4 id="题目描述-2">题目描述</h4>
<p>给定一个长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 的数列，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mn>1</mn><mo separator="true">,</mo><mi>A</mi><mn>2</mn><mo separator="true">,</mo><mo>…</mo><mi>A</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">A1,A2,…AN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">A</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>，如果其中一段连续的子序列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>i</mi><mo separator="true">,</mo><mi>A</mi><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mo>…</mo><mi>A</mi><mi>j</mi></mrow><annotation encoding="application/x-tex">Ai,Ai+1,…Aj</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>之和是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 的倍数，我们就称这个区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[i,j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 倍区间。</p>
<p>你能求出数列中总共有多少个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 倍区间吗？</p>
<h4 id="样例-2">样例</h4>
<h6 id="输入格式-2">输入格式</h6>
<p>第一行包含两个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>。</p>
<p>以下 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 行每行包含一个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">Ai</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">i</span></span></span></span>。</p>
<pre><code>5 2
1
2
3
4
5
</code></pre>
<h6 id="输出格式-2">输出格式</h6>
<p>输出一个整数，代表 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 倍区间的数目。</p>
<pre><code>6
</code></pre>
<h6 id="数据范围-2">数据范围</h6>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo separator="true">,</mo><mi>K</mi><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">1≤N,K≤100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>,<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>A</mi><mi>i</mi><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">1≤Ai≤100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
<hr>
<h4 id="算法-2">算法</h4>
<h5 id="前缀和-余数">前缀和 + 余数</h5>
<p>如果存在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>&lt;</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">j &lt; i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>  满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub><mo>≡</mo><msub><mi>S</mi><mi>j</mi></msub><mspace></mspace><mspace width="0.4444444444444444em"/><mo>(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333333333333333em"/><mi>k</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">S_i \equiv S_j \pmod k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444444444444444em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>， 则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub><mo>−</mo><msub><mi>S</mi><mi>j</mi></msub><mo>≡</mo><mn>0</mn><mspace></mspace><mspace width="0.4444444444444444em"/><mo>(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333333333333333em"/><mi>k</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">S_i-S_j \equiv 0 \pmod k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444444444444444em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></p>
<p>可以开一个数组<code>cnt[]</code>存一下不同余数的个数，<code>cnt[i]</code>表示余数是i的数有多少个</p>
<p><code>(sum[r] - sum[l-1]) % k = 0</code> 那么sum[r] 和sum[l-1]同余，我们只要求出每一个前缀和对k的余数，并运用排列组合公式即可。注意前缀和<code>sum[0]%k=0</code>也是要统计的，因为算某个区间的和需要用到<code>sum[0]</code></p>
<h5 id="c-代码-2">C++ 代码</h5>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

typedef long long LL;

using namespace std;

const int N = 100010;

int n, k;
LL s[N], cnt[N];

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;k);

	for (int i = 1; i &lt;= n; i ++) {
		scanf(&quot;%d&quot;, &amp;s[i]);
		s[i] += s[i - 1];
	}

	for (int i = 1; i &lt;= n; i ++) {
		cnt[s[i] % k] ++;
	}
	cnt[0] ++;

	LL res = 0;
	for (int i = 0; i &lt; k; i ++) {
	    LL t = cnt[i];
		res += (LL) t * (t - 1) / 2;
	}

	printf(&quot;%lld\n&quot;, res);

	return 0;
}
</code></pre>
<h3 id="习题-洛谷-b3612-求区间和">习题 洛谷 B3612 求区间和</h3>
<p><a href="https://www.luogu.com.cn/problem/B3612">洛谷 B3612 求区间和</a></p>
<h4 id="题目描述-3">题目描述</h4>
<p>给定 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个正整数组成的数列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_1,a_2,⋯,a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>个区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><msub><mi>l</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>r</mi><mo>+</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l_i,r+i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>，分别求这 <em><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span></em> 个区间的区间和。</p>
<h4 id="样例-3">样例</h4>
<h6 id="输入格式-3">输入格式</h6>
<p>共<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>+</mo><mi>m</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n+m+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 行。</p>
<p>第一行，为一个正整数 <em>n</em> 。</p>
<p>第二行，为 <em>n</em> 个正整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_1,a_2,⋯,a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>第三行，为一个正整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 。</p>
<p>第 4 到第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>+</mo><mi>m</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n+m+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>行 ，每行为两个正整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">l_i,r_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>l</mi><mi>i</mi></msub><mo>≤</mo><msub><mi>r</mi><mi>i</mi></msub><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \le l_i \le r_i \le n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></p>
<pre><code>4
4 3 2 1
2
1 4
2 3
</code></pre>
<h6 id="输出格式-3">输出格式</h6>
<p>共 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 行。</p>
<p>第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 行为第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 组答案的询问。</p>
<pre><code>10
5
</code></pre>
<h6 id="数据范围-3">数据范围</h6>
<p>样例解释：第 1 到第 4 个数加起来和为 10。第 2 个数到第 3 个数加起来和为 5。</p>
<p>对于 50% 的数据：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1000</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">1000\le n,m ≤1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> ；</p>
<p>对于 100% 的数据：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mi mathvariant="normal">，</mi><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">1≤n,m≤10^5，1≤a_i≤10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>。</p>
<hr>
<h4 id="算法-3">算法</h4>
<h5 id="一维前缀和-3">一维前缀和</h5>
<h5 id="c-代码-3">C++ 代码</h5>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 1e5 + 10;

int n, m;
int s[N];

int main() {
	scanf(&quot;%d&quot;, &amp;n);

	for (int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;s[i]);
	// 初始化前缀和矩阵
	for (int i = 1; i &lt;= n; i ++) s[i] += s[i - 1];

	scanf(&quot;%d&quot;, &amp;m);
	while (m --) {
		int l, r;
		scanf(&quot;%d%d&quot;, &amp;l, &amp;r);
		printf(&quot;%d\n&quot;, s[r] - s[l - 1]);
	}

	return 0;
}
</code></pre>
<h3 id="习题-洛谷-p3131-subsequences-summing-to-sevens-s">习题 洛谷 P3131 Subsequences Summing to Sevens S</h3>
<p><a href="https://www.luogu.com.cn/problem/P3131">洛谷 P3131 Subsequences Summing to Sevens S</a></p>
<h4 id="题目描述-4">题目描述</h4>
<p>Farmer John's <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> cows are standing in a row, as they have a tendency to do from time to time. Each cow is labeled with a distinct integer ID number so FJ can tell them apart. FJ would like to take a photo of a contiguous group of cows but, due to a traumatic childhood incident involving the numbers <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>…</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">1…6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span></span></span></span>, he only wants to take a picture of a group of cows if their IDs add up to a multiple of 7.</p>
<p>Please help FJ determine the size of the largest group he can photograph.</p>
<p>给你<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个数，分别是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo separator="true">,</mo><mi>a</mi><mo>[</mo><mn>2</mn><mo>]</mo><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>a</mi><mo>[</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[1],a[2],...,a[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span>。求一个最长的区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[x,y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span>，使得区间中的数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo separator="true">,</mo><mi>a</mi><mo>[</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo separator="true">,</mo><mi>a</mi><mo>[</mo><mi>x</mi><mo>+</mo><mn>2</mn><mo>]</mo><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>a</mi><mo>[</mo><mi>y</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo separator="true">,</mo><mi>a</mi><mo>[</mo><mi>y</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">(a[x],a[x+1],a[x+2],...,a[y-1],a[y])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span>的和能被7整除。输出区间长度。若没有符合要求的区间，输出0。</p>
<h4 id="样例-4">样例</h4>
<h6 id="输入格式-4">输入格式</h6>
<p>The first line of input contains <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>(</mo><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>50</mn><mo separator="true">,</mo><mn>000</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">N (1≤N≤50,000)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>. The next <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></p>
<p>lines each contain the <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> integer IDs of the cows (all are in the range</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>…</mo><mn>1</mn><mo separator="true">,</mo><mn>000</mn><mo separator="true">,</mo><mn>000</mn></mrow><annotation encoding="application/x-tex">0…1,000,000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>.</p>
<pre><code>7
3
5
1
6
2
14
10
</code></pre>
<h6 id="输出格式-4">输出格式</h6>
<p>Please output the number of cows in the largest consecutive group whose IDs sum</p>
<p>to a multiple of 7. If no such group exists, output 0.</p>
<pre><code>5
</code></pre>
<h6 id="说明提示">说明/提示</h6>
<p>In this example, 5+1+6+2+14 = 28.</p>
<hr>
<h4 id="算法-4">算法</h4>
<h5 id="一维前缀和-同余">一维前缀和 + 同余</h5>
<p>如果存在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>&lt;</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">j &lt; i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>  满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub><mo>≡</mo><msub><mi>S</mi><mi>j</mi></msub><mspace></mspace><mspace width="0.4444444444444444em"/><mo>(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333333333333333em"/><mn>7</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">S_i \equiv S_j \pmod 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444444444444444em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord">7</span><span class="mclose">)</span></span></span></span>， 则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub><mo>−</mo><msub><mi>S</mi><mi>j</mi></msub><mo>≡</mo><mn>0</mn><mspace></mspace><mspace width="0.4444444444444444em"/><mo>(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333333333333333em"/><mn>7</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">S_i-S_j \equiv 0 \pmod 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444444444444444em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord">7</span><span class="mclose">)</span></span></span></span></p>
<h5 id="c-代码-4">C++ 代码</h5>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 50010;

int n;
int s[N], l[7], r[7];

int main() {
	scanf(&quot;%d&quot;, &amp;n);

	for (int i = 1; i &lt;= n; i ++) {
		int cur;
		scanf(&quot;%d&quot;, &amp;cur);
		// 初始化前缀和矩阵
		s[i] = (s[i - 1] + cur) % 7;
	}
	// 从右往左，记录7的每个余数的最左边的坐标值
	for (int i = n; i ; i --) l[s[i]] = i;
	// 从左往右，记录7的每个余数的最右边的坐标值
	for (int i = 1; i &lt;= n; i ++) r[s[i]] = i;
	l[0] = 0;

	int res = 0;
	for (int i = 0; i &lt;= 6; i ++) {
		if (r[i]) res = max(res, r[i] - l[i]);
	}

	printf(&quot;%d\n&quot;, res);

	return 0;
}
</code></pre>
<h2 id="二维前缀和">二维前缀和</h2>
<p>二维前缀和（前缀和矩阵），对一维前缀和的扩展</p>
<h3 id="算法思路-2">算法思路</h3>
<p>定义原数组<code>a[ ][ ]</code>和前缀和数组<code>s[ ][ ]</code></p>
<pre><code class="language-c++">//s[][]中每一个数表示原矩阵当中左上角的所有数的和 
</code></pre>
<ol>
<li>预处理二维前缀和数组</li>
</ol>
<pre><code class="language-c++">// 容斥原理
s[x][y] = s[x - 1][y] + s[x][y - 1] - s[x - 1][y - 1] + a[x][y]
</code></pre>
<ol start="2">
<li>查询</li>
</ol>
<pre><code class="language-c++">// 容斥原理
// 子矩阵左上角[x1,y1],右下角[x2][y2] 
ans = s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2] + s[x1 -1 ][y1 - 1] 
//将时间复杂度从O(N*M)降到O(1)
</code></pre>
<h3 id="代码模板-2">代码模板</h3>
<pre><code class="language-c++">// S[i, j] = 第i行j列格子左上部分所有元素的和
// 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
</code></pre>
<h3 id="例题-acwing-796-子矩阵的和">例题 AcWing 796. 子矩阵的和</h3>
<p><a href="https://www.acwing.com/problem/content/798/">AcWing 796. 子矩阵的和</a></p>
<h4 id="题目描述-5">题目描述</h4>
<p>输入一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 列的整数矩阵，再输入 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span> 个询问，每个询问包含四个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mn>1</mn><mo separator="true">,</mo><mi>x</mi><mn>2</mn><mo separator="true">,</mo><mi>y</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">x1,y1,x2,y2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span></span></span></span>，表示一个子矩阵的左上角坐标和右下角坐标。</p>
<p>对于每个询问输出子矩阵中所有数的和。</p>
<h4 id="样例-5">样例</h4>
<h6 id="输入格式-5">输入格式</h6>
<p>第一行包含三个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">，</mi><mi>m</mi><mi mathvariant="normal">，</mi><mi>q</mi></mrow><annotation encoding="application/x-tex">n，m，q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">m</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>。</p>
<p>接下来 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 行，每行包含 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 个整数，表示整数矩阵。</p>
<p>接下来 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span> 行，每行包含四个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mn>1</mn><mo separator="true">,</mo><mi>x</mi><mn>2</mn><mo separator="true">,</mo><mi>y</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">x1,y1,x2,y2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span></span></span></span>，表示一组询问。</p>
<pre><code>3 4 3
1 7 2 4
3 6 2 8
2 1 2 3
1 1 2 2
2 1 3 4
1 3 3 4
</code></pre>
<h6 id="输出格式-5">输出格式</h6>
<p>共 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span> 行，每行输出一个询问的结果。</p>
<pre><code>17
27
21
</code></pre>
<h6 id="数据范围-4">数据范围</h6>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">1≤n,m≤1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>,<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>q</mi><mo>≤</mo><mn>200000</mn></mrow><annotation encoding="application/x-tex">1≤q≤200000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>x</mi><mn>1</mn><mo>≤</mo><mi>x</mi><mn>2</mn><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1≤x1≤x2≤n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>y</mi><mn>1</mn><mo>≤</mo><mi>y</mi><mn>2</mn><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">1≤y1≤y2≤m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">−</mi><mn>1000</mn><mo>≤</mo><mi mathvariant="normal">矩</mi><mi mathvariant="normal">阵</mi><mi mathvariant="normal">内</mi><mi mathvariant="normal">元</mi><mi mathvariant="normal">素</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">值</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">−1000≤矩阵内元素的值≤1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord cjk_fallback">矩</span><span class="mord cjk_fallback">阵</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">元</span><span class="mord cjk_fallback">素</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">值</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
<hr>
<h4 id="算法-5">算法</h4>
<h5 id="二维前缀和-2">二维前缀和</h5>
<h5 id="c-代码-5">C++ 代码</h5>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 1010;

int n, m, q;
int a[N][N], s[N][N];

int main() {
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q);
	for (int i = 1; i &lt;= n; i ++) {
		for (int j = 1; j &lt;= m; j ++) {
			scanf(&quot;%d&quot;, &amp;a[i][j]);
		}
	}
	// 初始化前缀和矩阵
	for (int i = 1; i &lt;= n; i ++) {
		for (int j = 1; j &lt;= m; j ++) {
			s[i][j] = a[i][j] + s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];
		}
	}
	// 处理查询
	while (q --) {
		int x1, y1, x2, y2;
		scanf(&quot;%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);
		printf(&quot;%d\n&quot;, s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]);
	}

	return 0;
}
</code></pre>
<h3 id="习题-acwing-99-激光炸弹">习题 AcWing 99. 激光炸弹</h3>
<p><a href="https://www.acwing.com/problem/content/description/101/">AcWing 99. 激光炸弹</a></p>
<h4 id="题目描述-6">题目描述</h4>
<p>地图上有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>个目标，用整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>Y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X_i,Y_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示目标在地图上的位置，每个目标都有一个价值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>W</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">W_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<p><strong>注意</strong>：不同目标可能在同一位置。</p>
<p>现在有一种新型的激光炸弹，可以摧毁一个包含 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>×</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">R×R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> 个位置的正方形内的所有目标。</p>
<p>激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个正方形的边必须和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mi mathvariant="normal">，</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">x，y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 轴平行。</p>
<p>求一颗炸弹最多能炸掉地图上总价值为多少的目标。</p>
<h4 id="样例-6">样例</h4>
<h6 id="输入格式-6">输入格式</h6>
<p>第一行输入正整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>，分别代表地图上的目标数目和正方形包含的横纵位置数量，数据用空格隔开。</p>
<p>接下来 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 行，每行输入一组数据，每组数据包括三个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>Y</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>W</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X_i,Y_i,W_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，分别代表目标的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 坐标，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 坐标和价值，数据用空格隔开。</p>
<pre><code>2 1
0 0 1
1 1 1
</code></pre>
<h6 id="输出格式-6">输出格式</h6>
<p>输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。</p>
<pre><code>1
</code></pre>
<h6 id="数据范围-5">数据范围</h6>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>R</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">0≤R≤10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>N</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">0&lt;N≤10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>,<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>X</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>Y</mi><mi>i</mi></msub><mo>≤</mo><mn>5000</mn></mrow><annotation encoding="application/x-tex">0≤X_i,Y_i≤5000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>W</mi><mi>i</mi></msub><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">0≤W_i≤1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
<hr>
<h4 id="算法-6">算法</h4>
<h5 id="二维前缀和-3">二维前缀和</h5>
<p>R的范围远大于区间的范围，所以<code>R</code>最多只能取到<code>5001</code>,否则就会数组越界<code>Segmentation Fault</code></p>
<h5 id="c-代码-6">C++ 代码</h5>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 5010;

int t, n, m, r;
int s[N][N];

int main() {
	scanf(&quot;%d%d&quot;, &amp;t, &amp;r);
	r = min(5001, r);
	n = m = r;

	for (int i = 0; i &lt; t; i ++) {
		// 由于坐标从0开始，故++使其从1开始
		int x, y, w;
		scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;w);
		x ++, y ++;
		n = max(x, n), m = max(y, m);  // 找到最大的x, y 作为边界
		s[x][y] += w;  // += 是因为可能不只有一个权值
	}

	// 初始化前缀和矩阵
	for (int i = 1; i &lt;= n; i ++) {
		for (int j = 1; j &lt;= m; j ++) {
			s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];
			// s[i][j] = a[i][j] + s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1]
		}
	}

	// 遍历整个地图查找最大值
	int res = 0;
	for (int i = r; i &lt;= n; i ++) {
		for (int j = r; j &lt;= m; j ++) {
			res = max(res, s[i][j] - s[i - r][j] - s[i][j - r] + s[i - r][j - r]);
			// s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]
		}
	}
	printf(&quot;%d\n&quot;, res);

	return 0;
}
</code></pre>
<h3 id="习题-洛谷-p1387-最大正方形">习题 洛谷 P1387 最大正方形</h3>
<p><a href="https://www.luogu.com.cn/problem/P1387">洛谷 P1387 最大正方形</a></p>
<h4 id="题目描述-7">题目描述</h4>
<p>在一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n×m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的只包含 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的矩阵里找出一个不包含 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的最大正方形，输出边长。</p>
<h4 id="样例-7">样例</h4>
<h6 id="输入格式-7">输入格式</h6>
<p>输入文件第一行为两个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>(</mo><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>100</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">n,m(1≤n,m≤100)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，接下来 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 行，每行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 个数字，用空格隔开，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p>
<pre><code>4 4
0 1 1 1
1 1 1 0
0 1 1 0
1 1 0 1
</code></pre>
<h6 id="输出格式-7">输出格式</h6>
<p>一个整数，最大正方形的边长。</p>
<pre><code>2
</code></pre>
<hr>
<h4 id="算法-7">算法</h4>
<h5 id="二维前缀和-枚举长度">二维前缀和 + 枚举长度</h5>
<h5 id="c-代码-7">C++ 代码</h5>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 110;

int n, m;
int s[N][N];

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (int i = 1; i &lt;= n; i ++) {
		for (int j = 1; j &lt;= m; j ++) {
			scanf(&quot;%d&quot;, &amp;s[i][j]);
		}
	}
	// 初始化前缀和矩阵
	for (int i = 1; i &lt;= n; i ++) {
		for (int j = 1; j &lt;= m; j ++) {
			s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];
		}
	}
	// 枚举最大长度
	int res = 0;
	for (int i = 1; i &lt;= n; i ++){
		for (int j = 1; j &lt;= m; j ++) {
			for (int len = 0; i + len &lt;= n &amp;&amp; j + len &lt;= m; len ++) {
				if (s[i + len][j + len] - s[i - 1][j + len] - s[i + len][j - 1] + s[i - 1][j - 1] == (len + 1) * (len + 1)){
					res = max(len + 1, res);
				}
			}
		}
	}           

	printf(&quot;%d\n&quot;, res);
	
	return 0;
}
</code></pre>
<h2 id="每日一题">每日一题</h2>
<h3 id="acwing-3956-截断数组">AcWing 3956. 截断数组</h3>
<p><a href="https://www.acwing.com/problem/content/description/3959/">AcWing 3956. 截断数组</a></p>
<h4 id="题目描述-8">题目描述</h4>
<p>给定一个长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的数组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_1,a_2,…,a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<p>现在，要将该数组从中间截断，得到三个<strong>非空</strong>子数组。</p>
<p>要求，三个子数组内各元素之和都相等。</p>
<p>请问，共有多少种不同的截断方法？</p>
<h4 id="样例-8">样例</h4>
<h6 id="输入格式-8">输入格式</h6>
<p>第一行包含整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>。</p>
<p>第二行包含 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_1,a_2,…,a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<pre><code>4
1 2 3 3
-------
5
1 2 3 4 5
-------
2
0 0
</code></pre>
<h6 id="输出格式-8">输出格式</h6>
<p>输出一个整数，表示截断方法数量。</p>
<pre><code>1
---
0
---
0
</code></pre>
<h6 id="数据范围-6">数据范围</h6>
<p>前六个测试点满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">1≤n≤10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>。<br>
所有测试点满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1≤n≤10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">−</mi><mn>10000</mn><mo>≤</mo><mi>a</mi><mi>i</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">−10000≤ai≤10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>。</p>
<hr>
<h4 id="算法-8">算法</h4>
<h5 id="前缀和-枚举">前缀和 + 枚举</h5>
<ol>
<li>由于要求某一段和，所以使用前缀和进行优化，使其在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 时间内完成操作</li>
<li>要保证能均分为3个部分，所以需要判断总和是否能整除3</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>∗</mo><mn>3</mn><mo>=</mo><mo>=</mo><mi>s</mi><mo>[</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">s[i] * 3 == s[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span> 的意思是，前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个数的和为总和的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mn>3</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>∗</mo><mn>3</mn><mo>=</mo><mo>=</mo><mi>s</mi><mo>[</mo><mi>n</mi><mo>]</mo><mo>∗</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">s[i] * 3 == s[n] * 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的意思是，前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个数的和为总和的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>2</mn><mn>3</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{2}{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
<li>对于每个前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mn>3</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>和的要判断，第二个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mn>3</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>和的坐标时候在其后面</li>
</ol>
<h5 id="c-代码-8">C++ 代码</h5>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

typedef long long LL;

const int N = 100010;

int n;
int s[N];
vector&lt;int&gt; d0, d1;

int main() {
	scanf(&quot;%d&quot;, &amp;n);

	for (int i = 1; i &lt;= n; i ++) {
		scanf(&quot;%d&quot;, &amp;s[i]);
		s[i] += s[i - 1];
	}
	// 枚举 
	LL res = 0;
	if (s[n] % 3 != 0 || n &lt; 3) {
		printf(&quot;0\n&quot;);
	} else {
		for (int i = 1; i &lt;= n - 2; i ++) if (s[i] * 3 == s[n]) d0.push_back(i);
		for (int i = 2; i &lt;= n - 1; i ++) if (s[i] * 3 == s[n] * 2) d1.push_back(i);
		sort(d1.begin(),d1.end(),greater&lt;int&gt;());
		for (int i = 0; i &lt; d0.size() &amp;&amp; d1.size(); i ++) {
			while (d0[i] &gt;= d1.back()) d1.pop_back();
			res += (LL)d1.size();
		}
		printf(&quot;%lld\n&quot;, res);
	}

	return 0;
}
</code></pre>
<h1 id="差分">差分</h1>
<p>Wiki可见  <a href="https://oi-wiki.org/basic/prefix-sum/">前缀和 &amp; 差分</a></p>
<h2 id="一维差分">一维差分</h2>
<p><strong>差分可以看成前缀和的逆运算。</strong></p>
<h3 id="算法思路-3">算法思路</h3>
<ol>
<li>对于数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo separator="true">,</mo><mi>a</mi><mo>[</mo><mn>2</mn><mo>]</mo><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>a</mi><mo>[</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[1],a[2],…,a[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span>，其对应的差分数组为数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo separator="true">,</mo><mi>b</mi><mo>[</mo><mn>2</mn><mo>]</mo><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>b</mi><mo>[</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">b[i],b[2],…,b[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span>（数组a，b的第一项都为0，便于计算前缀和）</li>
<li>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>=</mo><mi>a</mi><mo>[</mo><mn>1</mn><mo>]</mo><mi mathvariant="normal">−</mi><mi>a</mi><mo>[</mo><mn>0</mn><mo>]</mo><mo separator="true">,</mo><mi>b</mi><mo>[</mo><mn>2</mn><mo>]</mo><mo>=</mo><mi>a</mi><mo>[</mo><mn>2</mn><mo>]</mo><mi mathvariant="normal">−</mi><mi>a</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>b</mi><mo>[</mo><mi>n</mi><mo>]</mo><mo>=</mo><mi>a</mi><mo>[</mo><mi>n</mi><mo>]</mo><mi mathvariant="normal">−</mi><mi>a</mi><mo>[</mo><mi>n</mi><mi mathvariant="normal">−</mi><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">b[1]=a[1]−a[0],b[2]=a[2]−a[1],…,b[n]=a[n]−a[n−1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mord">−</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mord">−</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mord">−</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span></span></span></span></li>
<li>我们可以发现<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>b</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>+</mo><mi>b</mi><mo>[</mo><mn>2</mn><mo>]</mo><mo>+</mo><mi>b</mi><mo>[</mo><mn>3</mn><mo>]</mo><mo>+</mo><mo>…</mo><mo>+</mo><mi>b</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[i]=b[1]+b[2]+b[3]+…+b[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord">3</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>
<ul>
<li>即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>求前缀和的结果，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>的差分，<strong>前缀和与差分互为逆运算</strong></li>
</ul>
</li>
</ol>
<p>构造差分数组的步骤:</p>
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>+</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">b[l]+c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> :求前缀和恢复原数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>时，下标<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>以后的每个数都会加上c</li>
</ol>
<pre><code class="language-c++">b[l] += c
// a[l] = b[1] + b[2] + ... + b[l](+c)
// a[l + 1] = b[1] + b[2] + ... + b[l](+c) + b[l + 1]
// a[r] = b[1] + b[2] + ... + b[l](+c) + b[l + 1] ... + b[r]
</code></pre>
<ol start="2">
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>[</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo>]</mo><mi mathvariant="normal">−</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">b[r+1]−c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mord">−</span><span class="mord mathdefault">c</span></span></span></span> ：求前缀和恢复原数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>时，下标<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>以后的每个数不需要加上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>，需要减<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>来抵消</li>
</ol>
<pre><code class="language-c++">b[r + 1] -= c
// a[l] = b[1] + b[2] + ... + b[l](+c)
// a[l + 1] = b[1] + b[2] + ... + b[l](+c) + b[l + 1]
// a[r] = b[1] + b[2] + ... + b[l](+c) + b[l + 1] ... + b[r]
// a[r + 1] = b[1] + b[2] + ... + b[l](+c) + b[l + 1] ... + b[r] + b[r + 1](-c) // 加减相抵
// a[r + 1] = b[1] + b[2] + ... + b[l](+c) + b[l + 1] ... + b[r] + b[r + 1](-c) + b[r + 2] // 加减相抵   
</code></pre>
<h3 id="代码模板-3">代码模板</h3>
<pre><code class="language-c++">// 给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c
void insert(int l, int r, int c) {
    b[l] += c, b[r + 1] -= c;
}
</code></pre>
<h3 id="例题-acwing-797-差分">例题 AcWing 797. 差分</h3>
<p><a href="https://www.acwing.com/problem/content/799/">AcWing 797. 差分</a></p>
<h4 id="题目描述-9">题目描述</h4>
<p>输入一个长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的整数序列。</p>
<p>接下来输入 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 个操作，每个操作包含三个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo separator="true">,</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">l,r,c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span></span></span></span>，表示将序列中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 之间的每个数加上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>。</p>
<p>请你输出进行完所有操作后的序列。</p>
<h4 id="样例-9">样例</h4>
<h6 id="输入格式-9">输入格式</h6>
<p>第一行包含两个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>。</p>
<p>第二行包含 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个整数，表示整数序列。</p>
<p>接下来 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 行，每行包含三个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi mathvariant="normal">，</mi><mi>r</mi><mi mathvariant="normal">，</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">l，r，c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">c</span></span></span></span>，表示一个操作。</p>
<pre><code>6 3
1 2 2 1 2 1
1 3 1
3 5 1
1 6 1
</code></pre>
<h6 id="输出格式-9">输出格式</h6>
<p>共一行，包含 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个整数，表示最终序列。</p>
<h4 id="数据范围-7">数据范围</h4>
<pre><code>3 4 5 3 4 2
</code></pre>
<h6 id="数据范围-8">数据范围</h6>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">1≤n,m≤100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>,<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>l</mi><mo>≤</mo><mi>r</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1≤l≤r≤n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">−</mi><mn>1000</mn><mo>≤</mo><mi>c</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">−1000≤c≤1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>,<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">−</mi><mn>1000</mn><mo>≤</mo><mi mathvariant="normal">整</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">序</mi><mi mathvariant="normal">列</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">元</mi><mi mathvariant="normal">素</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">值</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">−1000≤整数序列中元素的值≤1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord cjk_fallback">整</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">序</span><span class="mord cjk_fallback">列</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">元</span><span class="mord cjk_fallback">素</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">值</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
<hr>
<h4 id="算法-9">算法</h4>
<h5 id="方法名称">方法名称</h5>
<h5 id="c-代码-9">C++ 代码</h5>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 100010;

int n, m;
int a[N], b[N];

void insert(int l, int r, int c) {
	b[l] += c, b[r + 1] -= c;
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);

	for (int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]);

	for (int i = 1; i &lt;= n; i ++) insert(i, i, a[i]);
	// 初始化差分矩阵
	// 在i, i 插入的意思是，b[1] = a[1] - a[0](原本为0), b[2] = -a[1]
	// b[2] = a[2] - a[1], b[3] = - a[2]

	while (m --) {
		// m次操作
		int l, r, c;
		scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;c);
		insert(l, r, c);
	}
	// 使用前缀和还原矩阵a
	for (int i = 1; i &lt;= n; i ++) a[i] = a[i - 1] + b[i];
	// a[i] = b[1] + b[2] + ... + b[i]
	for (int i = 1; i &lt;= n; i ++) printf(&quot;%d &quot;, a[i]);

	return 0;
}
</code></pre>
<h3 id="习题-acwing-100-增减序列">习题 AcWing 100. 增减序列</h3>
<p><a href="https://www.acwing.com/problem/content/102/">AcWing 100. 增减序列</a></p>
<h4 id="题目描述-10">题目描述</h4>
<p>给定一个长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的数列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mn>1</mn><mo separator="true">,</mo><mi>a</mi><mn>2</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>a</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">a1,a2,…,an</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span></span></span></span>，每次可以选择一个区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>，使下标在这个区间内的数都加一或者都减一。</p>
<p>求至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列可能有多少种。</p>
<h4 id="样例-10">样例</h4>
<h6 id="输入格式-10">输入格式</h6>
<p>第一行输入正整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>。</p>
<p>接下来 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 行，每行输入一个整数，第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 行的整数代表 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<pre><code>4
1
1
2
2
</code></pre>
<h6 id="输出格式-10">输出格式</h6>
<p>第一行输出最少操作次数。</p>
<p>第二行输出最终能得到多少种结果。</p>
<pre><code>1
2
</code></pre>
<h6 id="数据范围-9">数据范围</h6>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">0&lt;n≤10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>,<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>&lt;</mo><mn>2147483648</mn></mrow><annotation encoding="application/x-tex">0≤a_i&lt;2147483648</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">1</span><span class="mord">4</span><span class="mord">7</span><span class="mord">4</span><span class="mord">8</span><span class="mord">3</span><span class="mord">6</span><span class="mord">4</span><span class="mord">8</span></span></span></span></p>
<hr>
<h4 id="算法-10">算法</h4>
<h5 id="差分-2">差分</h5>
<p>由于差分矩阵<code>b[i] = a[i] - a[i - 1]</code>，所以<code>a</code>数组所有值一样时，得到<code>b[2] ~ b[n]</code>的值均为0</p>
<p>则题目转化为</p>
<ol>
<li>至少操作多少次，<strong>使得<code>b[2] ~ b[n]</code>的值均为0</strong></li>
<li>在最少的操作次数前提下，<code>b[1]</code>有多少种</li>
</ol>
<p>可分类出如下4种操作（对<code>, b[1], b[n + 1]</code>的影响不同）</p>
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>L</mi><mo separator="true">,</mo><mi>R</mi><mo>≤</mo><mi>N</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2 \le L, R \le N- 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>， 对 不包含左右端点的范围进行操作
<ul>
<li>在<code>b[2] ~ b[n]</code>中某个数 + 1， 某个数 - 1</li>
</ul>
</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>R</mi><mo>≤</mo><mi>N</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">L=1, R \le N - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ， 对只包含左端点的范围进行操作
<ul>
<li><code>b[1]</code> + 1， 让<code>b[2] ~ b[n]</code>中的某个数 - 1</li>
</ul>
</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>L</mi><mo separator="true">,</mo><mi>R</mi><mo>=</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">2 \le L, R = N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> ， 对包含右端点的范围进行操作
<ul>
<li>在<code>b[2] ~ b[n]</code>中某个数 + 1， <code>b[n + 1]</code> - 1</li>
</ul>
</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>R</mi><mo>=</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">L = 1, R = N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>， 对左右两端点都包含的范围进行操作
<ul>
<li><code>b[0]</code> + 1, <code>b[n + 1] </code> - 1，整体 +-1，是无意义的</li>
</ul>
</li>
</ol>
<p>由以上4种（实际3种有效操作）可以得出，首先使用第一种操作，将<code>b[2] ~ b[n]</code> 中 原本负的 + 1， 原本正的 - 1，来得到<code>b[2] ~ b[n]</code>的值均为0的效果，然后剩下的可以使用第二或三种操作，再将<code>b[2] ~ b[n]</code>中剩下的不为0的数变为0。于是</p>
<ul>
<li>至少操作多少次，<strong>使得<code>b[2] ~ b[n]</code>的值均为0</strong>，等价于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>q</mi><mo separator="true">,</mo><mi>p</mi><mo>)</mo><mo>+</mo><mi mathvariant="normal">∣</mi><mi>p</mi><mo>−</mo><mi>q</mi><mi mathvariant="normal">∣</mi><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>p</mi><mo separator="true">,</mo><mi>q</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">min(q, p) + |p - q| = max(p, q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span> ，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo separator="true">,</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p, q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span> 为 <code>b[2] ~ b[n]</code>中 大于0 或小于 0 的数</li>
<li>在最少的操作次数前提下，<code>b[1]</code>有多少种 ： 将得到<code>b[2] ~ b[n]</code>的值均变为0后，仍有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>p</mi><mo>−</mo><mi>q</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|p - q|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord">∣</span></span></span></span> 需要操作，其中只有第2种操作对<code>b[1]</code> 产生影响，所以第2种 第3种操作的分配数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>p</mi><mo>−</mo><mi>q</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">|p - q| + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 种</li>
</ul>
<h5 id="c-代码-10">C++ 代码</h5>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

const int N = 100010;

int n, m;
int a[N];

int main() {
	scanf(&quot;%d&quot;, &amp;n);

	for (int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]);
	// 初始化差分数组
	for (int i = n; i ; i --) a[i] -= a[i - 1];
	LL p = 0, q = 0;
	for (int i = 2; i &lt;= n; i ++) {
		// 统计 b[2] ~ b[n] 中 大于0 小于0 的个数
		if (a[i] &gt; 0) p += a[i];
		else q -= a[i];
	}

	LL mino = max(p, q);
	LL kinds = abs(p - q) + 1ll;
	printf(&quot;%lld\n%lld&quot;, mino, kinds);

	return 0;
}
</code></pre>
<h3 id="习题-洛谷-p4552-incdec-sequence-同acwing-100">习题 洛谷 P4552 IncDec Sequence [同AcWing 100]</h3>
<p><a href="https://www.luogu.com.cn/problem/P4552">洛谷 P4552 IncDec Sequence</a></p>
<h3 id="习题-acwing-101-最高的牛">习题 AcWing 101. 最高的牛</h3>
<p><a href="https://www.acwing.com/problem/content/description/103/">AcWing 101. 最高的牛</a></p>
<h4 id="题目描述-11">题目描述</h4>
<p>有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 头牛站成一行，被编队为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">、</mi><mn>2</mn><mi mathvariant="normal">、</mi><mn>3</mn><mo>…</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">1、2、3…N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord cjk_fallback">、</span><span class="mord">2</span><span class="mord cjk_fallback">、</span><span class="mord">3</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>，每头牛的身高都为整数。</p>
<p>当且仅当两头牛中间的牛身高都比它们矮时，两头牛方可看到对方。</p>
<p>现在，我们只知道其中最高的牛是第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> 头，它的身高是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span> ，剩余牛的身高未知。</p>
<p>但是，我们还知道这群牛之中存在着 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> 对关系，每对关系都指明了某两头牛 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 可以相互看见。</p>
<p>求每头牛的身高的最大可能值是多少。</p>
<h4 id="样例-11">样例</h4>
<h6 id="输入格式-11">输入格式</h6>
<p>第一行输入整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo separator="true">,</mo><mi>P</mi><mo separator="true">,</mo><mi>H</mi><mo separator="true">,</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">N,P,H,M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>，数据用空格隔开。</p>
<p>接下来 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> 行，每行输出两个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>，代表牛 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 和牛 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 可以相互看见，数据用空格隔开。</p>
<pre><code>9 3 5 5
1 3
5 3
4 3
3 7
9 8
</code></pre>
<h6 id="输出格式-11">输出格式</h6>
<p>一共输出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 行数据，每行输出一个整数。</p>
<p>第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 行输出的整数代表第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 头牛可能的最大身高。</p>
<pre><code>5
4
5
3
4
4
5
5
5
</code></pre>
<h6 id="数据范围-10">数据范围</h6>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>5000</mn></mrow><annotation encoding="application/x-tex">1≤N≤5000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>,<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>H</mi><mo>≤</mo><mn>1000000</mn></mrow><annotation encoding="application/x-tex">1≤H≤1000000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>,<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">1≤A,B≤10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>,<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>M</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">0≤M≤10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
<ul>
<li>此题中给出的关系对可能存在重复</li>
</ul>
<hr>
<h4 id="算法-11">算法</h4>
<h5 id="差分-集合去重">差分 + 集合去重</h5>
<ol>
<li>将原来的所有牛的身高赋为最高的牛的身高，然后构造差分数组</li>
<li>每次得到一组关系，表明，<code>i</code> 与<code>j</code> 之间所有的牛的身高都比<code>i</code>与<code>j</code>的身高低，于是将<code>[i + 1, j - 1]</code> 之间的牛的身高都减去1</li>
<li>由于题中给出的关系对可能存在重复， 所以需要用集合来进行判重</li>
<li>操作完毕，求前缀和还原数组</li>
</ol>
<h5 id="c-代码-11">C++ 代码</h5>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;

using namespace std;

typedef pair&lt;int, int&gt; PII;

const int N = 5010;

int n, p, h, m;
int b[N];

void insert(int l, int r, int c) {
	b[l] += c, b[r + 1] -= c;
}

int main() {
	scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;p, &amp;h, &amp;m);
	set&lt;PII&gt; existed;
	for (int i = 1; i &lt;= n; i ++) b[i] = h;
	for (int i = n; i &gt;= 1; i --) b[i] -= b[i - 1];

	while (m --) {
		int i, j;
		scanf(&quot;%d%d&quot;, &amp;i, &amp;j);
		if (i &gt; j) swap(i, j);
		if (!existed.count({i, j})) {
			existed.insert({i, j});
			int l = i + 1, r = j - 1;
			if (l &lt;= r) insert(l, r, -1);
		}
		
	}

	for (int i = 1; i &lt;= n; i ++) b[i] += b[i - 1];
	for (int i = 1; i &lt;= n; i ++) printf(&quot;%d\n&quot;, b[i]);

	return 0;
}
</code></pre>
<h2 id="二维差分">二维差分</h2>
<h3 id="算法思路-4">算法思路</h3>
<p>给定原矩阵<code>a[i][j]</code> 构造 差分矩阵 <code>b[i][j]</code> 使得 <code>a[][]</code> 是<code>b[][]</code> 的二维前缀和矩阵</p>
<p>核心操作： 给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：</p>
<p>当<code>b[x1][y1] += c</code>,二维数组<code>a(x1,y1)</code>右下角的所有元素都会加上<code>c</code>。但是我们只想要右下角到<code>(x2,y2)</code>的矩阵范围加上<code>c</code>，所以<code>b[x2+1][y1] -= c</code>且<code>b[x1][y2+1] -= c</code>，明显有一块减多了，所以<code>b[x2+1][y2+1] += c</code></p>
<h3 id="代码模板-4">代码模板</h3>
<pre><code class="language-c++">// 给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
</code></pre>
<h3 id="例题-acwing-798-差分矩阵">例题 AcWing 798. 差分矩阵</h3>
<p><a href="https://www.acwing.com/problem/content/800/">AcWing 798. 差分矩阵</a></p>
<h4 id="题目描述-12">题目描述</h4>
<p>输入一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 列的整数矩阵，再输入 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span> 个操作，每个操作包含五个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">x_1,y_1,x_2,y_2,c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(x_1,y_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(x_2,y_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>表示一个子矩阵的左上角坐标和右下角坐标。</p>
<p>每个操作都要将选中的子矩阵中的每个元素的值加上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>。</p>
<p>请你将进行完所有操作后的矩阵输出。</p>
<h4 id="样例-12">样例</h4>
<h6 id="输入格式-12">输入格式</h6>
<p>第一行包含整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo separator="true">,</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">n,m,q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>。</p>
<p>接下来 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 行，每行包含 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 个整数，表示整数矩阵。</p>
<p>接下来 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span> 行，每行包含 5 个整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">x_1,y_1,x_2,y_2,c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span></span></span></span>，表示一个操作。</p>
<pre><code>3 4 3
1 2 2 1
3 2 2 1
1 1 1 1
1 1 2 2 1
1 3 2 3 2
3 1 3 4 1
</code></pre>
<h6 id="输出格式-12">输出格式</h6>
<p>共 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 行，每行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 个整数，表示所有操作进行完毕后的最终矩阵。</p>
<pre><code>2 3 4 1
4 3 4 1
2 2 2 2
</code></pre>
<h6 id="数据范围-11">数据范围</h6>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">1≤n,m≤1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>,<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>q</mi><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">1≤q≤100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>x</mi><mn>1</mn></msub><mo>≤</mo><msub><mi>x</mi><mn>2</mn></msub><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1≤x_1≤x_2≤n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>y</mi><mn>1</mn></msub><mo>≤</mo><msub><mi>y</mi><mn>2</mn></msub><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">1≤y_1≤y_2≤m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">−</mi><mn>1000</mn><mo>≤</mo><mi>c</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">−1000≤c≤1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>,<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">−</mi><mn>1000</mn><mo>≤</mo><mi mathvariant="normal">矩</mi><mi mathvariant="normal">阵</mi><mi mathvariant="normal">内</mi><mi mathvariant="normal">元</mi><mi mathvariant="normal">素</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">值</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">−1000≤矩阵内元素的值≤1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord cjk_fallback">矩</span><span class="mord cjk_fallback">阵</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">元</span><span class="mord cjk_fallback">素</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">值</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
<hr>
<h4 id="算法-12">算法</h4>
<h5 id="构造差分矩阵进行操作求前缀和还原矩阵">构造差分矩阵进行操作，求前缀和还原矩阵</h5>
<h5 id="c-代码-12">C++ 代码</h5>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

const int N = 1010;

int n, m, q;
int b[N][N];

void insert(int x1, int y1, int x2, int y2, int c) {
	b[x1][y1] += c, b[x2 + 1][y1] -= c, b[x1][y2 + 1] -= c, b[x2 + 1][y2 + 1] += c;
}

int main() {
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q);

	for (int i = 1; i &lt;= n; i ++) {
		for (int j = 1; j &lt;= m; j ++) {
			int x;
			scanf(&quot;%d&quot;, &amp;x);
			insert(i, j, i, j, x);  // 初始化差分矩阵
		}
	}

	while (q --) {
		// q 次操作
		int x1, y1, x2, y2, c;
		scanf(&quot;%d%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;c);
		insert(x1, y1, x2, y2, c);
	}

	// 求前缀和 还原矩阵
	for (int i = 1; i &lt;= n; i ++) {
		for (int j = 1; j &lt;= m; j ++) {
			b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];
			printf(&quot;%d &quot;, b[i][j]);
		}
		printf(&quot;\n&quot;);
	}

	return 0;
}
</code></pre>
<h3 id="习题-洛谷-p3397-地毯">习题 洛谷 P3397 地毯</h3>
<p><a href="https://www.luogu.com.cn/problem/P3397">洛谷 P3397 地毯</a></p>
<h4 id="题目描述-13">题目描述</h4>
<p>在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n×n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的格子上有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 个地毯。</p>
<p>给出这些地毯的信息，问每个点被多少个地毯覆盖。</p>
<h4 id="样例-13">样例</h4>
<h6 id="输入格式-13">输入格式</h6>
<p>第一行，两个正整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n, m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span></span></span></span>。意义如题所述。</p>
<p>接下来 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>行，每行两个坐标 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>)</mo><mo separator="true">,</mo><mo>(</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(x_1, y_1), (x_2, y_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，代表一块地毯，左上角是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(x_1, y_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，右下角是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(x_2, y_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
<pre><code>5 3
2 2 3 3
3 3 5 5
1 2 1 4
</code></pre>
<h6 id="输出格式-13">输出格式</h6>
<p>输出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>行，每行<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个正整数。</p>
<p>第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 行第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 列的正整数表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 这个格子被多少个地毯覆盖。</p>
<pre><code>0 1 1 1 0
0 1 1 0 0
0 1 2 1 1
0 0 1 1 1
0 0 1 1 1
</code></pre>
<h6 id="数据范围-12">数据范围</h6>
<p>对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>20</mn></mrow><annotation encoding="application/x-tex">20%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span> 的数据，有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>50</mn><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">n≤50, m \le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span>。</p>
<p>对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>100</mn></mrow><annotation encoding="application/x-tex">100%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 的数据，有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">n, m \le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>。</p>
<hr>
<h4 id="算法-13">算法</h4>
<h5 id="构造差分矩阵进行操作求前缀和还原矩阵-2">构造差分矩阵进行操作，求前缀和还原矩阵</h5>
<h5 id="c-代码-13">C++ 代码</h5>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

const int N = 1010;

int n, m;
int b[N][N];

void insert(int x1, int y1, int x2, int y2, int c) {
	b[x1][y1] += c, b[x2 + 1][y1] -= c, b[x1][y2 + 1] -= c, b[x2 + 1][y2 + 1] += c;
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);

	for (int i = 1; i &lt;= n; i ++) {
		for (int j = 1; j &lt;= n; j ++) {
			insert(i, j, i, j, 0);  // 初始化差分矩阵
		}
	}

	while (m --) {
		// q 次操作
		int x1, y1, x2, y2;
		scanf(&quot;%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);
		insert(x1, y1, x2, y2, 1);
	}

	// 求前缀和 还原矩阵
	for (int i = 1; i &lt;= n; i ++) {
		for (int j = 1; j &lt;= n; j ++) {
			b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];
			printf(&quot;%d &quot;, b[i][j]);
		}
		printf(&quot;\n&quot;);
	}

	return 0;
}
</code></pre>
<h1 id="二分">二分</h1>
<p>wiki 可见 <a href="https://oi-wiki.org/basic/binary/">二分</a></p>
<h2 id="二分查找">二分查找</h2>
<h3 id="算法思路-5">算法思路</h3>
<p>二分查找（英语：binary search），也称折半搜索（英语：half-interval search）、对数搜索（英语：logarithmic search），是用来在一个有序数组中查找某一元素的算法。</p>
<ul>
<li>
<p>以在一个升序数组中查找一个数为例。</p>
</li>
<li>
<p>它每次考察数组当前部分的中间元素，如果中间元素刚好是要找的，就结束搜索过程；如果中间元素小于所查找的值，那么左侧的只会更小，不会有所查找的元素，只需到右侧查找；如果中间元素大于所查找的值同理，只需到左侧查找。</p>
</li>
</ul>
<h3 id="代码模板-5">代码模板</h3>
<h4 id="整数二分">整数二分</h4>
<pre><code class="language-c++">bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l &lt; r)
    {
        int mid = l + r &gt;&gt; 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
{
    while (l &lt; r)
    {
        int mid = l + r + 1 &gt;&gt; 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
</code></pre>
<h3 id="例题-acwing-789-数的范围">例题 AcWing 789. 数的范围</h3>
<p><a href="https://www.acwing.com/problem/content/791/">AcWing 789. 数的范围</a></p>
<h4 id="题目描述-14">题目描述</h4>
<p>给定一个按照升序排列的长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的整数数组，以及 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span> 个查询。</p>
<p>对于每个查询，返回一个元素 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的起始位置和终止位置（位置从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 开始计数）。</p>
<p>如果数组中不存在该元素，则返回 <code>-1 -1</code>。</p>
<h4 id="样例-14">样例</h4>
<h6 id="输入格式-14">输入格式</h6>
<p>给定一个按照升序排列的长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的整数数组，以及 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span> 个查询。</p>
<p>对于每个查询，返回一个元素 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的起始位置和终止位置（位置从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 开始计数）。</p>
<p>如果数组中不存在该元素，则返回 <code>-1 -1</code>。</p>
<pre><code>6 3
1 2 2 3 3 4
3
4
5
</code></pre>
<h6 id="输出格式-14">输出格式</h6>
<p>共 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>行，每行包含两个整数，表示所求元素的起始位置和终止位置。</p>
<p>如果数组中不存在该元素，则返回 <code>-1 -1</code>。</p>
<pre><code>3 4
5 5
-1 -1
</code></pre>
<h6 id="数据范围-13">数据范围</h6>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">1≤n≤100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>q</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">1≤q≤10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">1≤k≤10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
<hr>
<h4 id="算法-14">算法</h4>
<h5 id="二分查找左端点-二分查找右端点">二分查找左端点 + 二分查找右端点</h5>
<h5 id="c-代码-14">C++ 代码</h5>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 100010;

int n, q;
int a[N];

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;q);
	for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;a[i]);

	while (q --) {
		int x;
		scanf(&quot;%d&quot;, &amp;x);
		int l = 0, r = n - 1;
		while (l &lt; r) {
			int mid = (l + r) &gt;&gt; 1;
			if (a[mid] &gt;= x) r = mid;
			else l = mid + 1;
		}
		if (a[l] == x) {
			printf(&quot;%d&quot;, r);
			// 二分查找右端点
			r = n - 1;
			while (l &lt; r) {
				int mid = (l + r + 1) &gt;&gt; 1;
				if (a[mid] &lt;= x) l = mid;
				else r = mid - 1;
			}
			printf(&quot; %d\n&quot;, l);
		} else printf(&quot;-1 -1\n&quot;);
		
	}

	return 0;
}
</code></pre>
<h3 id="例题-acwing-113-特殊排序">例题 AcWing 113. 特殊排序</h3>
<p><a href="https://www.acwing.com/problem/content/115/">AcWing 113. 特殊排序</a></p>
<h4 id="题目描述-15">题目描述</h4>
<p>有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 个元素，编号 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>2..</mn><mi>N</mi></mrow><annotation encoding="application/x-tex">1,2..N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>，每一对元素之间的大小关系是确定的，关系具有反对称性，但不具有传递性。</p>
<p><strong>注意</strong>：不存在两个元素大小相等的情况。</p>
<p>也就是说，元素的大小关系是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 个点与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>N</mi><mo>×</mo><mo>(</mo><mi>N</mi><mi mathvariant="normal">−</mi><mn>1</mn><mo>)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{N×(N−1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">×</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mord mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 条有向边构成的任意有向图。</p>
<p>然而，这是一道交互式试题，这些关系不能一次性得知，你必须通过不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10000</mn></mrow><annotation encoding="application/x-tex">10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 次提问来获取信息，每次提问只能了解某两个元素之间的关系。</p>
<p>现在请你把这 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 个元素排成一行，使得每个元素都小于右边与它相邻的元素。</p>
<p>你可以通过我们预设的 bool 函数 compare 来获得两个元素之间的大小关系。</p>
<p>例如，编号为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 的两个元素，如果元素 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 小于元素 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>a</mi><mi>r</mi><mi>e</mi><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">compare(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span> 返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">true</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span></span></span></span>，否则返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">false</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span></span></span></span>。</p>
<p>将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 个元素排好序后，把他们的编号以数组的形式输出，如果答案不唯一，则输出任意一个均可。</p>
<h4 id="样例-15">样例</h4>
<h6 id="输入格式-15">输入格式</h6>
<pre><code>[[0, 1, 0], [0, 0, 0], [1, 1, 0]]
</code></pre>
<h6 id="输出格式-15">输出格式</h6>
<pre><code>[3, 1, 2]
</code></pre>
<h6 id="数据范围-14">数据范围</h6>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">1≤N≤1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
<hr>
<h4 id="算法-15">算法</h4>
<h5 id="二分-插入排序">二分 插入排序</h5>
<pre><code>样例的意思
[[0, 1, 0], 
 [0, 0, 0], 
 [1, 1, 0]]
指的是对于3个数的每组compare
compare（1，1）=0, compare（1，2）=1, compare（1，3）=0
compare（2，1）=0, compare（2，2）=0, compare（2，3）=0
compare（3，1）=1, compare（3，2）=1, compare（3，3）=0
其中 对角线不用看，只看上三角即可
compare（1，2）=1, 1 &lt; 2， compare（1，3）=0， 1 &gt; 3, compare（2，3）=0， 2 &gt; 3
对 1&lt;2, 1&gt;3, 2&gt;3 进行排序
</code></pre>
<p>首先假设vector中有排好序的一组元素：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo separator="true">,</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">a, b, c, d, e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span></span></span></span><br>
现在我们要在vector中插入f，如何确定f的位置？直接二分<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mi>d</mi><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">midd=c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>，如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>&gt;</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">f&gt;c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi mathvariant="normal">，</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">c，e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">e</span></span></span></span>之间，反之在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">，</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">a，c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">c</span></span></span></span>之间。</p>
<h5 id="c-代码-15">C++ 代码</h5>
<pre><code class="language-c++">// Forward declaration of compare API.
// bool compare(int a, int b);
// return bool means whether a is less than b.

class Solution {
public:
    vector&lt;int&gt; specialSort(int N) { //N表示N个数，分别为1~N
        vector&lt;int&gt; res;  //用于排序的vector
        res.push_back(1);  // 先将1插入，后面的元素可以和1进行比较
        for (int i = 2; i &lt;= N; i ++) {
        	int l = 0, r = res.size() - 1;
        	while(l &lt; r) {
        		int mid = (l + r + 1) &gt;&gt; 1;
        		if (compare(res[mid], i)) l = mid;
        		else r = mid - 1;
        	}
        	res.push_back(i);
        	for (int j = res.size() - 2; j &gt; r; j --) swap(res[j], res[j + 1]);
        	if (compare(i, res[r])) swap(res[r], res[r + 1]);
        }
        return res;
    }
};
</code></pre>
<h3 id="习题-洛谷-p2249-查找">习题 洛谷 P2249 查找</h3>
<p><a href="https://www.luogu.com.cn/problem/P2249">洛谷 P2249 查找</a></p>
<h4 id="题目描述-16">题目描述</h4>
<p>输入 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span> 的单调不减的（就是后面的数字不小于前面的数字）非负整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_1, a_2, ...,a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，然后进行<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>次询问。对于每次询问，给出一个整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>，要求输出这个数字在序列中第一次出现的编号，如果没有找到的话输出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> 。</p>
<h4 id="样例-16">样例</h4>
<h6 id="输入格式-16">输入格式</h6>
<p>第一行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>，表示数字个数和询问次数。</p>
<p>第二行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个整数，表示这些待查询的数字。</p>
<p>第三行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 个整数，表示询问这些数字的编号，从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 开始编号。</p>
<pre><code>11 3
1 3 3 3 5 7 9 11 13 15 15
1 3 6
</code></pre>
<h6 id="输出格式-16">输出格式</h6>
<p>输出一行，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 个整数，以空格隔开，表示答案。</p>
<pre><code>1 2 -1 
</code></pre>
<h6 id="数据范围-15">数据范围</h6>
<p>数据保证，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">1≤n≤10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>q</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">0≤a_i, q≤10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1≤m≤10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></p>
<p>本题输入输出量较大，请使用较快的 IO 方式。</p>
<hr>
<h4 id="算法-16">算法</h4>
<h5 id="二分-2">二分</h5>
<h5 id="c-代码-16">C++ 代码</h5>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 1000010;

int n, m;
int a[N];

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]);

	while (m --) {
		int x;
		scanf(&quot;%d&quot;, &amp;x);
		int l = 1, r = n;
		while (l &lt; r) {
			int mid = (l + r) &gt;&gt; 1;
			if (a[mid] &gt;= x) r = mid;
			else l = mid + 1;
		}
		if (a[l] == x) printf(&quot;%d &quot;, l);
		else printf(&quot;-1 &quot;);
	}

	return 0;
}
</code></pre>
<h2 id="实数域二分">实数域二分</h2>
<h3 id="算法思路-6">算法思路</h3>
<p>如果要在实数域内进行二分查找（比如求一个定义域为非无穷集的函数的零点），也可以利用二分查找，但不像整数，按照「取中间值」的方法是可以无限递归下去的，因此我们可以根据题目的要求设定一个精度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ε</mi></mrow><annotation encoding="application/x-tex">ε</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ε</span></span></span></span>（例如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ε</mi><mo>=</mo><mn>0.00001</mn></mrow><annotation encoding="application/x-tex">ε=0.00001</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ε</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span></span></span></span>），如果差小于精度则视为相等，不再递归。</p>
<h3 id="代码模板-6">代码模板</h3>
<h4 id="浮点数二分">浮点数二分</h4>
<pre><code class="language-c++">bool check(double x) {/* ... */} // 检查x是否满足某种性质

double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l &gt; eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
</code></pre>
<h3 id="例题-acwing-790-数的三次方根">例题 AcWing 790. 数的三次方根</h3>
<p><a href="https://www.acwing.com/problem/content/792/">AcWing 790. 数的三次方根</a></p>
<h4 id="题目描述-17">题目描述</h4>
<p>给定一个浮点数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，求它的三次方根。</p>
<h4 id="样例-17">样例</h4>
<h6 id="输入格式-17">输入格式</h6>
<p>共一行，包含一个浮点数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>。</p>
<pre><code>1000.00
</code></pre>
<h6 id="输出格式-17">输出格式</h6>
<p>共一行，包含一个浮点数，表示问题的解。</p>
<p>注意，结果保留 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span> 位小数。</p>
<pre><code>10.000000
</code></pre>
<h6 id="数据范围-16">数据范围</h6>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">−</mi><mn>10000</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">−10000≤n≤10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
<hr>
<h4 id="算法-17">算法</h4>
<h5 id="方法名称-2">方法名称</h5>
<h5 id="c-代码-17">C++ 代码</h5>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

double n;

int main() {
	scanf(&quot;%lf&quot;, &amp;n);

	double l = -100, r = 100;  // 根据数据范围10000来定
	while ((r - l) &gt; 1e-7) {
		double mid = (l + r) / 2;
		if (mid * mid * mid &lt;= n) l = mid;
		else r = mid;
	}
	printf(&quot;%.6lf\n&quot;, l);

	return 0;
}
</code></pre>
<h3 id="习题-洛谷-p1024-一元三次方程求解">习题 洛谷 P1024 一元三次方程求解</h3>
<p><a href="https://www.luogu.com.cn/problem/P1024">洛谷 P1024 一元三次方程求解</a></p>
<h4 id="题目描述-18">题目描述</h4>
<p>有形如：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mi>b</mi><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mi>c</mi><mi>x</mi><mo>+</mo><mi>d</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">ax^3+ bx^2 + cx + d = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 这样的一个一元三次方程。给出该方程中各项的系数（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">a, b, c, d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span></span></span></span>均为实数），并约定该方程存在三个不同实根（根的范围在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">−</mi><mn>100</mn></mrow><annotation encoding="application/x-tex">−100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 至 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>100</mn></mrow><annotation encoding="application/x-tex">100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 之间），且根与根之差的绝对值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">≥1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。要求由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后 22 位。</p>
<p>提示：记方程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(x)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，若存在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 个数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_1 &lt; x_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>)</mo><mo>⋅</mo><mi>f</mi><mo>(</mo><msub><mi>x</mi><mn>2</mn></msub><mo>)</mo><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(x_1)\cdot f(x_2) &lt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，则在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(x_1, x_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 之间一定有一个根。</p>
<h4 id="样例-18">样例</h4>
<h6 id="输入格式-18">输入格式</h6>
<p>一行，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>个实数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">a, b, c, d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span></span></span></span></p>
<pre><code>1 -5 -4 20
</code></pre>
<h6 id="输出格式-18">输出格式</h6>
<p>一行，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 个实根，从小到大输出，并精确到小数点后 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 位。</p>
<pre><code>-2.00 2.00 5.00
</code></pre>
<hr>
<h4 id="算法-18">算法</h4>
<h5 id="二分-3">二分</h5>
<p>由于题目中给出，<strong>根与根之差的绝对值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">≥1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></strong>，于是在每个长度为1的区间内，只能存在一个点，且根的数据范围在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mo>−</mo><mn>100</mn><mo separator="true">,</mo><mn>100</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[-100,100]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 之间，只要从100，开始不断枚举长度为1的区间即可</p>
<h5 id="c-代码-18">C++ 代码</h5>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

double a, b, c, d;

double get(double x) {
	return a * x * x * x + b * x * x + c * x + d;
}

int main() {
	scanf(&quot;%lf%lf%lf%lf&quot;, &amp;a, &amp;b, &amp;c, &amp;d);
	// 首先找最小的
	for (double i = -100; i &lt; 100; i++) {
		double l = i, r = i + 1, mid = 0;
		if (get(l) == 0) {
			printf(&quot;%.2lf &quot;, l);
			continue;
		}
		if (get(l) * get(r) &lt; 0) {
			// 区间中存在一个根
			while (r - l &gt; 1e-4) {
				double mid = (l + r) / 2;
				if (get(mid) * get(l) &lt;= 0) r = mid;
				else l = mid;
			}
			printf(&quot;%.2lf &quot;, l);
		}
	}

	return 0;
}
</code></pre>
<h2 id="二分答案">二分答案</h2>
<blockquote>
<p>对一个满足单调性质的问题，我们可以采用二分答案的方法来解决。</p>
</blockquote>
<p>解题的时候往往会考虑枚举答案然后检验枚举的值是否正确。若<strong>满足单调性，则满足使用二分法的条件</strong>。把这里的枚举换成二分，就变成了「二分答案」。</p>
<h3 id="算法思路-7">算法思路</h3>
<p>一般二分可解决的问题都是极值相关的问题（求某个量的最大/小值），这个时候我们可以二分这个量可能取的范围 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>，每次取这个范围的中点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>=</mo><mfrac><mrow><mi>l</mi><mo>+</mo><mi>r</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">m=\frac{l + r}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 检测。</p>
<ul>
<li>若检测通过（即这个量可以取这个值），则继续递归尝试区间的后半段；</li>
<li>若检测不通过，则更大的数显然不可能，此时递归尝试区间的前半段。</li>
<li>需要注意，可以二分答案的题必须满足单调性。</li>
</ul>
<h3 id="例题-acwing-102-最佳牛围栏">例题 AcWing 102. 最佳牛围栏</h3>
<p><a href="https://www.acwing.com/problem/content/104/">AcWing 102. 最佳牛围栏</a></p>
<h4 id="题目描述-19">题目描述</h4>
<p>农夫约翰的农场由 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 块田地组成，每块地里都有一定数量的牛，其数量不会少于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 头，也不会超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2000</mn></mrow><annotation encoding="application/x-tex">2000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 头。</p>
<p>约翰希望用围栏将一部分连续的田地围起来，并使得围起来的区域内每块地包含的牛的数量的平均值达到最大。</p>
<p>围起区域内至少需要包含 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span> 块地，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span> 会在输入中给出。</p>
<p>在给定条件下，计算围起区域内每块地包含的牛的数量的平均值可能的最大值是多少。</p>
<h4 id="样例-19">样例</h4>
<h6 id="输入格式-19">输入格式</h6>
<p>第一行输入整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span>，数据间用空格隔开。</p>
<p>接下来 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 行，每行输入一个整数，第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 行输入的整数代表第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 片区域内包含的牛的数目。</p>
<pre><code>10 6
6 
4
2
10
3
8
5
9
4
1
</code></pre>
<h6 id="输出格式-19">输出格式</h6>
<p>输出一个整数，表示平均值的最大值乘以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1000</mn></mrow><annotation encoding="application/x-tex">1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 再 <strong>向下取整</strong> 之后得到的结果。</p>
<pre><code>6500
</code></pre>
<h6 id="数据范围-17">数据范围</h6>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">1≤N≤100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>F</mi><mo>≤</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">1≤F≤N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></p>
<hr>
<h4 id="算法-19">算法</h4>
<h5 id="二分-前缀和-双指针">二分 + 前缀和 + 双指针</h5>
<p>答案可二分性</p>
<p>在原序列中是否存在一段，它的平均值大于等于mid</p>
<ol>
<li>将各个元素减去mid之后，得到一个新的序列</li>
<li>在新的序列中，是否存在一个长度大于等于F的子序列，它的和是非负的</li>
<li>使用前缀和处理，<code>s[j] - s[i] &gt;= 0</code> 转化为 <code>s[j] &gt;= s[i]</code>， 其中 <code>i</code>是要小于<code>j - F</code>，找出满足条件的<code>s[i]</code> 最小值</li>
</ol>
<h5 id="c-代码-19">C++ 代码</h5>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 100010;

int n, f;
double a[N], s[N];  // 存储前缀和

bool check(double avg) {
	// 处理均值与前缀和
	for (int i = 1; i &lt;= n; i ++) s[i] = s[i - 1] + a[i] - avg;
	double minv = 0;
	for (int i = 0, j = f; j &lt;= n; i ++, j ++) {
		minv = min(minv, s[i]);  // 
		if (s[j] &gt;= minv) return true;  // s[j] &gt;= 前缀最小值，则可以达成
	}
	return false;
}


int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;f);
	double l = 0, r = 0;
	for (int i = 1; i &lt;= n; i ++) {
		scanf(&quot;%lf&quot;, &amp;a[i]);
		r = max(r, a[i]);
	}
	
	while ((r - l) &gt; 1e-5) {
		double mid = (l + r) / 2;
		if (check(mid)) l = mid;
		else r = mid;
	}
	printf(&quot;%d\n&quot;, (int) (r * 1000));

	return 0;
}
</code></pre>
<h3 id="习题-洛谷-p1873-砍树">习题 洛谷 P1873 砍树</h3>
<p><a href="https://www.luogu.com.cn/problem/P1873">洛谷 P1873 砍树</a></p>
<h4 id="题目描述-20">题目描述</h4>
<p>伐木工人 Mirko 需要砍 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> 米长的木材。对 Mirko 来说这是很简单的工作，因为他有一个漂亮的新伐木机，可以如野火一般砍伐森林。不过，Mirko 只被允许砍伐一排树。</p>
<p>Mirko 的伐木机工作流程如下：Mirko 设置一个高度参数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span>（米），伐木机升起一个巨大的锯片到高度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span>，并锯掉所有树比 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span> 高的部分（当然，树木不高于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span> 米的部分保持不变）。Mirko 就得到树木被锯下的部分。例如，如果一排树的高度分别为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>20</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>17</mn></mrow><annotation encoding="application/x-tex">20, 15, 10, 17</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">7</span></span></span></span>，Mirko 把锯片升到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>15</mn></mrow><annotation encoding="application/x-tex">15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span>米的高度，切割后树木剩下的高度将是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>15</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>15</mn></mrow><annotation encoding="application/x-tex">15, 15, 10, 15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span>，而 Mirko 将从第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 棵树得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 米，从第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 棵树得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 米，共得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span> 米木材。</p>
<p>Mirko 非常关注生态保护，所以他不会砍掉过多的木材。这也是他尽可能高地设定伐木机锯片的原因。请帮助 Mirko 找到伐木机锯片的最大的整数高度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span>，使得他能得到的木材至少为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>米。换句话说，如果再升高 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 米，他将得不到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>米木材。</p>
<h4 id="样例-20">样例</h4>
<h6 id="输入格式-20">输入格式</h6>
<p>第 1 行 2 个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 表示树木的数量，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> 表示需要的木材总长度。</p>
<p>第 2 行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 个整数表示每棵树的高度。</p>
<pre><code>4 7
20 15 10 17
-----------
5 20
4 42 40 26 46
</code></pre>
<h6 id="输出格式-20">输出格式</h6>
<p>1 个整数，表示锯片的最高高度。</p>
<pre><code>15
--
36
</code></pre>
<h6 id="数据范围-18">数据范围</h6>
<p>对于 100% 的测试数据，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">1≤N≤10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>M</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">1≤M≤2×10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>，树的高度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">&lt;10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>，所有树的高度总和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>。</p>
<hr>
<h4 id="算法-20">算法</h4>
<h5 id="方法名称-3">方法名称</h5>
<h5 id="c-代码-20">C++ 代码</h5>
<pre><code class="language-c++">
</code></pre>
<h3 id="习题-洛谷-p2678-跳石头">习题 洛谷 P2678 跳石头</h3>
<p><a href="https://www.luogu.com.cn/problem/P2678">洛谷 P2678 跳石头</a></p>
<h4 id="题目描述-21">题目描述</h4>
<p>这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。</p>
<p>为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> 块岩石（不能移走起点和终点的岩石）。</p>
<h4 id="样例-21">样例</h4>
<h6 id="输入格式-21">输入格式</h6>
<p>第一行包含三个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo separator="true">,</mo><mi>N</mi><mo separator="true">,</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">L,N,M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">l \ge 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>≥</mo><mi>M</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">N \ge M \ge 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</p>
<p>接下来 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 行，每行一个整数，第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 行的整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub><mo>(</mo><mn>0</mn><mo>&lt;</mo><msub><mi>D</mi><mi>i</mi></msub><mo>&lt;</mo><mi>L</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">D_i(0 &lt; D_i &lt; L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mclose">)</span></span></span></span>， 表示第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置。</p>
<p>将与起点距离为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>14</mn></mrow><annotation encoding="application/x-tex">14</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">4</span></span></span></span> 的两个岩石移走后,最短的跳跃距离为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>(从与起点距离 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>17</mn></mrow><annotation encoding="application/x-tex">17</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">7</span></span></span></span> 的岩石跳到距离 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>21</mn></mrow><annotation encoding="application/x-tex">21</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">1</span></span></span></span> 的岩石,或者从距离 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>21</mn></mrow><annotation encoding="application/x-tex">21</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">1</span></span></span></span> 的岩石跳到终点)。</p>
<pre><code>25 5 2 
2
11
14
17 
21
</code></pre>
<h6 id="输出格式-21">输出格式</h6>
<p>一个整数，即最短跳跃距离的最大值。</p>
<pre><code>4
</code></pre>
<h6 id="数据范围-19">数据范围</h6>
<p>对于 20%的数据，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>M</mi><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">0≤M≤N≤10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span><br>
对于 50% 的数据，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>M</mi><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">0≤M≤N≤100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span>。<br>
对于 100%的数据，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>M</mi><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>50000</mn><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><mi>L</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">0≤M≤N≤50000, 1 \le L \le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>。</p>
<hr>
<h4 id="算法-21">算法</h4>
<h5 id="方法名称-4">方法名称</h5>
<h5 id="c-代码-21">C++ 代码</h5>
<pre><code class="language-c++">
</code></pre>
<h1 id="双指针">双指针</h1>
<h3 id="例题-acwing-799-最长连续不重复子序列">例题 AcWing 799. 最长连续不重复子序列</h3>
<p><a href="https://www.acwing.com/problem/content/801/">AcWing 799. 最长连续不重复子序列</a></p>
<h4 id="题目描述-22">题目描述</h4>
<p>给定一个长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。</p>
<h4 id="样例-22">样例</h4>
<h6 id="输入格式-22">输入格式</h6>
<p>第一行包含整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>。</p>
<p>第二行包含 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个整数（均在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>∼</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">0∼10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span> 范围内），表示整数序列。</p>
<pre><code>5
1 2 2 3 5
</code></pre>
<h6 id="输出格式-22">输出格式</h6>
<p>共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。</p>
<pre><code>3
</code></pre>
<h6 id="数据范围-20">数据范围</h6>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1≤n≤10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></p>
<hr>
<h4 id="算法-22">算法</h4>
<h5 id="方法名称-5">方法名称</h5>
<h5 id="c-代码-22">C++ 代码</h5>
<pre><code class="language-c++">
</code></pre>
<h3 id="例题-acwing-800-数组元素的目标和">例题 AcWing 800. 数组元素的目标和</h3>
<p><a href="https://www.acwing.com/problem/content/802/">AcWing 800. 数组元素的目标和</a></p>
<h4 id="题目描述-23">题目描述</h4>
<p>给定两个升序排序的有序数组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>，以及一个目标值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>。</p>
<p>数组下标从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 开始。</p>
<p>请你求出满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>+</mo><mi>B</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">A[i]+B[j]=x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的数对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>。</p>
<p>数据保证有唯一解。</p>
<h4 id="样例-23">样例</h4>
<h6 id="输入格式-23">输入格式</h6>
<p>第一行包含三个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo separator="true">,</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">n,m,x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span></span></span></span>，分别表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 的长度，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 的长度以及目标值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>。</p>
<p>第二行包含 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个整数，表示数组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>。</p>
<p>第三行包含 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 个整数，表示数组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>。</p>
<pre><code>4 5 6
1 2 4 7
3 4 6 8 9
</code></pre>
<h6 id="输出格式-23">输出格式</h6>
<p>共一行，包含两个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>。</p>
<pre><code>1 1
</code></pre>
<h6 id="数据范围-21">数据范围</h6>
<p>数组长度不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>。<br>
同一数组内元素各不相同。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">元</mi><mi mathvariant="normal">素</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">1≤数组元素≤10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">元</span><span class="mord cjk_fallback">素</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></p>
<hr>
<h4 id="算法-23">算法</h4>
<h5 id="方法名称-6">方法名称</h5>
<h5 id="c-代码-23">C++ 代码</h5>
<pre><code class="language-c++">
</code></pre>
<h3 id="例题-acwing-2816-判断子序列">例题 AcWing 2816. 判断子序列</h3>
<p><a href="https://www.acwing.com/problem/content/2818/">AcWing 2816. 判断子序列</a></p>
<h4 id="题目描述-24">题目描述</h4>
<p>给定一个长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的整数序列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_1,a_2,…,a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 以及一个长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的整数序列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>b</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">b_1,b_2,…,b_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<p>请你判断 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 序列是否为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 序列的子序列。</p>
<p>子序列指序列的一部分项按<strong>原有次序排列</strong>而得的序列，例如序列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">{a_1,a_3,a_5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 是序列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>4</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">{a_1,a_2,a_3,a_4,a_5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 的一个子序列。</p>
<h4 id="样例-24">样例</h4>
<h6 id="输入格式-24">输入格式</h6>
<p>第一行包含两个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n,m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span></span></span></span>。</p>
<p>第二行包含 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个整数，表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_1,a_2,…,a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<p>第三行包含 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 个整数，表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>b</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">b_1,b_2,…,b_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<pre><code>3 5
1 3 5
1 2 3 4 5
</code></pre>
<h6 id="输出格式-24">输出格式</h6>
<p>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 序列是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 序列的子序列，输出一行 <code>Yes</code>。</p>
<p>否则，输出 <code>No</code>。</p>
<pre><code>Yes
</code></pre>
<h6 id="数据范围-22">数据范围</h6>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1≤n≤m≤10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>,<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">−</mi><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>≤</mo><mi>a</mi><mi>i</mi><mo separator="true">,</mo><mi>b</mi><mi>i</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">−10^9≤ai,bi≤10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></p>
<hr>
<h4 id="算法-24">算法</h4>
<h5 id="方法名称-7">方法名称</h5>
<h5 id="c-代码-24">C++ 代码</h5>
<pre><code class="language-c++">
</code></pre>
<h3 id="例题-acwing-1238-日志统计">例题 AcWing 1238. 日志统计</h3>
<p><a href="https://www.acwing.com/problem/content/1240/">AcWing 1238. 日志统计</a></p>
<h4 id="题目描述-25">题目描述</h4>
<p>小明维护着一个程序员论坛。现在他收集了一份”点赞”日志，日志共有 N 行。</p>
<p>其中每一行的格式是：</p>
<pre><code>ts id  
</code></pre>
<p>表示在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">ts</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span></span></span></span>时刻编号 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">id</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span>的帖子收到一个”赞”。</p>
<p>现在小明想统计有哪些帖子曾经是”热帖”。</p>
<p>如果一个帖子曾在任意一个长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span> 的时间段内收到不少于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 个赞，小明就认为这个帖子曾是”热帖”。</p>
<p>具体来说，如果存在某个时刻 T 满足该帖在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>T</mi><mo separator="true">,</mo><mi>T</mi><mo>+</mo><mi>D</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">[T,T+D)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mclose">)</span></span></span></span> 这段时间内(注意是左闭右开区间)收到不少于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>个赞，该帖就曾是”热帖”。</p>
<p>给定日志，请你帮助小明统计出所有曾是”热帖”的帖子编号。</p>
<h4 id="样例-25">样例</h4>
<h6 id="输入格式-25">输入格式</h6>
<p>第一行包含三个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo separator="true">,</mo><mi>D</mi><mo separator="true">,</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">N,D,K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>。</p>
<p>以下 N 行每行一条日志，包含两个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">ts</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">id</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span>。</p>
<pre><code>7 10 2
0 1
0 10
10 10
10 1
9 1
100 3
100 3
</code></pre>
<h6 id="输出格式-25">输出格式</h6>
<p>按从小到大的顺序输出热帖 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">id</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span>。</p>
<p>每个 id 占一行。</p>
<pre><code>1
3
</code></pre>
<h6 id="数据范围-23">数据范围</h6>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>K</mi><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1≤K≤N≤10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>t</mi><mi>s</mi><mo separator="true">,</mo><mi>i</mi><mi>d</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">0≤ts,id≤10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>D</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">1≤D≤10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
<hr>
<h4 id="算法-25">算法</h4>
<h5 id="方法名称-8">方法名称</h5>
<h5 id="c-代码-25">C++ 代码</h5>
<pre><code class="language-c++">
</code></pre>
<h3 id="例题-acwing-1240-完全二叉树的权值">例题 AcWing 1240. 完全二叉树的权值</h3>
<p><a href="https://www.acwing.com/problem/content/1242/">AcWing 1240. 完全二叉树的权值</a></p>
<h4 id="题目描述-26">题目描述</h4>
<p>给定一棵包含 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 个节点的完全二叉树，树上每个节点都有一个权值，按从上到下、从左到右的顺序依次是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>⋅</mo><mo>⋅</mo><mo>⋅</mo><msub><mi>A</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">A_1,A_2,⋅⋅⋅A_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord">⋅</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，如下图所示：</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.acwing.com/media/article/image/2019/12/05/19_2f0cae5817-QQ%E6%88%AA%E5%9B%BE20191205124611.png" alt="QQ截图20191205124611.png" loading="lazy"></figure>
<p>现在小明要把相同深度的节点的权值加在一起，他想知道哪个深度的节点权值之和最大？</p>
<p>如果有多个深度的权值和同为最大，请你输出其中最小的深度。</p>
<p>注：根的深度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 。</p>
<h4 id="样例-26">样例</h4>
<h6 id="输入格式-26">输入格式</h6>
<p>第一行包含一个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>。</p>
<p>第二行包含 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>⋅</mo><mo>⋅</mo><mo>⋅</mo><msub><mi>A</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">A_1,A_2,⋅⋅⋅A_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord">⋅</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<pre><code>7
1 6 5 4 3 2 1
</code></pre>
<h6 id="输出格式-26">输出格式</h6>
<p>输出一个整数代表答案。</p>
<pre><code>2
</code></pre>
<h6 id="数据范围-24">数据范围</h6>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1≤N≤10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">−</mi><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo>≤</mo><mi>A</mi><mi>i</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">−10^5≤Ai≤10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></p>
<hr>
<h4 id="算法-26">算法</h4>
<h5 id="方法名称-9">方法名称</h5>
<h5 id="c-代码-26">C++ 代码</h5>
<pre><code class="language-c++">
</code></pre>
<h1 id="模板">模板</h1>
<h4 id="题目描述-27">题目描述</h4>
<h4 id="样例-27">样例</h4>
<h6 id="输入格式-27">输入格式</h6>
<pre><code>
</code></pre>
<h6 id="输出格式-27">输出格式</h6>
<pre><code>
</code></pre>
<h6 id="数据范围-25">数据范围</h6>
<hr>
<h4 id="算法-27">算法</h4>
<h5 id="方法名称-10">方法名称</h5>
<h5 id="c-代码-27">C++ 代码</h5>
<pre><code class="language-c++">
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CodeForces Training]]></title>
        <id>https://CNZedChou.github.io/post/codeforces-training/</id>
        <link href="https://CNZedChou.github.io/post/codeforces-training/">
        </link>
        <updated>2023-02-01T15:53:15.000Z</updated>
        <summary type="html"><![CDATA[<p>@Description:   用于CodeForces上的学习过程<br>
@Author:    Zed Chou<br>
@LastModified:    Fri 3 Feb 2023</p>
]]></summary>
        <content type="html"><![CDATA[<p>@Description:   用于CodeForces上的学习过程<br>
@Author:    Zed Chou<br>
@LastModified:    Fri 3 Feb 2023</p>
<!-- more -->
<h1 id="800">800</h1>
<h2 id="4a-watermelon">4A Watermelon</h2>
<p><a href="https://codeforces.com/problemset/problem/4/A">4A Watermelon</a></p>
<blockquote>
<p>Date: Feb/01/2023</p>
</blockquote>
<p>One hot summer day Pete and his friend Billy decided to buy a watermelon. They chose the biggest and the ripest one, in their opinion. After that the watermelon was weighed, and the scales showed <em>w</em> kilos. They rushed home, dying of thirst, and decided to divide the berry, however they faced a hard problem.</p>
<p>Pete and Billy are great fans of even numbers, that's why they want to divide the watermelon in such a way that each of the two parts weighs even number of kilos, at the same time it is not obligatory that the parts are equal. The boys are extremely tired and want to start their meal as soon as possible, that's why you should help them and find out, if they can divide the watermelon in the way they want. For sure, each of them should get a part of positive weight.</p>
<p>Input</p>
<p>The first (and the only) input line contains integer number <em>w</em> (1 ≤ <em>w</em> ≤ 100) — the weight of the watermelon bought by the boys.</p>
<p>Output</p>
<p>Print YES, if the boys can divide the watermelon into two parts, each of them weighing even number of kilos; and NO in the opposite case.</p>
<p>Sample 1</p>
<table>
<thead>
<tr>
<th>Inputcopy</th>
<th>Outputcopy</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>8 </code></td>
<td><code>YES </code></td>
</tr>
</tbody>
</table>
<p>Note</p>
<p>For example, the boys can divide the watermelon into two parts of 2 and 6 kilos respectively (another variant — two parts of 4 and 4 kilos).</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;

using namespace std;

int main() {
	int w;
	scanf(&quot;%d&quot;, &amp;w);

	if (w % 2 == 0 &amp;&amp; w != 2) {
		// 偶数
		printf(&quot;YES&quot;);
	} else {
		printf(&quot;NO&quot;);
	}

	return 0;
}
</code></pre>
<h2 id="9a-die-roll">9A Die Roll</h2>
<p><a href="https://codeforces.com/problemset/problem/9/A">9A Die Roll</a></p>
<blockquote>
<p>Date: Feb/02/2023</p>
</blockquote>
<p>Yakko, Wakko and Dot, world-famous animaniacs, decided to rest from acting in cartoons, and take a leave to travel a bit. Yakko dreamt to go to Pennsylvania, his Motherland and the Motherland of his ancestors. Wakko thought about Tasmania, its beaches, sun and sea. Dot chose Transylvania as the most mysterious and unpredictable place.</p>
<p>But to their great regret, the leave turned to be very short, so it will be enough to visit one of the three above named places. That's why Yakko, as the cleverest, came up with a truly genius idea: let each of the three roll an ordinary six-sided die, and the one with the highest amount of points will be the winner, and will take the other two to the place of his/her dreams.</p>
<p>Yakko thrown a die and got Y points, Wakko — W points. It was Dot's turn. But she didn't hurry. Dot wanted to know for sure what were her chances to visit Transylvania.</p>
<p>It is known that Yakko and Wakko are true gentlemen, that's why if they have the same amount of points with Dot, they will let Dot win.</p>
<p>Input</p>
<p>The only line of the input file contains two natural numbers Y and W — the results of Yakko's and Wakko's die rolls.</p>
<p>Output</p>
<p>Output the required probability in the form of irreducible fraction in format «A/B», where A — the numerator, and B — the denominator. If the required probability equals to zero, output «0/1». If the required probability equals to 1, output «1/1».</p>
<p>Sample 1</p>
<table>
<thead>
<tr>
<th>Inputcopy</th>
<th>Outputcopy</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>4 2 </code></td>
<td><code>1/2 </code></td>
</tr>
</tbody>
</table>
<p>Note</p>
<p>Dot will go to Transylvania, if she is lucky to roll 4, 5 or 6 points.</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;

using namespace std;


int y, w;
int main() {
	scanf(&quot;%d%d&quot;, &amp;y, &amp;w);

	int res;
	res = 7 - max(y, w);

	int denominator = 6;
	for (int i = 2; i &lt;= 3; i ++) {
		if (res % i == 0 &amp;&amp; denominator % i == 0) res /= i, denominator /= i;
	}
	printf(&quot;%d/%d\n&quot;, res, denominator);

	return 0;
}
</code></pre>
<h2 id="12a-super-agent">12A Super Agent</h2>
<p><a href="https://codeforces.com/problemset/problem/12/A">Super Agent</a></p>
<blockquote>
<p>Date: Feb/02/2023</p>
</blockquote>
<p>There is a very secret base in Potatoland where potato mash is made according to a special recipe. The neighbours from Porridgia decided to seize this recipe and to sell it to Pilauland. For this mission they have been preparing special agent Pearlo for many years. When, finally, Pearlo learned all secrets of espionage, he penetrated into the Potatoland territory and reached the secret base.</p>
<p>Now he is standing at the entrance, but to get inside he need to pass combination lock. Minute ago one of the workers entered the password on the terminal and opened the door. The terminal is a square digital keyboard 3 × 3 with digits from 1 to 9.</p>
<p>Pearlo knows that the password consists from distinct digits and is probably symmetric with respect to the central button of the terminal. He has heat sensor which allowed him to detect the digits which the worker pressed. Now he wants to check whether the password entered by the worker is symmetric with respect to the central button of the terminal. This fact can Help Pearlo to reduce the number of different possible password combinations.</p>
<p>Input</p>
<p>Input contains the matrix of three rows of three symbols each. Symbol «X» means that the corresponding button was pressed, and «.» means that is was not pressed. The matrix may contain no «X», also it may contain no «.».</p>
<p>Output</p>
<p>Print YES if the password is symmetric with respect to the central button of the terminal and NO otherwise.</p>
<p>Sample 1</p>
<table>
<thead>
<tr>
<th>Inputcopy</th>
<th>Outputcopy</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>XX. ... .XX </code></td>
<td><code>YES </code></td>
</tr>
</tbody>
</table>
<p>Sample 2</p>
<table>
<thead>
<tr>
<th>Inputcopy</th>
<th>Outputcopy</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>X.X X.. ... </code></td>
<td><code>NO </code></td>
</tr>
</tbody>
</table>
<p>Note</p>
<p>If you are not familiar with the term «central symmetry», you may look into http://en.wikipedia.org/wiki/Central_symmetry</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;

using namespace std;

bool q[9];


int main() {
	string line;
	int cnt = 0;
	int flag = true;
	for (int i = 0; i &lt; 3; i ++) {
		getline(cin, line);
		for (int j = 0; j &lt; 3; j ++, cnt ++) {
			if (cnt &lt;= 4) {
				if (line[cnt % 3] == 'X') {
					q[cnt] = true;
				}
			} else {
				if (line[cnt % 3] == 'X' &amp;&amp; !q[8 - cnt] || line[cnt % 3] == '.' &amp;&amp; q[8 - cnt]) {
					flag = false;
					break;
				}
			}
		}
		
	}
	if (flag) printf(&quot;YES\n&quot;); 
	else printf(&quot;NO\n&quot;);
		
	return 0;
}
</code></pre>
<h2 id="14a-letter">14A Letter</h2>
<p><a href="https://codeforces.com/problemset/problem/14/A">Letter</a></p>
<blockquote>
<p>Date: Feb/03/2023</p>
</blockquote>
<p>A boy Bob likes to draw. Not long ago he bought a rectangular graph (checked) sheet with <em>n</em> rows and <em>m</em> columns. Bob shaded some of the squares on the sheet. Having seen his masterpiece, he decided to share it with his elder brother, who lives in Flatland. Now Bob has to send his picture by post, but because of the world economic crisis and high oil prices, he wants to send his creation, but to spend as little money as possible. For each sent square of paper (no matter whether it is shaded or not) Bob has to pay 3.14 burles. Please, help Bob cut out of his masterpiece a rectangle of the minimum cost, that will contain all the shaded squares. The rectangle's sides should be parallel to the sheet's sides.</p>
<p>Input</p>
<p>The first line of the input data contains numbers <em>n</em> and <em>m</em> (1 ≤ <em>n</em>, <em>m</em> ≤ 50), <em>n</em> — amount of lines, and <em>m</em> — amount of columns on Bob's sheet. The following <em>n</em> lines contain <em>m</em> characters each. Character «.» stands for a non-shaded square on the sheet, and «*» — for a shaded square. It is guaranteed that Bob has shaded at least one square.</p>
<p>Output</p>
<p>Output the required rectangle of the minimum cost. Study the output data in the sample tests to understand the output format better.</p>
<p>Sample 1</p>
<table>
<thead>
<tr>
<th>Inputcopy</th>
<th>Outputcopy</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>6 7 ....... ..***.. ..*.... ..***.. ..*.... ..***.. </code></td>
<td><code>*** *.. *** *.. *** </code></td>
</tr>
</tbody>
</table>
<p>Sample 2</p>
<table>
<thead>
<tr>
<th>Inputcopy</th>
<th>Outputcopy</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>3 3 *** *.* *** </code></td>
<td><code>*** *.* *** </code></td>
</tr>
</tbody>
</table>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;

using namespace std;

int n, m;

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	string line;
	getline(cin, line); // 读取 n, m 后的换行，否则无法读取完整
	string strs[n];
	int rmin = n, rmax = 0, cmin = m, cmax = 0;
	for (int i = 0; i &lt; n; i ++) {
		getline(cin, strs[i]); // 读入每一行
		for (int j = 0; j &lt; m; j ++) {
			if (strs[i][j] == '*') {
				rmin = min(rmin, i);
				rmax = max(rmax, i);
				cmin = min(cmin, j);
				cmax = max(cmax, j);
			}
		}
	}

	for (int i = rmin; i &lt;= rmax; i ++) {
		for (int j = cmin; j &lt;= cmax; j ++) {
			cout &lt;&lt; strs[i][j];
		}
		cout &lt;&lt; endl;
	}

	return 0;
}
</code></pre>
<h2 id="16a-flag">16A Flag</h2>
<p><a href="https://codeforces.com/problemset/problem/16/A">Flag</a></p>
<blockquote>
<p>Date: Feb/03/2023</p>
</blockquote>
<p>According to a new ISO standard, a flag of every country should have a chequered field <em>n</em> × <em>m</em>, each square should be of one of 10 colours, and the flag should be «striped»: each horizontal row of the flag should contain squares of the same colour, and the colours of adjacent horizontal rows should be different. Berland's government asked you to find out whether their flag meets the new ISO standard.</p>
<p>Input</p>
<p>The first line of the input contains numbers <em>n</em> and <em>m</em> (1 ≤ <em>n</em>, <em>m</em> ≤ 100), <em>n</em> — the amount of rows, <em>m</em> — the amount of columns on the flag of Berland. Then there follows the description of the flag: each of the following <em>n</em> lines contain <em>m</em> characters. Each character is a digit between 0 and 9, and stands for the colour of the corresponding square.</p>
<p>Output</p>
<p>Output YES, if the flag meets the new ISO standard, and NO otherwise.</p>
<p>Sample 1</p>
<table>
<thead>
<tr>
<th>Inputcopy</th>
<th>Outputcopy</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>3 3 000 111 222 </code></td>
<td><code>YES </code></td>
</tr>
</tbody>
</table>
<p>Sample 2</p>
<table>
<thead>
<tr>
<th>Inputcopy</th>
<th>Outputcopy</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>3 3 000 000 111 </code></td>
<td><code>NO </code></td>
</tr>
</tbody>
</table>
<p>Sample 3</p>
<table>
<thead>
<tr>
<th>Inputcopy</th>
<th>Outputcopy</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>3 3 000 111 002 </code></td>
<td><code>NO</code></td>
</tr>
</tbody>
</table>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;

using namespace std;

const int N = 110;

int n, m;
string strs[N];


int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	char cur;
	string line;
	getline(cin, line);
	bool flag = true;
	bool inflag = false;
	for (int i = 0; i &lt; n; i ++) {
		getline(cin, strs[i]);
		for (int j = 1; j &lt; m; j ++) {
			if (strs[i][j] != strs[i][j - 1] || i &gt;= 1 &amp;&amp; strs[i][j] == strs[i - 1][j]) {
				flag = false;
				inflag = true;
				break;
			}
		} 
		if (inflag) break;
	}

	if (flag) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;
	else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;
	
	return 0;
}
</code></pre>
<h2 id="22a-second-order-statistics">22A Second Order Statistics</h2>
<p><a href="https://codeforces.com/problemset/problem/22/A">Second Order Statistics</a></p>
<blockquote>
<p>Date: Feb/04/2023</p>
</blockquote>
<p>Once Bob needed to find the second order statistics of a sequence of integer numbers. Lets choose each number from the sequence exactly once and sort them. The value on the second position is the second order statistics of the given sequence. In other words it is the smallest element strictly greater than the minimum. Help Bob solve this problem.</p>
<p>Input</p>
<p>The first input line contains integer <em>n</em> (1 ≤ <em>n</em> ≤ 100) — amount of numbers in the sequence. The second line contains <em>n</em> space-separated integer numbers — elements of the sequence. These numbers don't exceed 100 in absolute value.</p>
<p>Output</p>
<p>If the given sequence has the second order statistics, output this order statistics, otherwise output NO.</p>
<p>Sample 1</p>
<table>
<thead>
<tr>
<th>Inputcopy</th>
<th>Outputcopy</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>4 1 2 2 -4 </code></td>
<td><code>1 </code></td>
</tr>
</tbody>
</table>
<p>Sample 2</p>
<table>
<thead>
<tr>
<th>Inputcopy</th>
<th>Outputcopy</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>5 1 2 3 1 1 </code></td>
<td><code>2 </code></td>
</tr>
</tbody>
</table>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 105;

int n;
int q[N];


int main() {
	scanf(&quot;%d&quot;, &amp;n);

	for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;q[i]);

	sort(q, q + n);
	
	int res;
	bool flag = false;
	for (int i = 0; i &lt; n; i ++) {
		if (q[i] &gt; q[0]) {
			res = q[i];
			flag = true;
			break;
		}
	}

	if (flag) {
		printf(&quot;%d\n&quot;, res);
	} else printf(&quot;NO&quot;);

	return 0;
}
</code></pre>
<h2 id="32a-reconnaissance">32A Reconnaissance</h2>
<p><a href="https://codeforces.com/problemset/problem/32/A">Reconnaissance</a></p>
<blockquote>
<p>Date: Feb/04/2023</p>
</blockquote>
<p>According to the regulations of Berland's army, a reconnaissance unit should consist of exactly two soldiers. Since these two soldiers shouldn't differ much, their heights can differ by at most <em>d</em> centimeters. Captain Bob has <em>n</em> soldiers in his detachment. Their heights are <em>a</em>1, <em>a</em>2, ..., <em>a**n</em> centimeters. Some soldiers are of the same height. Bob wants to know, how many ways exist to form a reconnaissance unit of two soldiers from his detachment.</p>
<p>Ways (1, 2) and (2, 1) should be regarded as different.</p>
<p>Input</p>
<p>The first line contains two integers <em>n</em> and <em>d</em> (1 ≤ <em>n</em> ≤ 1000, 1 ≤ <em>d</em> ≤ 109) — amount of soldiers in Bob's detachment and the maximum allowed height difference respectively. The second line contains <em>n</em> space-separated integers — heights of all the soldiers in Bob's detachment. These numbers don't exceed 109.</p>
<p>Output</p>
<p>Output one number — amount of ways to form a reconnaissance unit of two soldiers, whose height difference doesn't exceed <em>d</em>.</p>
<p>Sample 1</p>
<table>
<thead>
<tr>
<th>Inputcopy</th>
<th>Outputcopy</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>5 10 10 20 50 60 65 </code></td>
<td><code>6 </code></td>
</tr>
</tbody>
</table>
<p>Sample 2</p>
<table>
<thead>
<tr>
<th>Inputcopy</th>
<th>Outputcopy</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>5 1 55 30 29 31 55 </code></td>
<td><code>6 </code></td>
</tr>
</tbody>
</table>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 105;

int n, d;
int q[N];


int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;d);

	for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;q[i]);

	sort(q, q + n);
	
	int res = 0;
	for (int i = 0; i &lt; n; i ++) {
		for (int j = i + 1; j &lt; n; j ++) {
			if (abs(q[i] - q[j]) &lt;= d) res ++;
		}
	}

	printf(&quot;%d\n&quot;, res * 2);

	return 0;
}
</code></pre>
<h2 id="32b-borze">32B Borze</h2>
<p><a href="https://codeforces.com/problemset/problem/32/B">Borze</a></p>
<blockquote>
<p>Date: Feb/05/2023</p>
</blockquote>
<p>Ternary numeric notation is quite popular in Berland. To telegraph the ternary number the Borze alphabet is used. Digit 0 is transmitted as «.», 1 as «-.» and 2 as «--». You are to decode the Borze code, i.e. to find out the ternary number given its representation in Borze alphabet.</p>
<p>Input</p>
<p>The first line contains a number in Borze code. The length of the string is between 1 and 200 characters. It's guaranteed that the given string is a valid Borze code of some ternary number (this number can have leading zeroes).</p>
<p>Output</p>
<p>Output the decoded ternary number. It can have leading zeroes.</p>
<p>Sample 1</p>
<table>
<thead>
<tr>
<th>Inputcopy</th>
<th>Outputcopy</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.-.-- </code></td>
<td><code>012</code></td>
</tr>
</tbody>
</table>
<p>Sample 2</p>
<table>
<thead>
<tr>
<th>Inputcopy</th>
<th>Outputcopy</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--. </code></td>
<td><code>20</code></td>
</tr>
</tbody>
</table>
<p>Sample 3</p>
<table>
<thead>
<tr>
<th>Inputcopy</th>
<th>Outputcopy</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-..-.-- </code></td>
<td><code>1012</code></td>
</tr>
</tbody>
</table>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;


int main() {
	string line;
	getline(cin, line);
	int n = line.size();

	for (int i = 0; i &lt; n;) {
		if (line[i] == '.') {
			printf(&quot;0&quot;);
			i ++;
		}
		else {
			if (line[++i] == '.') printf(&quot;1&quot;);
			else printf(&quot;2&quot;);
			i ++;
		}
	}

	return 0;
}
</code></pre>
<h2 id="34a-reconnaissance-2">34A Reconnaissance 2</h2>
<p><a href="https://codeforces.com/problemset/problem/34/A">Reconnaissance 2</a></p>
<blockquote>
<p>Date: Feb/05/2023</p>
</blockquote>
<p><em>n</em> soldiers stand in a circle. For each soldier his height <em>a**i</em> is known. A reconnaissance unit can be made of such two <strong>neighbouring</strong> soldiers, whose heights difference is minimal, i.e. |<em>a**i</em> - <em>a**j</em>| is minimal. So each of them will be less noticeable with the other. Output any pair of soldiers that can form a reconnaissance unit.</p>
<p>Input</p>
<p>The first line contains integer <em>n</em> (2 ≤ <em>n</em> ≤ 100) — amount of soldiers. Then follow the heights of the soldiers in their order in the circle — <em>n</em> space-separated integers <em>a</em>1, <em>a</em>2, ..., <em>a**n</em> (1 ≤ <em>a**i</em> ≤ 1000). The soldier heights are given in clockwise or counterclockwise direction.</p>
<p>Output</p>
<p>Output two integers — indexes of <strong>neighbouring</strong> soldiers, who should form a reconnaissance unit. If there are many optimum solutions, output any of them. Remember, that the soldiers stand in a circle.</p>
<p>Sample 1</p>
<table>
<thead>
<tr>
<th>Inputcopy</th>
<th>Outputcopy</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>5 10 12 13 15 10 </code></td>
<td><code>5 1 </code></td>
</tr>
</tbody>
</table>
<p>Sample 2</p>
<table>
<thead>
<tr>
<th>Inputcopy</th>
<th>Outputcopy</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>4 10 20 30 40 </code></td>
<td><code>1 2 </code></td>
</tr>
</tbody>
</table>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;

const int N = 110;

int n;
int h[N];

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;h[i]);

	int minv = 1100, min1, min2;
	for (int i = 2; i &lt;= n; i ++) {
		int cur = abs(h[i] - h[i - 1]);
		if (cur &lt; minv) {
			minv = cur;
			min1 = i;
			min2 = i - 1;
		}
	}
	if (abs(h[n] - h[1]) &lt; minv) {
		min1 = n;
		min2 = 1;
	}

	printf(&quot;%d %d&quot;, min1, min2);

	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode Ultimate]]></title>
        <id>https://CNZedChou.github.io/post/leetcode-ultimate/</id>
        <link href="https://CNZedChou.github.io/post/leetcode-ultimate/">
        </link>
        <updated>2023-01-19T15:15:08.000Z</updated>
        <summary type="html"><![CDATA[<p>@Description:   用于记录AcWing上学习leetcode究极班的过程<br>
@Author:    Zed Chou<br>
@LastModified:    Thu 19 Jan 2023</p>
]]></summary>
        <content type="html"><![CDATA[<p>@Description:   用于记录AcWing上学习leetcode究极班的过程<br>
@Author:    Zed Chou<br>
@LastModified:    Thu 19 Jan 2023</p>
<!-- more -->
<h1 id="34-在排序数组中查找元素的第一个和最后一个位置">34. 在排序数组中查找元素的第一个和最后一个位置</h1>
<p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array">34. 在排序数组中查找元素的第一个和最后一个位置</a></p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230128150058175.png" alt="image-20230128150058175" loading="lazy"></figure>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) {
        vector&lt;int&gt; res;
        if (nums.empty()) return {-1, -1};
        int l = 0, r = nums.size() - 1;
        while (l &lt; r) {
            int mid = (l + r) &gt;&gt; 1;
            if (nums[mid] &gt;= target) r = mid;
            else l = mid + 1;
        }
        if (nums[l] != target) return {-1, -1};
        res.push_back(l);
        l = 0, r = nums.size() - 1;
        while (l &lt; r) {
            int mid = (l + r + 1) &gt;&gt; 1;
            if (nums[mid] &lt;= target) l = mid;
            else r = mid - 1;
        }
        res.push_back(l);
        return res;
    }
};
</code></pre>
<h1 id="35-搜索插入位置">35. 搜索插入位置</h1>
<p><a href="https://leetcode.cn/problems/search-insert-position/?envType=study-plan&amp;id=binary-search-beginner&amp;plan=binary-search&amp;plan_progress=b5ethhc">35. 搜索插入位置</a></p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230120141638246.png" alt="image-20230120141638246" loading="lazy"></figure>
<pre><code class="language-c++">class Solution {
public:
    int searchInsert(vector&lt;int&gt;&amp; nums, int target) {
        int l = 0, r = nums.size() - 1;
        while (l &lt; r) {
            int mid = (l + r) &gt;&gt; 1;
            if (nums[mid] &gt;= target) r = mid;
            else l = mid + 1;
        }
        if (nums[l] &gt;= target) return l;
        else return nums.size();
    }
};
</code></pre>
<h1 id="69-x-的平方根">69. x 的平方根</h1>
<p><a href="https://leetcode.cn/problems/sqrtx">69. x 的平方根</a></p>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230128144259169.png" alt="image-20230128144259169" loading="lazy"></figure>
<pre><code class="language-c++">class Solution {
public:
    int mySqrt(int x) {
        int l = 0, r = x;
        while (l &lt; r) {
            int mid = (l + 1ll + r) &gt;&gt; 1;
            if (mid &lt;= x / mid) l = mid;
            else r = mid - 1;
        }
        return l;
    }
};
</code></pre>
<h1 id="167-两数之和-ii-输入有序数组">167. 两数之和 II - 输入有序数组</h1>
<p><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted">167. 两数之和 II - 输入有序数组</a></p>
<h1 id="278-第一个错误的版本">278. 第一个错误的版本</h1>
<p><a href="https://leetcode.cn/problems/first-bad-version/description/">278. 第一个错误的版本</a></p>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230128145426577.png" alt="image-20230128145426577" loading="lazy"></figure>
<pre><code class="language-c++">// The API isBadVersion is defined for you.
// bool isBadVersion(int version);

class Solution {
public:
    int firstBadVersion(int n) {
        long long l = 1, r = n;
        while (l &lt; r) {
            long long mid = (l + r) &gt;&gt; 1;
            if (isBadVersion(mid)) r = mid;
            else l = mid + 1;
        }
        return (int)l;
    }
};
</code></pre>
<h1 id="367-有效的完全平方数">367. 有效的完全平方数</h1>
<p><a href="https://leetcode.cn/problems/valid-perfect-square/?envType=study-plan&amp;id=binary-search-beginner&amp;plan=binary-search">367. 有效的完全平方数</a></p>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230128140223714.png" alt="image-20230128140223714" loading="lazy"></figure>
<pre><code class="language-c++">class Solution {
public:
    bool isPerfectSquare(int num) {
        int l = 1, r = num;
        while (l &lt; r) {
            int mid = (l + 1ll + r) &gt;&gt; 1;  // 防止爆int
            if (mid &lt;= num / mid) l = mid;
            else r = mid - 1;
        }
        return r * r == num;
    }
};
</code></pre>
<h1 id="374-猜数字大小">374. 猜数字大小</h1>
<p><a href="https://leetcode.cn/problems/guess-number-higher-or-lower/?envType=study-plan&amp;id=binary-search-beginner&amp;plan=binary-search&amp;plan_progress=b5ethhc">374. 猜数字大小</a></p>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119231836443.png" alt="image-20230119231836443" loading="lazy"></figure>
<pre><code class="language-c++">/** 
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return 	     -1 if num is higher than the picked number
 *			      1 if num is lower than the picked number
 *               otherwise return 0
 * int guess(int num);
 */

class Solution {
public:
    int guessNumber(int n) {
        int l = 1, r = n;
        while (l &lt; r) {
            int mid = (long long) l + r &gt;&gt; 1;
            if (guess(mid) &lt;= 0) r = mid;
            else l = mid + 1;
        }

        return l;
    }
};
</code></pre>
<h1 id="441-排列硬币">441. 排列硬币</h1>
<p><a href="https://leetcode.cn/problems/arranging-coins">441. 排列硬币</a></p>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230128151155808.png" alt="image-20230128151155808" loading="lazy"></figure>
<pre><code class="language-c++">class Solution {
public:
    int arrangeCoins(int n) {
        long long  l = 1, r = n;
        while (l &lt; r) {
            long long  mid = (l + r + 1) &gt;&gt; 1;
            if (mid * (mid + 1) &lt;= (long long) 2 * n) l = mid;
            else r = mid - 1;
        }
        return (int) l;
    }
};
</code></pre>
<h1 id="704-二分查找">704. 二分查找</h1>
<p><a href="https://leetcode.cn/problems/binary-search/description/">704. 二分查找</a></p>
<figure data-type="image" tabindex="8"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119231633704.png" alt="image-20230119231633704" loading="lazy"></figure>
<pre><code class="language-c++">class Solution {
public:
    int search(vector&lt;int&gt;&amp; nums, int target) {
        int l = 0, r = nums.size() - 1;
        while (l &lt; r) {
            int mid = (l + r) &gt;&gt; 1;
            if (nums[mid] &gt;= target) r = mid;
            else l = mid + 1;
        }
        if (nums[l] == target) return l;
        else return -1;
    }
};
</code></pre>
<h1 id="744-寻找比目标字母大的最小字母">744. 寻找比目标字母大的最小字母</h1>
<p><a href="https://leetcode.cn/problems/find-smallest-letter-greater-than-target">744. 寻找比目标字母大的最小字母</a></p>
<figure data-type="image" tabindex="9"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230128144828367.png" alt="image-20230128144828367" loading="lazy"></figure>
<p>在比较时，字母是依序循环出现的。举个例子：<br>
如果目标字母 target = 'z' 并且字符列表为 letters = ['a', 'b']，则答案返回 'a'</p>
<p>就是说,如果没有找到合适的,就返回letters的第一字符</p>
<pre><code class="language-c++">class Solution {
public:
    char nextGreatestLetter(vector&lt;char&gt;&amp; letters, char target) {
        int l = 0, r = letters.size() - 1;
        while (l &lt; r) {
            int mid = (l + r) &gt;&gt; 1;
            if (letters[mid] &gt; target) r = mid;
            else l = mid + 1;
        }
        if (letters[l] &lt;= target) return letters[0];
        else return letters[l];
    }
};
</code></pre>
<h1 id="852-山脉数组的峰顶索引">852. 山脉数组的峰顶索引</h1>
<p><a href="https://leetcode.cn/problems/peak-index-in-a-mountain-array/?envType=study-plan&amp;id=binary-search-beginner&amp;plan=binary-search&amp;plan_progress=b5ethhc">852. 山脉数组的峰顶索引</a></p>
<figure data-type="image" tabindex="10"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230120142227927.png" alt="image-20230120142227927" loading="lazy"></figure>
<pre><code class="language-c++">class Solution {
public:
    int peakIndexInMountainArray(vector&lt;int&gt;&amp; arr) {
        int l = 1, r = arr.size() - 2;
        while (l &lt; r) {
            int mid = (l + r + 1) &gt;&gt; 1;
            if (arr[mid] &gt; arr[mid - 1]) l = mid;
            else r = mid - 1;
        }
        return l;
    }
};
</code></pre>
<h1 id="1385-两个数组间的距离值">1385. 两个数组间的距离值</h1>
<p><a href="https://leetcode.cn/problems/find-the-distance-value-between-two-arrays">1385. 两个数组间的距离值</a></p>
<figure data-type="image" tabindex="11"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230128143836717.png" alt="image-20230128143836717" loading="lazy"></figure>
<pre><code class="language-c++">class Solution {
public:
    int findTheDistanceValue(vector&lt;int&gt;&amp; arr1, vector&lt;int&gt;&amp; arr2, int d) {
        int n = arr1.size(), m = arr2.size();
        int res = 0;
        for (int i = 0; i &lt; n; i ++) {
            bool flag = true;
            for (int j = 0; j &lt; m; j ++) {
                if (arr1[i] - arr2[j] &lt;= d &amp;&amp; arr1[i] - arr2[j] &gt;= -d) {
                    flag = false;
                    break;
                }
                
            }
            if (flag) res ++;
        }
        return res;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Tricks in Cpp]]></title>
        <id>https://CNZedChou.github.io/post/tricks-in-cpp/</id>
        <link href="https://CNZedChou.github.io/post/tricks-in-cpp/">
        </link>
        <updated>2023-01-15T07:37:55.000Z</updated>
        <summary type="html"><![CDATA[<p>@Description:   用于记录C++的学习过程的技巧<br>
@Author:    Zed Chou<br>
@LastModified:    Fri 3 Feb 2023</p>
]]></summary>
        <content type="html"><![CDATA[<p>@Description:   用于记录C++的学习过程的技巧<br>
@Author:    Zed Chou<br>
@LastModified:    Fri 3 Feb 2023</p>
<!-- more -->
<h1 id="c库函数-printf">C库函数 - printf()</h1>
<ul>
<li>%d 十进制有符号整数</li>
<li>%u 十进制无符号整数</li>
<li>%f 浮点数</li>
<li>%s 字符串</li>
<li>%c 单个字符</li>
<li>%p 指针的值</li>
<li>%e 指数形式的浮点数</li>
<li>%x, %X 无符号以十六进制表示的整数</li>
<li>%o 无符号以八进制表示的整数</li>
<li>%g 把输出的值按照 %e 或者 %f 类型中输出长度较小的方式输出</li>
<li>%p 输出地址符</li>
<li>%lu 32位无符号整数</li>
<li>%llu 64位无符号整数</li>
</ul>
<h1 id="c语言中的pi圆周率">C语言中的Pi圆周率</h1>
<p>标准的C语言中没有π这个符号及常量，一般在开发过程中是通过开发人员自己定义这个常量的，最常见的方式是使用<a href="https://so.csdn.net/so/search?q=%E5%AE%8F%E5%AE%9A%E4%B9%89&amp;spm=1001.2101.3001.7020">宏定义</a>：<br>
方法1：</p>
<pre><code class="language-cpp">#define PI 3.1415926 
</code></pre>
<p>方法2：</p>
<p>使用反三角函数</p>
<pre><code class="language-cpp">const double PI = acos(-1.0);
</code></pre>
<h1 id="向上取整">向上取整</h1>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">⌈</mo><mfrac><mi>a</mi><mi>b</mi></mfrac><mo fence="true">⌉</mo></mrow><mo>=</mo><mrow><mo fence="true">⌊</mo><mfrac><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>−</mo><mn>1</mn></mrow><mi>b</mi></mfrac><mo fence="true">⌋</mo></mrow></mrow><annotation encoding="application/x-tex">\left \lceil \frac {a}{b} \right \rceil  = \left \lfloor \frac {a + b - 1}{b} \right \rfloor 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.8359999999999999em;vertical-align:-0.686em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">⌈</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">b</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">⌉</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">⌊</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">b</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">⌋</span></span></span></span></span></span></span></p>
<h1 id="求a除以b的正余数">求a除以b的正余数</h1>
<pre><code class="language-c++">int get_mod(int a, int b) {
    return (a % b + b) % b;
}
</code></pre>
<h1 id="判断年份是否为闰年">判断年份是否为闰年</h1>
<pre><code class="language-c++">if (year % 100 &amp;&amp; year % 4 == 0 || year % 400 == 0) {
    // 闰年
}
</code></pre>
<h1 id="c-读入多组数据">C++ 读入多组数据</h1>
<h2 id="单纯读入多行字符串"><strong>单纯读入多行字符串</strong></h2>
<p>读入三行字符串：</p>
<pre><code class="language-c++">string str[3];
for(int i=0;i&lt;3;i++)
    getline(cin,str[i]);
</code></pre>
<h2 id="读取数量不定的输入数据">读取数量不定的输入数据</h2>
<h3 id="while-循环-scanf">while 循环， scanf</h3>
<pre><code class="language-c++">while(scanf(&quot;%d&quot;,&amp;a)!=EOF){
    printf(&quot;%d\n&quot;,a);
}
</code></pre>
<h3 id="for-循环">for 循环</h3>
<pre><code class="language-c++">for(int i;cin&gt;&gt;i;){
    cout &lt;&lt; i &lt;&lt; endl;
}
</code></pre>
<h3 id="while-循环-cin">while 循环， cin</h3>
<pre><code class="language-c++">while(cin&gt;&gt;a){
    cout &lt;&lt; a &lt;&lt; endl;
}
</code></pre>
<h1 id="二维-三维坐标转化为一维">二维、三维坐标转化为一维</h1>
<pre><code class="language-c++">int get(int i, int j, int k) {
	// 将三维坐标转化为一维
    // 三维为A, B, C
    return (i * B + j) * C + k;
}

int get(int i, int j) {
    // 二维为n, m
    return i * m + j;
}
</code></pre>
<h1 id="偏移量数组">偏移量数组</h1>
<h2 id="二维">二维</h2>
<pre><code class="language-c++">int dx[4] = {-1, 0, 1, 0};
int dy[4] = {0, -1, 0, 1};
</code></pre>
<h2 id="三维">三维</h2>
<pre><code class="language-c++">int dx[6] = {-1, 1, 0, 0, 0, 0};
int dy[6] = {0, 0, -1, 1, 0, 0};
int dz[6] = {0, 0, 0, 0, -1, 1};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[蓝桥杯C++]]></title>
        <id>https://CNZedChou.github.io/post/lan-qiao-bei-c/</id>
        <link href="https://CNZedChou.github.io/post/lan-qiao-bei-c/">
        </link>
        <updated>2023-01-13T06:26:10.000Z</updated>
        <summary type="html"><![CDATA[<p>@Description:   用于AcWing上学习蓝桥杯C++的学习过程<br>
@Author:    Zed Chou<br>
@LastModified:    Wed 8 Feb 2023</p>
]]></summary>
        <content type="html"><![CDATA[<p>@Description:   用于AcWing上学习蓝桥杯C++的学习过程<br>
@Author:    Zed Chou<br>
@LastModified:    Wed 8 Feb 2023</p>
<!-- more -->
<h1 id="递归与递推">递归与递推</h1>
<h2 id="递归">递归</h2>
<p>所有递归都可以转化为一棵递归搜索树</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230113144601714.png" alt="image-20230113144601714" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230113143336682.png" alt="image-20230113143336682" loading="lazy"></figure>
<p>斐波那契数列代码</p>
<pre><code class="language-c++">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;

using namespace std;

int f(int n) {
	if (n == 1) return 1;
	if (n == 2) return 2;
	return f(n - 1) + f(n - 2);
}

int main() {
	int n;
	scanf(&quot;%d&quot;, &amp;n);
	printf(&quot;%d\n&quot;, f(n));
	
	return 0;
}
</code></pre>
<h3 id="例题-92-递归实现指数型枚举">例题 92. 递归实现指数型枚举</h3>
<p><a href="https://www.acwing.com/problem/content/94/">92. 递归实现指数型枚举</a></p>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230116214158902.png" alt="image-20230116214158902" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230113145510183.png" alt="image-20230113145510183" loading="lazy"></figure>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;

using namespace std;

int n;
const int N = 16;
int st[N]; // 表示数字选择的状态，0 表示还没选，1 表示选， 2表示不选 

void dfs(int u) {
	// u 表示当前所在的位数
	if (u &gt; n) {
		for (int i = 1; i &lt;= n; i ++) {
			if (st[i] == 1)
				printf(&quot;%d &quot;, i); // 加空格，否则wrong answer 
		}
		printf(&quot;\n&quot;);
		return ;
	}
	
	st[u] = 2; 
	dfs(u + 1); // 不选的分支 
	st[u] = 0; // 恢复现场 
	
	st[u] = 1;
	dfs(u + 1); // 选的分支 
	st[u] = 0; // 恢复现场 
}


int main() {
	scanf(&quot;%d&quot;, &amp;n);
	dfs(1);
	
	return 0; 
}
</code></pre>
<h3 id="例题-94-递归实现排列型枚举">例题 94. 递归实现排列型枚举</h3>
<p><a href="https://www.acwing.com/problem/content/96/">AcWing 94. 递归实现排列型枚举 </a></p>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230116214218850.png" alt="image-20230116214218850" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230113155248147.png" alt="image-20230113155248147" loading="lazy"></figure>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;

using namespace std;

int n;
const int N = 10;
int st[N]; // 	表示当前的状态， 0表示没有数，1-n表示有数字 
bool used[N]; //	表示每个数是否被用过，true表示已经被用过，false 表示还没有被用过 


void dfs(int u) {
	// 边界条件 
	if (u &gt; n) {
		for (int i = 1; i &lt;= n; i ++) printf(&quot;%d &quot;, st[i]);
		printf(&quot;\n&quot;);
		return ; 
	}
	
	for (int i = 1; i &lt;= n; i ++) {
		if (!used[i]) {
			st[u] = i;
			used[i] = true;
			dfs(u + 1);
			
			st[u] = 0;
			used[i] = false;
		}
	}		
}


int main() {
	scanf(&quot;%d&quot;, &amp;n);
	
	dfs(1);
	
	return 0;	
}
</code></pre>
<h3 id="习题-93-递归实现组合型枚举">习题 93. 递归实现组合型枚举</h3>
<p><a href="https://www.acwing.com/problem/content/95/">93. 递归实现组合型枚举</a></p>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230116214413907.png" alt="image-20230116214413907" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230116214643540.png" alt="image-20230116214643540" loading="lazy"></figure>
<p><strong>方案限制 从小到大排序</strong> 只需要保证所有新加的数 大于 前面的数</p>
<figure data-type="image" tabindex="9"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230116215538793.png" alt="递归组合搜索树" loading="lazy"></figure>
<p>代码要点</p>
<figure data-type="image" tabindex="10"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230116215902983.png" alt="image-20230116215902983" loading="lazy"></figure>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;

using namespace std;

const int N = 30;

int n, m;
int way[N];

void dfs(int u, int start) {
    if (u + n - start &lt; m) return ; // 优化
	if (u == m + 1) {
		// 表明已经递归完最后一位
		for (int i = 1; i &lt;= m; i ++) {
			printf(&quot;%d &quot;, way[i]);
			
		}
		puts(&quot;&quot;);
		return ;
	}
	// 开始递归
	for (int i = start; i &lt;= n; i ++) {
		way[u] = i;
		dfs(u + 1, i + 1);
		way[u] = 0; // 恢复现场
	}
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	
	dfs(1, 1);
	
	return 0;
}
</code></pre>
<h3 id="习题-1209-带分数">习题 1209. 带分数</h3>
<p><a href="https://www.acwing.com/problem/content/1211/">1209. 带分数</a></p>
<figure data-type="image" tabindex="11"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230116223936038.png" alt="image-20230116223936038" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230116231235695.png" alt="image-20230116231235695" loading="lazy"></figure>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

const int N = 20;
typedef long long LL;

int n, ans;
bool st[N], backup[N];

bool check(int a, int c) {
	LL b = n * (LL)c - a * c;
	if (!a || !b || !c) return false;
	memcpy(backup, st, sizeof st);
	while (b) {
		int x = b % 10;
		b /= 10;
		if (!x || backup[x]) return false; // 如果x是0 或 x已被用过
		backup[x] = true;	
	}
	for (int i = 1; i &lt;= 9; i ++) {
		if (!backup[i]) return false;	
	}
	
	return true;
}



void dfs_c(int a, int c) {
	if (check(a, c)) ans ++;
	for (int i = 1; i &lt;= 9; i ++) {
		if (!st[i]) {
			st[i] = true;
			dfs_c(a, c * 10 + i);	
			st[i] = false;
		}
	}
}

void dfs_a(int a) {
	if (a &gt;= n) return ; // 如果 a &gt; n 则不成立
	if (a) dfs_c(a, 0);
	
	for (int i = 1; i &lt;= 9; i ++) {
		if (!st[i]) {
			// 如果没有使用过
			st[i] = true;
			dfs_a(a * 10 + i); // 向前移动一位 
			st[i] = false; // 恢复现场	
		}
	}
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	
	dfs_a(0);
	cout &lt;&lt; ans;
	
	return 0;
}
</code></pre>
<h3 id="习题-1225-正则问题">习题 1225. 正则问题</h3>
<p><a href="https://www.acwing.com/problem/content/1227/">1225. 正则问题</a></p>
<p>考虑一种简单的正则表达式：</p>
<p>只由 x ( ) | 组成的正则表达式。</p>
<p>小明想求出这个正则表达式能接受的最长字符串的长度。</p>
<p>例如 ((xx|xxx)x|(x|xx))xx 能接受的最长字符串是： xxxxxx，长度是6。</p>
<h4 id="输入格式">输入格式</h4>
<p>一个由x()|组成的正则表达式。</p>
<h4 id="输出格式">输出格式</h4>
<p>输出所给正则表达式能接受的最长字符串的长度。</p>
<h4 id="数据范围">数据范围</h4>
<p>输入长度不超过100，保证合法。</p>
<h4 id="输入样例">输入样例：</h4>
<pre><code>((xx|xxx)x|(x|xx))xx 
</code></pre>
<h4 id="输出样例">输出样例：</h4>
<pre><code>6
</code></pre>
<figure data-type="image" tabindex="13"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230208155532386.png" alt="image-20230208155532386" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230208155845844.png" alt="image-20230208155845844" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

string str;
int k;

int dfs() {
    int res = 0;
    while (k &lt; str.size()) {
        if (str[k] == '(') {  // 处理形如(...)的内容
            k ++;  // 跳过当前的左括号
            res += dfs();
            k ++;  // 跳过当前的右括号
        } else if (str[k] == '|') {
            //  取左右的较大值
            k ++;  // 跳过当前的 '|'
            res = max(res, dfs());
        } else if (str[k] == ')') break;
        else {
            // 遇到'x' 
            k ++;
            res ++;
        }
    }
    return res;
}

int main() {
    cin &gt;&gt; str;
    printf(&quot;%d\n&quot;, dfs());

    return 0;
}
</code></pre>
<h2 id="递推">递推</h2>
<h3 id="例题-717-简单斐波那契">例题 717. 简单斐波那契</h3>
<p><a href="https://www.acwing.com/problem/content/719/">717. 简单斐波那契</a></p>
<figure data-type="image" tabindex="15"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230118155532256.png" alt="image-20230118155532256" loading="lazy"></figure>
<ul>
<li>使用数组的方法</li>
</ul>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;

using namespace std;

int main() {
	int f[46];
	int n;
	cin &gt;&gt; n;
	
	f[0] = 0, f[1] = 1;
	for (int i = 2; i &lt; n; i ++) f[i] = f[i - 1] + f[i - 2];
	
	for (int i = 0; i &lt; n; i ++) cout &lt;&lt; f[i] &lt;&lt; ' ';
	
	return 0;
}
</code></pre>
<ul>
<li>使用变量的方法</li>
</ul>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;

using namespace std;

int main() {
	int n;
	cin &gt;&gt; n;
	
	int a = 0, b = 1;
	for (int i = 1; i &lt;= n; i ++) {
		cout &lt;&lt; a &lt;&lt; ' ';
		int fn = a + b;
		a = b, b = fn;	
	}
	
	return 0;
}
</code></pre>
<h3 id="例题-95-费解的开关">例题 95. 费解的开关</h3>
<p><a href="https://www.acwing.com/problem/content/97/">95. 费解的开关</a></p>
<figure data-type="image" tabindex="16"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119133745755.png" alt="image-20230119133745755" loading="lazy"></figure>
<figure data-type="image" tabindex="17"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119134729534.png" alt="image-20230119134729534" loading="lazy"></figure>
<h4 id="思路当第一行确定之后接下来的操作都唯一确定">思路：当第一行确定之后，接下来的操作都唯一确定</h4>
<h4 id="代码关键点">代码关键点</h4>
<ul>
<li>如何枚举第一行的操作
<ul>
<li>由于一行只有5位，将这5位看成5位的二进制数，每个操作对应一个二进制数</li>
<li>判断2进制表示的数字某位是否为1的方法<code>i &gt;&gt; k &amp; 1</code></li>
</ul>
</li>
<li>如何去操作
<ul>
<li>turn(x,y) 通过偏移量进行操作</li>
</ul>
</li>
<li>时间复杂度</li>
</ul>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

const int N = 6;

char g[N][N], backup[N][N];
int dx[5] = {-1, 0, 1, 0, 0}, dy[5] = {0, 1, 0, -1, 0};

void turn(int x, int y) {
	for (int i = 0; i &lt; 5; i ++) {
		int a = x + dx[i], b = y + dy[i];
		if (a &lt; 0 || a &gt;= 5 || b &lt; 0 || b &gt;= 5) continue; // 在边界之外
		g[a][b] ^= 1; // 其中'0'ascii码为48二进制为110000， '1'ascii码为49二进制为110001 
	}
}

int main() {
	int n;
	cin &gt;&gt; n;
	while (n --) {
		for (int i = 0; i &lt; 5; i ++) cin &gt;&gt; g[i];
		int res = 10;
		
		// 对第一行进行操作
		for (int op = 0; op &lt; 32; op ++) {
			memcpy(backup, g, sizeof g);
			int step = 0;
			for (int i = 0; i &lt; 5; i ++) {
				if (op &gt;&gt; i &amp; 1) {
					step ++; // 操作数加1，表示将灭的灯打开 
					turn(0, i); // turn函数表示对当前坐标以及周围的灯的状态进行改变 
				}
			}
			for (int i = 0; i &lt; 4; i ++) {
				for (int j = 0; j &lt; 5; j ++) {
					if (g[i][j] == '0') {
						// 表示当前的等灭，下一行需要开灯，故操作数加1
						step++;
						turn(i + 1, j); 
					}
				}
			}
			
			bool dark = false;
			for (int i = 0; i &lt; 5; i ++) {
				if (g[4][i] == '0') {
					dark = true;
					break;
					// 最后一行仍有未开的灯	
				}
			}
			if (!dark) res = min(res, step); // 如果全部灯都打开
			memcpy(g, backup, sizeof g); 
		}
		if (res &gt; 6) res = -1;
		cout &lt;&lt; res &lt;&lt; endl;
		
	}
	
	return 0;
}
</code></pre>
<h3 id="习题-116-飞行员兄弟">习题 116. 飞行员兄弟</h3>
<p><a href="https://www.acwing.com/problem/content/118/">116. 飞行员兄弟</a></p>
<figure data-type="image" tabindex="18"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119143918474.png" alt="image-20230119143918474" loading="lazy"></figure>
<h4 id="思路">思路</h4>
<figure data-type="image" tabindex="19"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119153305792.png" alt="image-20230119153305792" loading="lazy"></figure>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;

#define x first
#define y second

using namespace std;

typedef pair&lt;int, int&gt; PII; 
const int N = 5;

char g[N][N], backup[N];


int get(int x, int y) {
	return x * 4 + y;
	// 坐标为x，y的对应为二进制数的第x*4+y位	
}

void turn_one(int x, int y) {
	if (g[x][y] == '-') g[x][y] = '+';
	else g[x][y] = '-';	
}

void turn_all(int x, int y) {
	// 修改对应的十字路径上的开关 
	for (int i = 0; i &lt; 4; i ++) {
		turn_one(i, y); // 修改行 
		turn_one(x, i); // 修改列 
	}
	turn_one(x, y); // 由于中间的被两次操作，所以再操作回来 
}


int main() {
	for (int i = 0; i &lt; 4; i ++) cin &gt;&gt; g[i];
	
	vector&lt;PII&gt; res; // 存储结果的操作 
	
	// 暴力枚举每一次的操作
	for (int op = 0; op &lt; (1 &lt;&lt; 16); op ++) {
		vector&lt;PII&gt; tmp;
		memcpy(backup, g, sizeof g); //		备份
		for (int i = 0; i &lt; 4; i ++) {
			for (int j = 0; j &lt; 4; j ++) {
				if (op &gt;&gt; get(i, j) &amp; 1) {
					tmp.push_back({i, j});
					turn_all(i, j);	
				}
			}
		}
		// 判断所有的灯泡是否全部亮 
		bool has_closed = false;
		for (int i = 0; i &lt; 4; i ++) {
			for (int j = 0; j &lt; 4; j ++) {
				if (g[i][j] == '+') has_closed = true; // 有还没关闭的 
			}
		}
		
		if (has_closed == false) {
			if (res.empty() || res.size() &gt; tmp.size()) res = tmp;	
		}
		memcpy(g, backup, sizeof g); // 	还原 
	}
	// 输出结果
	cout &lt;&lt; res.size() &lt;&lt; endl;
	for (auto p: res) cout &lt;&lt; p.x + 1 &lt;&lt; ' ' &lt;&lt; p.y + 1 &lt;&lt; endl; 

	return 0;
}
</code></pre>
<h3 id="习题-1208-翻硬币">习题 1208. 翻硬币</h3>
<p><a href="https://www.acwing.com/problem/content/1210/">1208. 翻硬币</a></p>
<figure data-type="image" tabindex="20"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119144156307.png" alt="image-20230119144156307" loading="lazy"></figure>
<h4 id="思路-2">思路</h4>
<figure data-type="image" tabindex="21"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119145109874.png" alt="image-20230119145109874" loading="lazy"></figure>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;

using namespace std;

const int N = 110;
char before[N], after[N];
 
void turn(int i) {
	if (before[i] == '*') before[i] = 'o';
	else before[i] = '*';	
}

int main() {
	cin &gt;&gt; before &gt;&gt; after;
	int res = 0;
	int n = strlen(before);
	for (int i = 0; i &lt; n - 1; i ++) {
		if (before[i] != after[i]) {
			turn(i), turn(i + 1); // 进行修改，翻转相邻的两枚硬币 
			res ++;
		}
	}
	cout &lt;&lt; res &lt;&lt; endl;
	return 0;
}
</code></pre>
<h1 id="二分与前缀和">二分与前缀和</h1>
<h2 id="二分">二分</h2>
<p>整数二分步骤：</p>
<ol>
<li>找一个区间[L,R],使得答案一定在该区间中</li>
<li>找一个判断条件，使得该判断条件具有二段性，并且答案一定是该二段性的分界点。</li>
<li>分析终点M在该判断条件下是否成立，如果成立，考虑答案在哪个区间；如果不成立，考虑答案在哪个区间：</li>
<li>如果更新方式写的是R=Mid,则不用做任何处理；如果更新方式写的是L=Mid,则需要在计算Mid时加上1。</li>
</ol>
<h3 id="整数二分的模板">整数二分的模板</h3>
<pre><code class="language-c++">bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l &lt; r)
    {
        int mid = l + r &gt;&gt; 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
{
    while (l &lt; r)
    {
        int mid = l + r + 1 &gt;&gt; 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
</code></pre>
<h4 id="第一类目标值为左侧区间的右端点落在左侧">第一类：目标值为左侧区间的右端点（落在左侧）</h4>
<figure data-type="image" tabindex="22"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119171603443.png" alt="image-20230119171603443" loading="lazy"></figure>
<pre><code class="language-c++">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
{
    while (l &lt; r)
    {
        int mid = l + r + 1 &gt;&gt; 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
</code></pre>
<h4 id="第二类目标值为右侧区间的左端点落在右侧">第二类：目标值为右侧区间的左端点（落在右侧）</h4>
<figure data-type="image" tabindex="23"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119171817071.png" alt="image-20230119171817071" loading="lazy"></figure>
<pre><code class="language-c++">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l &lt; r)
    {
        int mid = l + r &gt;&gt; 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
</code></pre>
<h3 id="浮点数二分的模板">浮点数二分的模板</h3>
<figure data-type="image" tabindex="24"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119225519164.png" alt="image-20230119225519164" loading="lazy"></figure>
<pre><code class="language-c++">double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l &gt; eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
</code></pre>
<h3 id="例题-789-数的范围">例题 789. 数的范围</h3>
<p><a href="https://www.acwing.com/problem/content/791/">789. 数的范围</a></p>
<figure data-type="image" tabindex="25"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119185556558.png" alt="image-20230119185556558" loading="lazy"></figure>
<h4 id="思路-3">思路</h4>
<figure data-type="image" tabindex="26"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119190414212.png" alt="image-20230119190414212" loading="lazy"></figure>
<p>在查找右侧的端点的时候</p>
<p>可以将找到的左端点作为左边界</p>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;

using namespace std;

const int N = 100010;
int q[N];
int n, m;

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	// 输入待询问的数组 
	for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;q[i]);
	
	// 处理每次询问 
	for (int i = 0; i &lt; m; i ++) {
		int x;
		scanf(&quot;%d&quot;, &amp;x);
		int l = 0, r = n - 1;
		// 二分查找左端点 
		while (l &lt; r) {
			int mid = (l + r) &gt;&gt; 1;
			if (q[mid] &gt;= x) r = mid;
			else l = mid + 1;	
		}
		if (q[r] == x) {
			cout &lt;&lt; r;	
			// 开始二分查找右端点 此时l = r
			r = n - 1; // 重新设置右边界点
			while (l &lt; r) {
				int mid = (l + r + 1) &gt;&gt; 1;
				if (q[mid] &lt;= x) l = mid;
				else r = mid - 1;
			}
			cout &lt;&lt; ' ' &lt;&lt; r &lt;&lt; endl;
			 
		} else {
			cout &lt;&lt; &quot;-1 -1&quot; &lt;&lt; endl;
		}
	}
	
	return 0;
}
</code></pre>
<h3 id="例题-790-数的三次方根">例题 790. 数的三次方根</h3>
<p><a href="https://www.acwing.com/problem/content/792/">790. 数的三次方根</a></p>
<figure data-type="image" tabindex="27"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119225730575.png" alt="image-20230119225730575" loading="lazy"></figure>
<figure data-type="image" tabindex="28"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119230241701.png" alt="image-20230119230241701" loading="lazy"></figure>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;

using namespace std;

double n;

int main() {
	cin &gt;&gt; n;
	double l = -1e6, r = 1e6;
	while (r - l &gt; 1e-7) {
		double mid = (l + r) / 2;
		if (mid * mid * mid &gt;= n) r = mid;
		else l = mid; 	
	}
	printf(&quot;%.6f&quot;, l);
	
	return 0;
}
</code></pre>
<h3 id="习题-730-机器人跳跃问题">习题 730. 机器人跳跃问题</h3>
<p><a href="https://www.acwing.com/problem/content/732/">730. 机器人跳跃问题</a></p>
<figure data-type="image" tabindex="29"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119233225250.png" alt="image-20230119233225250" loading="lazy"></figure>
<figure data-type="image" tabindex="30"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119233752375.png" alt="image-20230119233752375" loading="lazy"></figure>
<figure data-type="image" tabindex="31"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230119234034010.png" alt="image-20230119234034010" loading="lazy"></figure>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;

using namespace std;

const int N = 100010;

int n;
int h[N];

bool check(int e) {
	for (int i = 1; i &lt;= n; i ++) {
		e = 2 * e - h[i];
		if (e &gt;= 1e5) return true;
		if (e &lt; 0) return false;
	}
	return true; 
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;h[i]);
	
	int l = 0, r = 1e5;
	while (l &lt; r) {
		int mid = (l + r) &gt;&gt; 1;
		if (check(mid)) r = mid;
		else l = mid + 1;	
	}
	
	printf(&quot;%d&quot;, r);
	return 0;	
}
</code></pre>
<h3 id="习题-1221-四平方和">习题 1221. 四平方和</h3>
<p><a href="https://www.acwing.com/problem/content/1223/">1221. 四平方和</a></p>
<figure data-type="image" tabindex="32"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230120143245617.png" alt="image-20230120143245617" loading="lazy"></figure>
<figure data-type="image" tabindex="33"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230120145053309.png" alt="image-20230120145053309" loading="lazy"></figure>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;

using namespace std;

const int N = 2500010;

struct Sum{
	int s, c, d; // 其中s=c*c+d*d
	// 重载运算符
	bool operator&lt; (const Sum &amp;t) const {
		if (s != t.s) return s &lt; t.s;
		if (c != t.c) return c &lt; t.c;
		return d &lt; t.d;
	}
} Sum[N];

int n, m;

int main() {
	cin &gt;&gt; n;
	for (int c = 0; c * c &lt;= n; c ++) {
		for (int d = c; c * c + d * d &lt;= n; d ++) {
			Sum[m++] = {c * c + d * d, c, d};
		}
	}
	// 对存储的sum进行排序
	sort(Sum, Sum + m);
	
	for (int a = 0; a * a &lt;= n; a ++) {
		for (int b = 0; a * a + b * b &lt;= n; b ++) {
			int t = n - a * a - b * b;
			int l = 0, r = m - 1;
			// 二分查找 
			while (l &lt; r) {
				int mid = (l + r) &gt;&gt; 1;
				if (Sum[mid].s &gt;= t) r = mid;
				else l = mid + 1;
			}
			if (t == Sum[l].s) {
				printf(&quot;%d %d %d %d&quot;, a, b, Sum[l].c, Sum[l].d);
				return 0;
			}
		}
	}
	
	return 0; 
}
</code></pre>
<h3 id="习题-1227-分巧克力">习题 1227. 分巧克力</h3>
<p><a href="https://www.acwing.com/problem/content/1229/">1227. 分巧克力</a></p>
<figure data-type="image" tabindex="34"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230120163921397.png" alt="image-20230120163921397" loading="lazy"></figure>
<figure data-type="image" tabindex="35"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230120164939813.png" alt="image-20230120164939813" loading="lazy"></figure>
<ul>
<li>块数大于等于K的最大边长</li>
</ul>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;

using namespace std;

const int N = 100010;

int n, k;
int h[N], w[N];

bool check(int mid) {
	int res = 0;
	for (int i = 0; i &lt; n; i ++) {
		res += (h[i] / mid) * (w[i] / mid);
		if (res &gt;= k) return true;
	}
	return false;
}


int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
	for (int i = 0; i &lt; n; i ++) scanf(&quot;%d%d&quot;, &amp;h[i], &amp;w[i]); // 输入每块的长与宽
	
	int l = 1, r = 100000;
	while (l &lt; r) {
		int mid = l + r + 1&gt;&gt; 1;
		if (check(mid)) l = mid;
		else r = mid - 1; 
	}
	printf(&quot;%d&quot;, l);
	
	return 0;
}
</code></pre>
<h2 id="前缀和">前缀和</h2>
<h3 id="一维前缀和">一维前缀和</h3>
<figure data-type="image" tabindex="36"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230120224820456.png" alt="image-20230120224820456" loading="lazy"></figure>
<ul>
<li>只能<strong>处理静态数据，不能修改数据</strong>(只能查询不能修改)</li>
</ul>
<h3 id="二维前缀和">二维前缀和</h3>
<p>求一个子矩阵内的和</p>
<ul>
<li>前缀和矩阵：表示左上角所有数的和</li>
</ul>
<figure data-type="image" tabindex="37"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230129145240479.png" alt="image-20230129145240479" loading="lazy"></figure>
<ul>
<li>
<p>如何计算前缀和矩阵：容斥原理</p>
<ul>
<li>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>x</mi><mi>y</mi></mrow></msub><mo>=</mo><msub><mi>S</mi><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>S</mi><mrow><mi>x</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi></mrow></msub><mo>−</mo><msub><mi>S</mi><mrow><mi>x</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>a</mi><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow></msub></mrow><annotation encoding="application/x-tex">S_{xy} = S_{x,y - 1} + S_{x - 1, y}- S_{x- 1, y - 1}+a_{x, y}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
</li>
<li>
<figure data-type="image" tabindex="38"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230129145609537.png" alt="image-20230129145609537" loading="lazy"></figure>
</li>
</ul>
</li>
<li>
<p>如何计算子矩阵的和：</p>
<ul>
<li>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub></mrow></msub><mo>−</mo><msub><mi>S</mi><mrow><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mrow><msub><mi>y</mi><mn>1</mn></msub><mo>−</mo><mn>1</mn></mrow></mrow></msub><mo>−</mo><msub><mi>S</mi><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>−</mo><mn>1</mn><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub></mrow></msub><mo>+</mo><msub><mi>S</mi><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>−</mo><mn>1</mn><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">S_{x_2,y_2} - S_{x_2, {y_1 - 1}} - S_{x_1 - 1, y_2} + S_{x_1 - 1, y_2 - 1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
</li>
<li>
<figure data-type="image" tabindex="39"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230129145934338.png" alt="image-20230129145934338" loading="lazy"></figure>
</li>
</ul>
</li>
</ul>
<h3 id="例题-795-前缀和">例题 795. 前缀和</h3>
<p><a href="https://www.acwing.com/problem/content/797/">795. 前缀和</a></p>
<figure data-type="image" tabindex="40"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230129143639574.png" alt="image-20230129143639574" loading="lazy"></figure>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;

using namespace std;

const int N = 1000010;

int n, m;
int a[N]; // 表示原数组 
int s[N]; // 表示前缀和数组

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m); 
	for (int i = 1; i &lt;= n; i ++) {
		scanf(&quot;%d&quot;, &amp;a[i]); // 读取原的数组
		s[i] = s[i - 1] + a[i]; // 初始化前缀和数组
	}
	
	while (m --) {
		int l, r;
		scanf(&quot;%d%d&quot;, &amp;l, &amp;r);
		printf(&quot;%d\n&quot;, s[r] - s[l - 1]);
	}
	
	return 0;
}
</code></pre>
<h3 id="例题-796-子矩阵的和">例题 796. 子矩阵的和</h3>
<p><a href="https://www.acwing.com/problem/content/798/">796. 子矩阵的和</a></p>
<figure data-type="image" tabindex="41"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230129144630859.png" alt="image-20230129144630859" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N =  1010;
int n, m, q;
int a[N][N], s[N][N];

int main()
{
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q);
    
    for (int i = 1; i &lt;= n; i ++ ) {
        for (int j = 1; j &lt;= m; j ++ ) {
            scanf(&quot;%d&quot;, &amp;a[i][j]); // 输入原数组
            s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j -1] + a[i][j];
        }
    }
    
    // 处理询问
    while (q -- ) {
        int x1, x2, y1, y2;
        scanf(&quot;%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);
        printf(&quot;%d\n&quot;, s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 -1] + s[x1 - 1][y1 - 1]);
    }
    
    return 0;
}
</code></pre>
<h3 id="习题-99-激光炸弹">习题 99. 激光炸弹</h3>
<p><a href="https://www.acwing.com/problem/content/101/">99. 激光炸弹</a></p>
<figure data-type="image" tabindex="42"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230129151237410.png" alt="image-20230129151237410" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;

using namespace std;

const int N = 5010;

int n, m;

int s[N][N];

int main() {
    int cnt, R;
    scanf(&quot;%d%d&quot;, &amp;cnt, &amp;R);
    
    R = min(5001, R);
    
    n = m = R;
    
    while (cnt -- ) {
        int x, y, w;
        scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;w);
        x ++, y ++; // 保证前缀和坐标从1 开始
        n = max(x, n), m = max(y, m);
        s[x][y] += w; 
    }
    
    // 预处理前缀和
    for (int i = 1; i &lt;= n; i ++ ) {
        for (int j = 1; j &lt;= m; j ++ ) {
            s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];
        }
    }
    
    int res = 0;
    for (int i = R; i &lt;= n; i ++) {
        for (int j = R; j &lt;= m; j ++) {
            res = max(res, s[i][j] - s[i][j - R] - s[i - R][j] + s[i - R][j - R]);
        }
    }
    
    printf(&quot;%d\n&quot;, res);
    
    return 0;
}
</code></pre>
<h3 id="习题-1230-k倍区间">习题 1230. K倍区间</h3>
<p><a href="https://www.acwing.com/problem/content/1232/">1230. K倍区间</a></p>
<figure data-type="image" tabindex="43"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230129151339797.png" alt="image-20230129151339797" loading="lazy"></figure>
<figure data-type="image" tabindex="44"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230129170108442.png" alt="image-20230129170108442" loading="lazy"></figure>
<ul>
<li><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230129170841638.png" alt="image-20230129170841638" loading="lazy"></li>
</ul>
<figure data-type="image" tabindex="46"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230129171642817.png" alt="image-20230129171642817" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 100010;
typedef long long LL;

LL a[N], s[N], cnt[N];
int n, k;


int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
    for (int i = 1; i &lt;= n; i ++ ) {
        scanf(&quot;%lld&quot;, &amp;a[i]);
        s[i] = s[i - 1] + a[i];
    }
    LL res = 0;
    
    cnt[0] = 1;
    for (int i = 1; i &lt;= n; i ++ ) {
        res += cnt[s[i] % k];
        cnt[s[i] % k] ++;
    }
    
    printf(&quot;%lld\n&quot;, res);
    
    return 0;
}
</code></pre>
<h1 id="数学与简单dp">数学与简单DP</h1>
<h2 id="数学">数学</h2>
<h3 id="例题-1205-买不到的数目">例题 1205. 买不到的数目</h3>
<p><a href="https://www.acwing.com/problem/content/1207/">1205. 买不到的数目</a></p>
<ul>
<li>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">如</mi><mi mathvariant="normal">果</mi><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mi mathvariant="normal">均</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">正</mi><mi mathvariant="normal">整</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">且</mi><mi mathvariant="normal">互</mi><mi mathvariant="normal">质</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">那</mi><mi mathvariant="normal">么</mi><mi mathvariant="normal">由</mi><mi>a</mi><mi>x</mi><mi mathvariant="normal">十</mi><mi>b</mi><mi>y</mi><mo separator="true">,</mo><mi>x</mi><mo>≥</mo><mn>0</mn><mi mathvariant="normal">，</mi><mi>y</mi><mo>≥</mo><mn>0</mn><mi mathvariant="normal">不</mi><mi mathvariant="normal">能</mi><mi mathvariant="normal">凑</mi><mi mathvariant="normal">出</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">最</mi><mi mathvariant="normal">大</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">是</mi><mi>a</mi><mi>b</mi><mi mathvariant="normal">一</mi><mi>a</mi><mi mathvariant="normal">一</mi><mi>b</mi><mi mathvariant="normal">。</mi></mrow><annotation encoding="application/x-tex">如果a,b均是正整数且互质，那么由ax十by,x≥0，y≥0不能凑出的最大数是ab一a一b。
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">果</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mord cjk_fallback">均</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">正</span><span class="mord cjk_fallback">整</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">且</span><span class="mord cjk_fallback">互</span><span class="mord cjk_fallback">质</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">那</span><span class="mord cjk_fallback">么</span><span class="mord cjk_fallback">由</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">十</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">能</span><span class="mord cjk_fallback">凑</span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">大</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">是</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord cjk_fallback">一</span><span class="mord mathdefault">a</span><span class="mord cjk_fallback">一</span><span class="mord mathdefault">b</span><span class="mord cjk_fallback">。</span></span></span></span></span></p>
</li>
</ul>
<figure data-type="image" tabindex="47"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230129204554603.png" alt="image-20230129204554603" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

int n, m;
typedef long long LL;

int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    LL res = (LL)n * m - n -m;
    printf(&quot;%lld&quot;, res);
    
    return 0;
}
</code></pre>
<h3 id="例题-1211-蚂蚁感冒">例题 1211. 蚂蚁感冒</h3>
<p><a href="https://www.acwing.com/problem/content/1213/">1211. 蚂蚁感冒</a></p>
<figure data-type="image" tabindex="48"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230129210443101.png" alt="image-20230129210443101" loading="lazy"></figure>
<figure data-type="image" tabindex="49"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230129211316883.png" alt="image-20230129211316883" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 110;
int n;
int x[N];

int main()
{
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;x[i]);
    
    int left = 0, right = 0; // 分别表示左边向右走 和 右边向左走的 蚂蚁的数量
    for (int i = 0; i &lt; n; i ++ ) {
        if (abs(x[i]) &lt; abs(x[0]) &amp;&amp; x[i] &gt; 0) left ++;
        else if (abs(x[i]) &gt; abs(x[0]) &amp;&amp; x[i] &lt; 0) right ++;
    }
    
    if (x[0] &lt; 0 &amp;&amp; left == 0 || x[0] &gt; 0 &amp;&amp; right == 0) printf(&quot;%d\n&quot;, 1);
    else printf(&quot;%d&quot;, left + right + 1);
    
    return 0;
}
</code></pre>
<h3 id="例题-1216-饮料换购">例题 1216. 饮料换购</h3>
<p><a href="https://www.acwing.com/problem/content/1218/">1216. 饮料换购</a></p>
<figure data-type="image" tabindex="50"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230130132541351.png" alt="image-20230130132541351" loading="lazy"></figure>
<ul>
<li>
<p>模拟</p>
<ul>
<li><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230130132715913.png" alt="image-20230130132715913" loading="lazy"></li>
</ul>
</li>
<li>
<p>思路</p>
<ul>
<li><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230130132914119.png" alt="image-20230130132914119" loading="lazy"></li>
</ul>
</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;


int n;
int main()
{
    scanf(&quot;%d&quot;, &amp;n);
    int res = n;
    while (n &gt;= 3 ) {
        res += n / 3;
        n = n % 3 + n / 3;
    }
    
    printf(&quot;%d&quot;, res);
    
    return 0;
}
</code></pre>
<h2 id="简单dp">简单DP</h2>
<h3 id="01背包问题">01背包问题</h3>
<ul>
<li>每个物品最多用1次</li>
</ul>
<ol>
<li>状态表示 f(i, j)
<ol>
<li>集合</li>
<li>属性：max、min、数量</li>
</ol>
</li>
<li>状态计算 (如何把每一步的状态计算出来)</li>
</ol>
<h3 id="例题-2-01背包问题">例题 2. 01背包问题</h3>
<p><a href="https://www.acwing.com/problem/content/2/">2. 01背包问题</a></p>
<figure data-type="image" tabindex="53"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230130145004998.png" alt="image-20230130145004998" loading="lazy"></figure>
<figure data-type="image" tabindex="54"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230130220732663.png" alt="image-20230130220732663" loading="lazy"></figure>
<figure data-type="image" tabindex="55"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230130144955793.png" alt="image-20230130144955793" loading="lazy"></figure>
<figure data-type="image" tabindex="56"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230130150025911.png" alt="image-20230130150025911" loading="lazy"></figure>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mo separator="true">,</mo><mi>f</mi><mo>(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><msub><mi>v</mi><mi>i</mi></msub><mo>)</mo><mo>+</mo><msub><mi>w</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">f(i, j) = max(f(i - 1, j), f(i - 1, j - v_i)+w_i)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<ul>
<li>二维写法</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 1010;

int n, m; // 表示物品数量和背包容积
int v[N], w[N];
int f[N][N];

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m); 
    for (int i = 1; i &lt;= n; i ++ ) {
        scanf(&quot;%d%d&quot;, &amp;v[i], &amp;w[i]);
    }
    
    // 由于 f[0][0~m] 表示选0个的最大价值，故都为0
    for (int i = 1; i &lt;= n; i ++ ) {
        for (int j = 0; j &lt;= m; j ++ ) {
            f[i][j] = f[i - 1][j];
            // 如果 j &gt; v[i] 则表示还可以放第i个
            if (j &gt;= v[i] ) {
                f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);
            }
        }
    }
    printf(&quot;%d&quot;, f[n][m]);
    
    return 0;
}
</code></pre>
<ul>
<li>一维写法（f(i) 只用到了f(i - 1））可以使用滚动数组</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 1010;

int n, m; // 表示物品数量和背包容积
int v[N], w[N];
int f[N];

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m); 
    for (int i = 1; i &lt;= n; i ++ ) {
        scanf(&quot;%d%d&quot;, &amp;v[i], &amp;w[i]);
    }
    
    for (int i = 1; i &lt;= n; i ++ ) {
        for (int j = m; j &gt;= v[i]; j --) 
            f[j] = max(f[j], f[j - v[i]] + w[i]);
    }
    printf(&quot;%d&quot;, f[m]);
    
    return 0;
}
</code></pre>
<h3 id="例题-1015-摘花生">例题 1015. 摘花生</h3>
<p><a href="https://www.acwing.com/problem/content/1017/">1015. 摘花生</a></p>
<p>Hello Kitty想摘点花生送给她喜欢的米老鼠。</p>
<p>她来到一片有网格状道路的矩形花生地(如下图)，从西北角进去，东南角出来。</p>
<p>地里每个道路的交叉点上都有种着一株花生苗，上面有若干颗花生，经过一株花生苗就能摘走该它上面所有的花生。</p>
<p>Hello Kitty只能向东或向南走，不能向西或向北走。</p>
<p>问Hello Kitty最多能够摘到多少颗花生。</p>
<figure data-type="image" tabindex="57"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/19_a8509f26d5-1.gif" alt="1.gif" loading="lazy"></figure>
<h4 id="输入格式-2">输入格式</h4>
<p>第一行是一个整数T，代表一共有多少组数据。</p>
<p>接下来是T组数据。</p>
<p>每组数据的第一行是两个整数，分别代表花生苗的行数R和列数 C。</p>
<p>每组数据的接下来R行数据，从北向南依次描述每行花生苗的情况。每行数据有C个整数，按从西向东的顺序描述了该行每株花生苗上的花生数目M。</p>
<h4 id="输出格式-2">输出格式</h4>
<p>对每组输入数据，输出一行，内容为Hello Kitty能摘到得最多的花生颗数。</p>
<h4 id="数据范围-2">数据范围</h4>
<p>1≤T≤100<br>
1≤R,C≤100<br>
0≤M≤1000</p>
<h4 id="输入样例-2">输入样例：</h4>
<pre><code>2
2 2
1 1
3 4
2 3
2 3 4
1 6 5
</code></pre>
<h4 id="输出样例-2">输出样例：</h4>
<pre><code>8
16
</code></pre>
<figure data-type="image" tabindex="58"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230130221623273.png" alt="image-20230130221623273" loading="lazy"></figure>
<ul>
<li>
<p>状态表示</p>
<ul>
<li><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230130165947282.png" alt="image-20230130165947282" loading="lazy"></li>
</ul>
</li>
<li>
<p>状态计算</p>
<ul>
<li><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230130170618569.png" alt="image-20230130170618569" loading="lazy"></li>
</ul>
</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 110;

int n, m;
int w[N][N];
int f[N][N];

int main()
{
    int T;
    scanf(&quot;%d&quot;, &amp;T);
    
    while (T --) {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m); 
        // 初始化权重数组
        
        for (int i = 1; i &lt;= n; i ++ )
            for (int j = 1; j &lt;= m; j ++ ) 
                scanf(&quot;%d&quot;, &amp;w[i][j]);
        
        // 进行dp
        for (int i = 1; i &lt;= n; i ++ ) {
            for (int j = 1; j &lt;= m; j ++ ) {
                f[i][j] = max(f[i - 1][j], f[i][j - 1]) + w[i][j];
            }
        }
        
        printf(&quot;%d\n&quot;, f[n][m]);
    }
    return 0;
}
</code></pre>
<h3 id="例题-895-最长上升子序列">例题 895. 最长上升子序列</h3>
<p><a href="https://www.acwing.com/problem/content/897/">895. 最长上升子序列 </a></p>
<p>给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少。</p>
<h4 id="输入格式-3">输入格式</h4>
<p>第一行包含整数 N。</p>
<p>第二行包含 N 个整数，表示完整序列。</p>
<h4 id="输出格式-3">输出格式</h4>
<p>输出一个整数，表示最大长度。</p>
<h4 id="数据范围-3">数据范围</h4>
<p>1≤N≤1000，<br>
−10<sup>9≤数列中的数≤10</sup>9</p>
<h4 id="输入样例-3">输入样例：</h4>
<pre><code>7
3 1 2 1 8 5 6
</code></pre>
<h4 id="输出样例-3">输出样例：</h4>
<pre><code>4
</code></pre>
<figure data-type="image" tabindex="61"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230130183608958.png" alt="image-20230130183608958" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 1010;

int n;
int a[N], f[N];

int main()
{
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]);
    
    // dp
    for (int i = 1; i &lt;= n; i ++ ) {
        f[i] = 1;
        for (int j = 1; j &lt; i; j ++) {
            if (a[j] &lt; a[i]) f[i] = max(f[i], f[j] + 1);
        }
    }
    
    // 寻找最大值
    int res = 0;
    for (int i = 1; i &lt;= n; i ++ ) res = max(res, f[i]);
    
    printf(&quot;%d&quot;, res);
    
    return 0;
}
</code></pre>
<h3 id="习题-1212-地宫取宝">习题 1212. 地宫取宝</h3>
<p><a href="https://www.acwing.com/problem/content/1214/">1212. 地宫取宝</a></p>
<p>X 国王有一个地宫宝库，是 n×m个格子的矩阵，每个格子放一件宝贝，每个宝贝贴着价值标签。</p>
<p>地宫的入口在左上角，出口在右下角。</p>
<p>小明被带到地宫的入口，国王要求他只能向右或向下行走。</p>
<p>走过某个格子时，如果那个格子中的宝贝价值比小明手中任意宝贝价值都大，小明就可以拿起它（当然，也可以不拿）。</p>
<p>当小明走到出口时，如果他手中的宝贝恰好是 k件，则这些宝贝就可以送给小明。</p>
<p>请你帮小明算一算，在给定的局面下，他有多少种不同的行动方案能获得这 k件宝贝。</p>
<h4 id="输入格式-4">输入格式</h4>
<p>第一行 33 个整数，n,m,k，含义见题目描述。</p>
<p>接下来 n行，每行有 m个整数 Ci用来描述宝库矩阵每个格子的宝贝价值。</p>
<h4 id="输出格式-4">输出格式</h4>
<p>输出一个整数，表示正好取 k� 个宝贝的行动方案数。</p>
<p>该数字可能很大，输出它对 10000000071000000007 取模的结果。</p>
<h4 id="数据范围-4">数据范围</h4>
<p>1≤n,m≤50<br>
1≤k≤12<br>
0≤Ci≤12</p>
<h4 id="输入样例1">输入样例1：</h4>
<pre><code>2 2 2
1 2
2 1
</code></pre>
<h4 id="输出样例1">输出样例1：</h4>
<pre><code>2
</code></pre>
<h4 id="输入样例2">输入样例2：</h4>
<pre><code>2 3 2
1 2 3
2 1 5
</code></pre>
<h4 id="输出样例2">输出样例2：</h4>
<pre><code>14
</code></pre>
<figure data-type="image" tabindex="62"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230130225212156.png" alt="image-20230130225212156" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 55, MOD = 1000000007;

int n, m, k;
int w[N][N];
int f[N][N][13][14];

int main()
{
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);
    // 初始化权重矩阵
    
    for (int i = 1; i &lt;= n; i ++) {
        for (int j = 1; j &lt;= m; j ++) {
            scanf(&quot;%d&quot;, &amp;w[i][j]);
            w[i][j] ++; // 防止出现-1 错误
        }
    }
    
    // 边界初始化
    f[1][1][1][w[1][1]] = 1;  // 第一个取
    f[1][1][0][0] = 1;
    
    // dp
    for (int i = 1; i &lt;= n; i ++) {
        for (int j = 1; j &lt;= m ; j ++) {
            if (i == 1 &amp;&amp; j == 1) continue;
            for (int u = 0; u &lt;= k; u ++) {
                for (int v = 0; v &lt;= 13; v ++) {
                    int &amp;val = f[i][j][u][v];
                    val = (val + f[i - 1][j][u][v]) % MOD;
                    val = (val + f[i][j - 1][u][v]) % MOD;
                    if (u &gt; 0 &amp;&amp; w[i][j] == v) {
                        for (int c = 0; c &lt; v; c ++) {
                            val = (val + f[i - 1][j][u - 1][c]) % MOD;
                            val = (val + f[i][j - 1][u - 1][c]) % MOD;
                        }
                    }
                }
            }
        }
    }
    
    int res = 0;
    for (int i = 0; i &lt;= 13; i ++) {
        res = (res + f[n][m][k][i]) % MOD;
    }
    
    printf(&quot;%d&quot;, res);
    
    return 0;
}
</code></pre>
<h3 id="习题-1214-波动数列">习题 1214. 波动数列</h3>
<p><a href="https://www.acwing.com/problem/content/1216/">1214. 波动数列</a></p>
<p>观察这个数列：</p>
<p>1 3 0 2 -1 1 -2 …</p>
<p>这个数列中后一项总是比前一项增加2或者减少3，<strong>且每一项都为整数</strong>。</p>
<p>栋栋对这种数列很好奇，他想知道长度为 n 和为 s 而且后一项总是比前一项增加 a或者减少 b的整数数列可能有多少种呢？</p>
<h4 id="输入格式-5">输入格式</h4>
<p>共一行，包含四个整数 n,s,a,b，含义如前面所述。</p>
<h4 id="输出格式-5">输出格式</h4>
<p>共一行，包含一个整数，表示满足条件的方案数。</p>
<p>由于这个数很大，请输出方案数除以 100000007 的余数。</p>
<h4 id="数据范围-5">数据范围</h4>
<p>1≤n≤1000<br>
−10<sup>9≤s≤10</sup>9<br>
1≤a,b≤10^6</p>
<h4 id="输入样例-4">输入样例：</h4>
<pre><code>4 10 2 3
</code></pre>
<h4 id="输出样例-4">输出样例：</h4>
<pre><code>2
</code></pre>
<h4 id="样例解释">样例解释</h4>
<p>两个满足条件的数列分别是2 4 1 3和7 4 1 -2。</p>
<figure data-type="image" tabindex="63"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230131000506977.png" alt="image-20230131000506977" loading="lazy"></figure>
<figure data-type="image" tabindex="64"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230131001018359.png" alt="image-20230131001018359" loading="lazy"></figure>
<figure data-type="image" tabindex="65"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230131001028462.png" alt="image-20230131001028462" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 1010, MOD = 100000007;
int f[N][N];

int get_mod(int a, int b) {
    return (a % b + b) % b;
}

int main()
{
    int n, s, a, b;
    scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;s, &amp;a, &amp;b);
    
    f[0][0] = 1;
    for (int i = 1; i &lt; n; i ++) {
        for (int j = 0; j &lt; n; j ++) // j 表示余数，取值范围从0~n-1 
            f[i][j] = (f[i - 1][get_mod(j - i * a, n)] + f[i - 1][get_mod(j + i * b, n)]) % MOD;
    }
    
    printf(&quot;%d&quot;, f[n - 1][get_mod(s, n)]);
    
    return 0;
}
</code></pre>
<h1 id="枚举-模拟与排序">枚举、模拟与排序</h1>
<h2 id="枚举">枚举</h2>
<h3 id="例题-1210-连号区间数">例题 1210. 连号区间数</h3>
<p><a href="https://www.acwing.com/problem/content/1212/">1210. 连号区间数</a></p>
<p>小明这些天一直在思考这样一个奇怪而有趣的问题：</p>
<p>在 1∼N 的某个排列中有多少个连号区间呢？</p>
<p>这里所说的连号区间的定义是：</p>
<p>如果区间 [L,R][�,�] 里的所有元素（即此排列的第 L个到第 R个元素）递增排序后能得到一个长度为 R−L+1的“连续”数列，则称这个区间连号区间。</p>
<p>当 N很小的时候，小明可以很快地算出答案，但是当 N变大的时候，问题就不是那么简单了，现在小明需要你的帮助。</p>
<h4 id="输入格式-6">输入格式</h4>
<p>第一行是一个正整数 N，表示排列的规模。</p>
<p>第二行是 N 个不同的数字 Pi，表示这 N个数字的某一排列。</p>
<h4 id="输出格式-6">输出格式</h4>
<p>输出一个整数，表示不同连号区间的数目。</p>
<h4 id="数据范围-6">数据范围</h4>
<p>1≤N≤10000,<br>
1≤Pi≤N1</p>
<h4 id="输入样例1-2">输入样例1：</h4>
<pre><code>4
3 2 4 1
</code></pre>
<h4 id="输出样例1-2">输出样例1：</h4>
<pre><code>7
</code></pre>
<h4 id="输入样例2-2">输入样例2：</h4>
<pre><code>5
3 4 2 5 1
</code></pre>
<h4 id="输出样例2-2">输出样例2：</h4>
<pre><code>9
</code></pre>
<h4 id="样例解释-2">样例解释</h4>
<p>第一个用例中，有 77 个连号区间分别是：[1,1],[1,2],[1,3],[1,4],[2,2],[3,3],[4,4]<br>
第二个用例中，有 99 个连号区间分别是：[1,1],[1,2],[1,3],[1,4],[1,5],[2,2],[3,3],[4,4],[5,5]</p>
<figure data-type="image" tabindex="66"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230131185746568.png" alt="image-20230131185746568" loading="lazy"></figure>
<ul>
<li>
<p>暴力做法</p>
<ul>
<li><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230131185917643.png" alt="image-20230131185917643" loading="lazy"></li>
</ul>
</li>
<li>
<p>优化</p>
<ul>
<li>[a, b] 区间Max - Min == b - a</li>
<li><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230131190528380.png" alt="image-20230131190528380" loading="lazy"></li>
</ul>
</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 10010, INF = 1e9; //  定义最大值

int n;
int a[N];

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;a[i]);

	int res = 0;
	for (int i = 0; i &lt; n; i ++) {
		int maxv = -INF, minv = INF;
		for (int j = i; j &lt; n; j ++) {
			// 更新 最大值和最小值
			maxv = max(maxv, a[j]);
			minv = min(minv, a[j]);
			// 判断是否满足连号区间的条件
			if ((maxv - minv) == (j - i)) res ++;
		}
	}

	printf(&quot;%d\n&quot;, res);

	return 0;
}
</code></pre>
<h3 id="例题-1236-递增三元组">例题 1236. 递增三元组</h3>
<p><a href="https://www.acwing.com/problem/content/1238/">1236. 递增三元组</a></p>
<figure data-type="image" tabindex="69"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230131192135472.png" alt="image-20230131192135472" loading="lazy"></figure>
<figure data-type="image" tabindex="70"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230131194737449.png" alt="image-20230131194737449" loading="lazy"></figure>
<ul>
<li>暴力做法（3重for 循环）</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 10010; //  定义最大值

int n;
int a[N], b[N], c[N];

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;a[i]);
	for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;b[i]);
	for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;c[i]);

	int res = 0;
	
	for (int i = 0; i &lt; n; i ++) {
		for (int j = 0; j &lt; n; j ++) {
			for (int k = 0; k &lt; n; k ++) {
				if (a[i] &lt; b[j] &amp;&amp; b[j] &lt; c[k]) res ++;
			}
		}
	}

	printf(&quot;%d\n&quot;, res);

	return 0;
}
</code></pre>
<ul>
<li>优化-方法1（前缀和）
<ul>
<li>使用cnt数组，cnt[i] 表示在A 中，i 这个值出现多少次</li>
<li>前缀和数组 s， s[i] = cnt[0] + cnt[1] + .. + cnt[i - 1] + cnt[i]，表示A中，从0-i 出现多少次</li>
</ul>
</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 1e5+10;
typedef long long LL;

int n;
int a[N], b[N], c[N];
int as[N], cs[N];
int cnt[N], s[N]; // cnt[a[i]] 表示在数组a[]中a[i] 出现的次数

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	// a[i] 数据范围从0~1e5，故每项++，可以保证数据均大于0
	for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;a[i]), a[i] ++;
	for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;b[i]), b[i] ++;
	for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;c[i]), c[i] ++;

	// 处理A
	for (int i = 0; i &lt; n; i ++) cnt[a[i]] ++;
	for (int i = 1; i &lt; N; i ++) s[i] = s[i - 1] + cnt[i];

	for (int i = 0; i &lt; n; i ++) as[i] = s[b[i] - 1];

	// 清空cnt 与 s，处理C
	memset(cnt, 0, sizeof cnt);
	memset(s, 0, sizeof s);

	for (int i = 0; i &lt; n; i ++) cnt[c[i]] ++;
	for (int i = 1; i &lt; N; i ++) s[i] = s[i - 1] + cnt[i];

	for (int i = 0; i &lt; n; i ++) cs[i] = s[N - 1] - s[b[i]];

	// 统计答案
	LL res = 0;
	
	for (int i = 0; i &lt; n; i ++) res += (LL) as[i] * cs[i];

	cout &lt;&lt; res &lt;&lt; endl;

	return 0;
}
</code></pre>
<ul>
<li>优化-方法2（排序 + 二分）</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

const int N = 1e5 + 5;
int a[N], b[N], c[N];
int n;

int main() {
    long long res = 0;
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i];
    for (int i = 0; i &lt; n; ++i) cin &gt;&gt; b[i];
    for (int i = 0; i &lt; n; ++i) cin &gt;&gt; c[i];

    sort(a, a + n), sort(b, b + n), sort(c, c + n); // 排序
    for (int i = 0; i &lt; n; ++i) {
        // 计算a比b小个数
        int t = b[i];
        int l = 0, r = n - 1;
        long long cnt = 1;
        while (l &lt; r) {
            int mid = l + r &gt;&gt; 1;
            if (a[mid] &gt;= t) r = mid;
            else l = mid + 1;
        }
        if (a[l] &gt;= t)
            cnt *= l;
        else cnt = n;

        // 计算c比b大个数
        t = b[i];
        l = 0, r = n - 1;
        while (l &lt; r) {
            int mid = l + r &gt;&gt; 1;
            if (c[mid] &gt; t) r = mid;
            else l = mid + 1;
        }
        if (c[l] &gt; t)
            cnt *= n - l;
        else continue;

        res += cnt;
    }
    cout &lt;&lt; res &lt;&lt; endl;
}
</code></pre>
<h3 id="例题-1245-特别数的和">例题 1245. 特别数的和</h3>
<p><a href="https://www.acwing.com/problem/content/1247/">1245. 特别数的和</a></p>
<figure data-type="image" tabindex="71"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230131220547202.png" alt="image-20230131220547202" loading="lazy"></figure>
<ul>
<li>暴力做法</li>
<li><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230131221243207.png" alt="image-20230131221243207" loading="lazy"></li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

int n;

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	int res = 0;
	for (int i = 1; i &lt;= n; i ++) {
		int x = i;
		// 将数字的每位取出来
		while (x) {
			int t = x % 10;
			x /= 10;
			if (t == 2 || t == 0 || t == 1 || t == 9) {
				res += i;
				break; // 找到即可退出取数的循环
			}
		}
	}
	printf(&quot;%d&quot;, res);

	return 0;
}
</code></pre>
<h3 id="例题-1204-错误票据">例题 1204. 错误票据</h3>
<p><a href="https://www.acwing.com/problem/content/1206/">1204. 错误票据</a></p>
<p>某涉密单位下发了某种票据，并要在年终全部收回。</p>
<p>每张票据有唯一的ID号。</p>
<p>全年所有票据的ID号是连续的，但ID的开始数码是随机选定的。</p>
<p>因为工作人员疏忽，在录入ID号的时候发生了一处错误，造成了某个ID断号，另外一个ID重号。</p>
<p>你的任务是通过编程，找出断号的ID和重号的ID。</p>
<p>假设断号不可能发生在最大和最小号。</p>
<h4 id="输入格式-7">输入格式</h4>
<p>第一行包含整数 N，表示后面共有 N行数据。</p>
<p>接下来 N行，每行包含空格分开的若干个（不大于100个）正整数（不大于100000），每个整数代表一个ID号。</p>
<h4 id="输出格式-7">输出格式</h4>
<p>要求程序输出1行，含两个整数 m,n，用空格分隔。</p>
<p>其中，m表示断号ID，n表示重号ID。</p>
<h4 id="数据范围-7">数据范围</h4>
<p>1≤N≤100</p>
<h4 id="输入样例-5">输入样例：</h4>
<pre><code>2
5 6 8 11 9 
10 12 9
</code></pre>
<h4 id="输出样例-5">输出样例：</h4>
<pre><code>7 9
</code></pre>
<ul>
<li>暴力做法：
<ul>
<li>设置状态数组，遍历后为true的为重号id</li>
<li>然后找到开始的数，从这个数字开始扫描，找到断号id</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="73"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230131233017462.png" alt="image-20230131233017462" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt; // 使用stringstream

using namespace std;

const int N = 10010, M = 100010; 
int n;
int a[N]; // 用于存放数据
bool st[M]; // 用于存放状态

int main() {
	int cnt;
	cin &gt;&gt; cnt;

	string line;
	getline(cin, line); // 由于第一行读入cnt之后，还剩下换行符

	while (cnt --) {
		getline(cin, line);
		stringstream ssin(line); // 类似cin

		while (ssin &gt;&gt; a[n]) n ++; // 依次读取数据
	}
	// 状态数组法
	int c = 0, d = 0;
	for (int i = 0; i &lt; n; i ++) {
		if (st[a[i]]) {
			c = a[i]; 
		}
		st[a[i]] = true; // 找到重号id
	}
	int start = 0;
	while (!st[start]) start ++; // 找到开始的位置

	for (int i = start; ; i ++) {
		if (!st[i]) {
			d = i; // 找到断号id
			break;
		}
	}

	cout &lt;&lt; d &lt;&lt; ' ' &lt;&lt; c &lt;&lt; endl;

	return 0;
}
</code></pre>
<ul>
<li>排序做法
<ul>
<li>排序后从第二个位置开始扫描，每次与前一个数字进行比较</li>
<li>如果相等则为重号id</li>
<li>如果大于等于前一个数字+2，则为断号id</li>
<li><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230131233524786.png" alt="image-20230131233524786" loading="lazy"></li>
</ul>
</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt; // 使用stringstream

using namespace std;

const int N = 10010, M = 100010; 
int n;
int a[N]; // 用于存放数据

int main() {
	int cnt;
	cin &gt;&gt; cnt;

	string line;
	getline(cin, line); // 由于第一行读入cnt之后，还剩下换行符

	while (cnt --) {
		getline(cin, line);
		stringstream ssin(line); // 类似cin

		while (ssin &gt;&gt; a[n]) n ++; // 依次读取数据
	}
	// 排序法
	sort(a, a + n);
	int d, c;
	for (int i = 1; i &lt; n; i ++) {
		if (a[i] == a[i - 1]) c = a[i];
		else if (a[i] &gt;= a[i - 1] + 2) d = a[i] - 1;
	}

	cout &lt;&lt; d &lt;&lt; ' ' &lt;&lt; c &lt;&lt; endl;

	return 0;
}
</code></pre>
<h3 id="例题-466-回文日期">例题 466. 回文日期</h3>
<p><a href="https://www.acwing.com/problem/content/468/">466. 回文日期</a></p>
<figure data-type="image" tabindex="75"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201000806225.png" alt="image-20230201000806225" loading="lazy"></figure>
<ul>
<li>思路：先枚举回文，然后再判断日期是否合法</li>
<li><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201001612097.png" alt="image-20230201001612097" loading="lazy"></li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

int days[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; // 每个月份对应日期
bool check_valid(int date) {
	// 分离年月日
	int year = date / 10000;
	int month = date % 10000 / 100;
	int day = date % 100;
	if (month == 0 || month &gt; 13) return false; // 无效月份
	if (day == 0 || month != 2 &amp;&amp; day &gt; days[month]) return false; // 非2月的无效日期
	if (month == 2) {
		int leap = year % 100 &amp;&amp; year % 4 == 0 || year % 400 == 0; //闰年为1
		if (day &gt; days[month] + leap) return false; // 2月的无效日期
	}
	return true;
}


int main() {
	int date1, date2;
	cin &gt;&gt; date1 &gt;&gt; date2;

	// 开始枚举年份
	int res = 0;
	for (int i = 1000; i &lt;= 9999; i ++) {
		int date = i, x = i;
		for (int i = 0; i &lt; 4; i ++) {
			// 将年份扩展为回文日期
			date = date * 10 + x % 10;
			x /= 10;
		}
		// 判断是否在所求范围内
		if (date1 &lt;= date  &amp;&amp; date &lt;= date2 &amp;&amp; check_valid(date)) res ++;
	}	
	cout &lt;&lt; res &lt;&lt; endl;

	return 0;
}
</code></pre>
<h2 id="排序">排序</h2>
<h3 id="例题-787-归并排序">例题 787. 归并排序</h3>
<p><a href="https://www.acwing.com/problem/content/789/">787. 归并排序</a></p>
<p>给定你一个长度为 n 的整数数列。</p>
<p>请你使用归并排序对这个数列按照从小到大进行排序。</p>
<p>并将排好序的数列按顺序输出。</p>
<h4 id="输入格式-8">输入格式</h4>
<p>输入共两行，第一行包含整数 n。</p>
<p>第二行包含 n个整数（所有整数均在 1∼1091∼109 范围内），表示整个数列。</p>
<h4 id="输出格式-8">输出格式</h4>
<p>输出共一行，包含 n 个整数，表示排好序的数列。</p>
<h4 id="数据范围-8">数据范围</h4>
<p>1≤n≤100000</p>
<h4 id="输入样例-6">输入样例：</h4>
<pre><code>5
3 1 2 4 5
</code></pre>
<h4 id="输出样例-6">输出样例：</h4>
<pre><code>1 2 3 4 5
</code></pre>
<figure data-type="image" tabindex="77"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201130348824.png" alt="image-20230201130348824" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

const int N = 100010;

int n;
int q[N], tmp[N];

void merge_sort(int q[], int l, int r) {
	// 归并排序
	if (l &gt;= r) return ;
	// 递归排序左、右
	int mid = (l + r) &gt;&gt; 1;
	merge_sort(q, l, mid), merge_sort(q, mid + 1, r);

	// 归并
	int k = 0, i = l, j = mid + 1; // k 表示归并的数量
	while (i &lt;= mid &amp;&amp; j &lt;= r) {
		if (q[i] &lt;= q[j]) tmp[k ++] = q[i ++];
		else tmp[k ++] = q[j ++];
	}
	// 合并归并完剩余的内容
	while (i &lt;= mid) tmp[k ++] = q[i ++];
	while (j &lt;= r) tmp[k ++] = q[j ++];

	// 将tmp数组复制回q数组
	for (int i = l, j = 0; i &lt;= r; i ++, j ++) q[i] = tmp[j];
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;q[i]);

	merge_sort(q, 0, n - 1); // 归并排序
	
	for (int i = 0; i &lt; n; i ++) printf(&quot;%d &quot;, q[i]);

	return 0;
}
</code></pre>
<h3 id="习题-1219-移动距离">习题 1219. 移动距离</h3>
<p><a href="https://www.acwing.com/problem/content/1221/">1219. 移动距离</a></p>
<figure data-type="image" tabindex="78"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201132723359.png" alt="image-20230201132723359" loading="lazy"></figure>
<figure data-type="image" tabindex="79"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201140302231.png" alt="image-20230201140302231" loading="lazy"></figure>
<ul>
<li>每个数减少1，如此数字从0开始，坐到与行号（从0开始）一致</li>
</ul>
<figure data-type="image" tabindex="80"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201140743776.png" alt="image-20230201140743776" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;

int main() {
	int w, m, n;
	scanf(&quot;%d%d%d&quot;, &amp;w, &amp;m, &amp;n);

	// 分别计算m 与 n 的坐标
	m --, n --; 
	int x1, y1, x2, y2;
	x1 = m / w, x2 = n / w;

	if (x1 % 2 == 0) y1 = m % w;
	else y1 = w - 1 - m % w;
	if (x2 % 2 == 0) y2 = n % w;
	else y2 = w - 1 - n % w;

	int res = abs(x1 - x2) + abs(y1 - y2);

	printf(&quot;%d\n&quot;, res);

	return 0;
}
</code></pre>
<h3 id="习题-1229-日期问题">习题 1229. 日期问题</h3>
<p><a href="https://www.acwing.com/problem/content/1231/">1229. 日期问题</a></p>
<p>小明正在整理一批历史文献。这些历史文献中出现了很多日期。</p>
<p>小明知道这些日期都在1960年1月1日至2059年12月31日。</p>
<p>令小明头疼的是，这些日期采用的格式非常不统一，有采用年/月/日的，有采用月/日/年的，还有采用日/月/年的。</p>
<p>更加麻烦的是，年份也都省略了前两位，使得文献上的一个日期，存在很多可能的日期与其对应。</p>
<p>比如02/03/04，可能是2002年03月04日、2004年02月03日或2004年03月02日。</p>
<p>给出一个文献上的日期，你能帮助小明判断有哪些可能的日期对其对应吗？</p>
<h4 id="输入格式-9">输入格式</h4>
<p>一个日期，格式是”AA/BB/CC”。</p>
<p>即每个’/’隔开的部分由两个 0-9 之间的数字（不一定相同）组成。</p>
<h4 id="输出格式-9">输出格式</h4>
<p>输出若干个不相同的日期，每个日期一行，格式是”yyyy-MM-dd”。</p>
<p>多个日期按从早到晚排列。</p>
<h4 id="数据范围-9">数据范围</h4>
<p>0≤A,B,C≤9</p>
<h4 id="输入样例-7">输入样例：</h4>
<pre><code>02/03/04
</code></pre>
<h4 id="输出样例-7">输出样例：</h4>
<pre><code>2002-03-04
2004-02-03
2004-03-02
</code></pre>
<figure data-type="image" tabindex="81"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201142952161.png" alt="image-20230201142952161" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;

int a, b, c;
int days[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

bool check_valid(int year, int month, int day) {
	if (month == 0 || month &gt; 12) return false; // 月份无效
	if (month != 2) {
		// 先判断非2月的天数是否有效
		if (day == 0 || day &gt; days[month]) return false;
	} else {
		// 判断2月
		int leap = year % 100 &amp;&amp; year % 4 == 0 || year % 400 == 0; // 闰年
		if (day == 0 || day &gt; days[month] + leap) return false;
	}
	return true;
}

int main() {
	scanf(&quot;%d/%d/%d&quot;, &amp;a, &amp;b, &amp;c); // 表示从a/b/c取得a、b、c
	for (int i = 19600101; i &lt;= 20591231; i ++) {
		int year = i / 10000, month = i % 10000 / 100, day = i % 100;
		if (check_valid(year, month, day)) {
			if (year % 100 == a &amp;&amp; month == b &amp;&amp; day == c || // 年月日表示法
				month == a &amp;&amp; day == b &amp;&amp; year % 100 == c || // 月日年表示法
				day == a &amp;&amp; month == b &amp;&amp; year % 100 == c // 日月年表示法
				) {
				printf(&quot;%d-%02d-%02d\n&quot;, year, month, day);
			}
		}
	}

	return 0;
}
</code></pre>
<h3 id="习题-1231-航班时间">习题 1231. 航班时间</h3>
<p><a href="https://www.acwing.com/problem/content/1233/">1231. 航班时间</a></p>
<p>小 ℎ 前往美国参加了蓝桥杯国际赛。</p>
<p>小 ℎ 的女朋友发现小 ℎ 上午十点出发，上午十二点到达美国，于是感叹到“现在飞机飞得真快，两小时就能到美国了”。</p>
<p>小 ℎ 对超音速飞行感到十分恐惧。</p>
<p>仔细观察后发现飞机的起降时间都是当地时间。</p>
<p>由于北京和美国东部有 12 小时时差，故飞机总共需要 14小时的飞行时间。</p>
<p>不久后小 ℎ 的女朋友去中东交换。</p>
<p>小 ℎ 并不知道中东与北京的时差。</p>
<p>但是小 ℎ 得到了女朋友来回航班的起降时间。</p>
<p>小 ℎ 想知道女朋友的航班飞行时间是多少。</p>
<p>对于一个可能跨时区的航班，给定来回程的起降时间。</p>
<p>假设飞机来回飞行时间相同，求飞机的飞行时间。</p>
<h4 id="输入格式-10">输入格式</h4>
<p>一个输入包含多组数据。</p>
<p>输入第一行为一个正整数 T，表示输入数据组数。</p>
<p>每组数据包含两行，第一行为去程的起降时间，第二行为回程的起降时间。</p>
<p>起降时间的格式如下:</p>
<ol>
<li>h1:m1:s1 h2:m2:s2</li>
<li>h1:m1:s1 h3:m3:s3 (+1)</li>
<li>h1:m1:s1 h4:m4:s4 (+2)</li>
</ol>
<p>第一种格式表示该航班在<strong>当地</strong>时间h1时m1分s1秒起飞，在<strong>当地</strong>时间<strong>当日</strong>h2时m2分s2秒降落。</p>
<p>第二种格式表示该航班在<strong>当地</strong>时间h1时m1分s1秒起飞，在<strong>当地</strong>时间<strong>次日</strong>h2时m2分s2秒降落。</p>
<p>第三种格式表示该航班在<strong>当地</strong>时间h1时m1分s1秒起飞，在<strong>当地</strong>时间<strong>第三日</strong>h2时m2分s2秒降落。</p>
<h4 id="输出格式-10">输出格式</h4>
<p>对于每一组数据输出一行一个时间hh:mm:ss，表示飞行时间为hh小时mm分ss秒。</p>
<p>注意，当时间为一位数时，要补齐前导零，如三小时四分五秒应写为03:04:05。</p>
<h4 id="数据范围-10">数据范围</h4>
<p>保证输入时间合法（0≤h≤23,0≤m,s≤59），飞行时间不超过24小时。</p>
<h4 id="输入样例-8">输入样例：</h4>
<pre><code>3
17:48:19 21:57:24
11:05:18 15:14:23
17:21:07 00:31:46 (+1)
23:02:41 16:13:20 (+1)
10:19:19 20:41:24
22:19:04 16:41:09 (+1)
</code></pre>
<h4 id="输出样例-8">输出样例：</h4>
<pre><code>04:09:05
12:10:39
14:22:05
</code></pre>
<figure data-type="image" tabindex="82"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201152436097.png" alt="image-20230201152436097" loading="lazy"></figure>
<figure data-type="image" tabindex="83"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201152821548.png" alt="image-20230201152821548" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;

int get_seconds(int h, int m, int s) {
	return h * 3600 + m * 60 + s; // 将时间转化为秒
}

int get_time() {
	string line;
	getline(cin, line);
	if (line.back() != ')') line += &quot; (+0)&quot;; // 格式保持一致
	int h1, m1, s1, h2, m2, s2, d;
	sscanf(line.c_str(), &quot;%d:%d:%d %d:%d:%d (+%d)&quot;, &amp;h1, &amp;m1, &amp;s1, &amp;h2, &amp;m2, &amp;s2, &amp;d);
	return get_seconds(h2, m2, s2) - get_seconds(h1, m1, s1) + 24 * 3600 * d;
}

int main() {
	int n;
	scanf(&quot;%d&quot;, &amp;n);
	string line;
	getline(cin, line); // 读入第一行的换行

	while (n --) {
		int time = (get_time() + get_time()) / 2;
		int h = time / 3600, m = time % 3600 / 60, s = time % 60;
		printf(&quot;%02d:%02d:%02d\n&quot;, h, m, s);
	}

	return 0;
}
</code></pre>
<h3 id="习题-1241-外卖店优先级">习题 1241. 外卖店优先级</h3>
<p><a href="https://www.acwing.com/problem/content/1243/">1241. 外卖店优先级 </a></p>
<p>“饱了么”外卖系统中维护着 N 家外卖店，编号 1∼N。</p>
<p>每家外卖店都有一个优先级，初始时 (0 时刻) 优先级都为 0。</p>
<p>每经过 1 个时间单位，如果外卖店没有订单，则优先级会减少 1，最低减到 0；而如果外卖店有订单，则优先级不减反加，每有一单优先级加 2。</p>
<p>如果某家外卖店某时刻优先级大于 5，则会被系统加入优先缓存中；如果优先级小于等于 3，则会被清除出优先缓存。</p>
<p>给定 T时刻以内的 M 条订单信息，请你计算 T 时刻时有多少外卖店在优先缓存中。</p>
<h4 id="输入格式-11">输入格式</h4>
<p>第一行包含 33 个整数 N,M,T。</p>
<p>以下 M 行每行包含两个整数 ts 和 id，表示 ts 时刻编号 id 的外卖店收到一个订单。</p>
<h4 id="输出格式-11">输出格式</h4>
<p>输出一个整数代表答案。</p>
<h4 id="数据范围-11">数据范围</h4>
<p>1≤N,M,T≤105<br>
1≤ts≤T<br>
1≤id≤N</p>
<h4 id="输入样例-9">输入样例：</h4>
<pre><code>2 6 6
1 1
5 2
3 1
6 2
2 1
6 2
</code></pre>
<h4 id="输出样例-9">输出样例：</h4>
<pre><code>1
</code></pre>
<h4 id="样例解释-3">样例解释</h4>
<p>6 时刻时，1号店优先级降到 3，被移除出优先缓存；2 号店优先级升到 6，加入优先缓存。</p>
<p>所以是有 1家店 (2 号) 在优先缓存中。</p>
<ul>
<li>
<p>暴力模拟</p>
<ul>
<li><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201155717680.png" alt="image-20230201155717680" loading="lazy"></li>
</ul>
</li>
<li>
<p>优化（将连续一段时间没有订单的店铺，统一到下次一有订单时处理）</p>
<ul>
<li><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201161324702.png" alt="image-20230201161324702" loading="lazy"></li>
</ul>
</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

#define x first
#define y second

using namespace std;

typedef pair&lt;int, int&gt; PII;

const int N = 1e5 + 10;

PII order[N]; // 存储订单数组
int score[N], last[N];
bool st[N]; // 是否在有限缓存中

int main() {
	int n, m, T;
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;T);
	for (int i = 0; i &lt; m; i ++) scanf(&quot;%d%d&quot;, &amp;order[i].x, &amp;order[i].y); // 读入订单
	sort(order, order + m); // 对订单数组按时间排序

	for (int i = 0; i &lt; m; ) {
		int j = i;
		while (j &lt; m &amp;&amp; order[j].y == order[i].y) j ++; // 是为了算出来同一时刻同一家店的订单数量，
		int t = order[i].x, id = order[i].y, cnt = j - i; // 数量就是cnt的值，这个数量可能不唯一
		i = j; // 继续下一个时刻的循环

		score[id] -= t - last[id] - 1; 
		if (score[id] &lt; 0) score[id] = 0;
		if (score[id] &lt;= 3) st[id] = false; // 以上处理t 时刻以前的内容


		score[id] += cnt * 2;
		if (score[id] &gt; 5) st[id] = true;
		last[id] = t;
	}

	for (int i = 1; i &lt;= n; i ++) {
		if (last[i] &lt; T) {
			score[i] -= T - last[i];
			if (score[i] &lt;= 3) st[i] = false;
		}
	}
	int res = 0;
	for (int i = 1; i &lt;= n; i ++) res += st[i];

	printf(&quot;%d&quot;, res);

	return 0;
}
</code></pre>
<h3 id="习题-788-逆序对的数量">习题 788. 逆序对的数量</h3>
<p><a href="https://www.acwing.com/problem/content/790/">788. 逆序对的数量</a></p>
<figure data-type="image" tabindex="86"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201171806294.png" alt="image-20230201171806294" loading="lazy"></figure>
<figure data-type="image" tabindex="87"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201172612170.png" alt="image-20230201172612170" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

typedef long long LL;

const int N = 100010;

int n;
int q[N], tmp[N];



LL merge_sort(int l, int r) {
	if (l &gt;= r) return 0; // 终止位置
	int mid = (l + r) &gt;&gt; 1;

	LL res = merge_sort(l, mid) + merge_sort(mid + 1, r);
	// 归并过程
	int k = 0, i = l, j = mid + 1;
	while (i &lt;= mid &amp;&amp; j &lt;= r) {
		if (q[i] &lt;= q[j]) tmp[k ++] = q[i ++];
		else {
			tmp[k ++] = q[j ++];
			res += mid - i + 1;
		}
	}
	// 归并扫尾
	while (i &lt;= mid) tmp[k ++] = q[i ++];
	while (j &lt;= r) tmp[k ++] = q[j ++];

	// 恢复
	for (int i = l, j = 0; i &lt;= r; i ++, j ++) q[i] = tmp[j];

	return res;
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);

	for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;q[i]);

	cout &lt;&lt; merge_sort(0, n - 1) &lt;&lt; endl;

	return 0;
}
</code></pre>
<h1 id="树状数组与线段树">树状数组与线段树</h1>
<h2 id="树状数组">树状数组</h2>
<p>快速求前缀和</p>
<figure data-type="image" tabindex="88"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201195910674.png" alt="image-20230201195910674" loading="lazy"></figure>
<figure data-type="image" tabindex="89"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201201141527.png" alt="image-20230201201141527" loading="lazy"></figure>
<figure data-type="image" tabindex="90"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201201439806.png" alt="image-20230201201439806" loading="lazy"></figure>
<figure data-type="image" tabindex="91"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201204233325.png" alt="image-20230201204233325" loading="lazy"></figure>
<h3 id="树状数组核心函数">树状数组核心函数</h3>
<h4 id="lowbitint-x">lowbit(int x)</h4>
<pre><code class="language-c++">int lowbit(int x) {
	return x &amp; -x;
}
</code></pre>
<h4 id="addint-x-int-v">add(int x, int v)</h4>
<pre><code class="language-c++">void add (int x, int v) {
	// 在x 位置 加上v
	for (int i = x; i &lt;= n; i += lowbit(i)) tr[i] += v;
}
</code></pre>
<h4 id="queryint-x">query(int x)</h4>
<pre><code class="language-c++">int query(int x) {
	// 求前缀和
	int res = 0;
	for (int i = x; i; i -= lowbit(i)) res += tr[i];

	return res;
}
</code></pre>
<h3 id="例题-1264-动态求连续区间和">例题 1264. 动态求连续区间和</h3>
<p><a href="https://www.acwing.com/problem/content/1266/">1264. 动态求连续区间和</a></p>
<figure data-type="image" tabindex="92"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201205457652.png" alt="image-20230201205457652" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 100010;

int n, m;
int a[N], tr[N];

int lowbit(int x) {
	return x &amp; -x;
}

void add (int x, int v) {
	// 在x 位置 加上v
	for (int i = x; i &lt;= n; i += lowbit(i)) tr[i] += v;
}

int query(int x) {
	// 求前缀和
	int res = 0;
	for (int i = x; i; i -= lowbit(i)) res += tr[i];

	return res;
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]); // 读入原数组
	for (int i = 1; i &lt;= n; i ++) add(i, a[i]); // 初始化树状数组

	while (m --) {
		int k, x, y;
		scanf(&quot;%d%d%d&quot;, &amp;k, &amp;x, &amp;y);
		if (k == 0) {
			printf(&quot;%d\n&quot;, query(y) - query(x - 1));
		} else if (k == 1) {
			add(x, y);
		}
	}

	return 0;
}
</code></pre>
<h3 id="例题-1265-数星星">例题 1265. 数星星</h3>
<p><a href="https://www.acwing.com/problem/content/1267/">1265. 数星星</a></p>
<p>天空中有一些星星，这些星星都在不同的位置，每个星星有个坐标。</p>
<p>如果一个星星的左下方（包含正左和正下）有 k 颗星星，就说这颗星星是 k 级的。</p>
<figure data-type="image" tabindex="93"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/19_6f40991a1c-1.png" alt="1.png" loading="lazy"></figure>
<p>例如，上图中星星 5是 3级的（1,2,4在它左下），星星 2,4是 11 级的。</p>
<p>例图中有 1 个 0级，2个 1级，1个 2级，1个 3级的星星。</p>
<p>给定星星的位置，输出各级星星的数目。</p>
<p>换句话说，给定 N 个点，定义每个点的等级是在该点左下方（含正左、正下）的点的数目，试统计每个等级有多少个点。</p>
<h4 id="输入格式-12">输入格式</h4>
<p>第一行一个整数 N，表示星星的数目；</p>
<p>接下来 N行给出每颗星星的坐标，坐标用两个整数 x,y 表示；</p>
<p>不会有星星重叠。星星按 y坐标增序给出，y坐标相同的按 x坐标增序给出。</p>
<h4 id="输出格式-12">输出格式</h4>
<p>N行，每行一个整数，分别是 0 级，1级，2级，……，N−1 级的星星的数目。</p>
<h4 id="数据范围-12">数据范围</h4>
<p>1≤N≤15000<br>
0≤x,y≤320000</p>
<h4 id="输入样例-10">输入样例：</h4>
<pre><code>5
1 1
5 1
7 1
3 3
5 5
</code></pre>
<h4 id="输出样例-10">输出样例：</h4>
<pre><code>1
2
1
1
0
</code></pre>
<figure data-type="image" tabindex="94"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230201224648773.png" alt="image-20230201224648773" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 32010;

int n;
int level[N], tr[N];

int lowbit(int x) {
	return x &amp; -x;
}

void add (int x) {
	// 在x 位置 加上v
	for (int i = x; i &lt; N; i += lowbit(i)) tr[i] ++;
}

int query(int x) {
	// 求前缀和
	int res = 0;
	for (int i = x; i; i -= lowbit(i)) res += tr[i];

	return res;
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 0; i &lt; n; i ++) {
		int x, y;
		scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
		x ++;
		level[query(x)]++;
		add(x);
	}

	for (int i = 0; i &lt; n; i ++) printf(&quot;%d\n&quot;, level[i]);

	return 0;
}
</code></pre>
<h3 id="习题-1215-小朋友排队">习题 1215. 小朋友排队</h3>
<p><a href="https://www.acwing.com/problem/content/1217/">1215. 小朋友排队</a></p>
<p>n个小朋友站成一排。</p>
<p>现在要把他们按身高从低到高的顺序排列，但是每次只能交换位置相邻的两个小朋友。</p>
<p>每个小朋友都有一个不高兴的程度。</p>
<p>开始的时候，所有小朋友的不高兴程度都是 0。</p>
<p>如果某个小朋友第一次被要求交换，则他的不高兴程度增加 1，如果第二次要求他交换，则他的不高兴程度增加 2（即不高兴程度为 3），依次类推。当要求某个小朋友第 k次交换时，他的不高兴程度增加 k。</p>
<p>请问，要让所有小朋友按从低到高排队，他们的不高兴程度之和最小是多少。</p>
<p>如果有两个小朋友身高一样，则他们谁站在谁前面是没有关系的。</p>
<h4 id="输入格式-13">输入格式</h4>
<p>输入的第一行包含一个整数 n，表示小朋友的个数。</p>
<p>第二行包含 n个整数 H1,H2,…,Hn，分别表示每个小朋友的身高。</p>
<h4 id="输出格式-13">输出格式</h4>
<p>输出一行，包含一个整数，表示小朋友的不高兴程度和的最小值。</p>
<h4 id="数据范围-13">数据范围</h4>
<p>1≤n≤100000,<br>
0≤Hi≤1000000</p>
<h4 id="输入样例-11">输入样例：</h4>
<pre><code>3
3 2 1
</code></pre>
<h4 id="输出样例-11">输出样例：</h4>
<pre><code>9
</code></pre>
<h4 id="样例解释-4">样例解释</h4>
<p>首先交换身高为3和2的小朋友，再交换身高为3和1的小朋友，再交换身高为2和1的小朋友，每个小朋友的不高兴程度都是3，总和为9。</p>
<figure data-type="image" tabindex="95"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203185220944.png" alt="image-20230203185220944" loading="lazy"></figure>
<figure data-type="image" tabindex="96"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203185758380.png" alt="image-20230203185758380" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;
const int N = 1000010; // 小朋友的身高为0≤Hi≤1000000

int n;
int h[N], tr[N], sum[N]; //sum数组存储每个小朋友的不高兴度

int lowbit(int x) {
	return x &amp; -x;
}

void add(int x, int v) {
	for (int i = x; i &lt; N; i += lowbit(i)) tr[i] += v; 
}

int query(int x) {
	int res = 0;
	for (int i = x; i; i -= lowbit(i)) res += tr[i]; // 由于是个数，所以不需要使用LL

	return res;
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);

	for (int i = 0; i &lt; n; i ++) {
		scanf(&quot;%d&quot;, &amp;h[i]);
		h[i] ++;
	}

	// 求每个数前面有多少比它大
	for (int i = 0; i &lt; n; i ++) {
		sum[i] = query(N - 1) - query(h[i]);
		add(h[i], 1);
	}

	// 求每个数后面有多少比它小
	memset(tr, 0, sizeof tr);

	for (int i = n - 1; i&gt;= 0; i --) {
		sum[i] += query(h[i] - 1);
		add(h[i], 1);
	}

	LL res = 0;
	for (int i = 0; i &lt; n; i ++) res += (LL) sum[i] * (sum[i] + 1) / 2;

	printf(&quot;%lld\n&quot;, res);

	return 0;
}
</code></pre>
<h2 id="线段树">线段树</h2>
<figure data-type="image" tabindex="97"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203161448365.png" alt="image-20230203161448365" loading="lazy"></figure>
<h3 id="线段树-核心操作">线段树 核心操作</h3>
<h4 id="单点修改">单点修改</h4>
<figure data-type="image" tabindex="98"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203163005151.png" alt="image-20230203163005151" loading="lazy"></figure>
<h4 id="区间查询">区间查询</h4>
<figure data-type="image" tabindex="99"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203163210009.png" alt="image-20230203163210009" loading="lazy"></figure>
<h3 id="线段树-核心函数">线段树 核心函数</h3>
<h4 id="pushup用子节点信息更新当前节点信息">pushup：用子节点信息更新当前节点信息</h4>
<pre><code class="language-c++">void pushup(int u) {
	tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum;
	// 左儿子 u &lt;&lt; 1， 右儿子 u &lt;&lt; 1 | 1 之和
}
</code></pre>
<h4 id="build在一段区间上初始化线段树">build：在一段区间上初始化线段树</h4>
<pre><code class="language-c++">void build(int u, int l, int r) {
	lf (l == r) tr[u] = {l, r, w[l]}; // 表示是叶子节点, 注意是w[l] 或w[r]， u 是线段树的下标
	else {
		int mid = l + r &gt;&gt; 1; // 找到分界点
		build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);// 递归建立左右儿子
		pushup(u);
	}
}
</code></pre>
<h4 id="modify修改">modify：修改</h4>
<pre><code class="language-c++">
</code></pre>
<h4 id="query查询">query：查询</h4>
<pre><code class="language-c++">
</code></pre>
<h3 id="例题-1264-动态求连续区间和-2">例题 1264. 动态求连续区间和</h3>
<p><a href="https://www.acwing.com/problem/content/1266/">1264. 动态求连续区间和</a></p>
<figure data-type="image" tabindex="100"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203164712810.png" alt="image-20230203164712810" loading="lazy"></figure>
<figure data-type="image" tabindex="101"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203164328814.png" alt="image-20230203164328814" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;

using namespace std;

const int N = 100010;

int n, m;
int w[N];

struct Node
{
	int l, r; // 左右边界
	int sum; // 求和
} tr[4 * N];


void pushup(int u) {
	tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum;
	// 左儿子 u &lt;&lt; 1， 右儿子 u &lt;&lt; 1 | 1 之和
}

void build(int u, int l, int r) {
	if (l == r) tr[u] = {l, r, w[l]}; // 表示是叶子节点, 注意是w[l] 或w[r]， u 是线段树的下标
	else {
		tr[u] = {l, r}; // /赋左右边界的初值
		int mid = l + r &gt;&gt; 1; // 找到分界点
		build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);// 递归建立左右儿子
		pushup(u);
	}
}

int query(int u, int l, int r) {
	if (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) return tr[u].sum; // 表示已经完全包含
	// 找到分界点
	int mid = tr[u].l + tr[u].r &gt;&gt; 1;
	int sum = 0;
	if (l &lt;= mid) sum += query(u &lt;&lt; 1, l, r);
	if (r &gt;= mid + 1) sum += query(u &lt;&lt; 1 | 1, l, r);

	return sum;
}

void modify(int u, int x, int v) {
	if (tr[u].l == tr[u].r) tr[u].sum += v;
	else {
		int mid = tr[u].l + tr[u].r &gt;&gt; 1; // 分界点
		if (x &lt;= mid) modify(u &lt;&lt; 1, x, v);
		else modify(u &lt;&lt; 1 | 1, x, v);
		pushup(u); // 在父节点出更新
	}
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;w[i]);
	build(1, 1, n); // 初始化线段树

	int k, a, b;
	while (m --) {
		scanf(&quot;%d%d%d&quot;, &amp;k, &amp;a, &amp;b);
		if (k == 0) printf(&quot;%d\n&quot;, query(1, a, b)); // 查询 a, b 区间和
		else {
			modify(1, a, b); 
		}
	}

	return 0;
}
</code></pre>
<h3 id="例题-1270-数列区间最大值">例题 1270. 数列区间最大值</h3>
<p><a href="https://www.acwing.com/problem/content/1272/">1270. 数列区间最大值</a></p>
<figure data-type="image" tabindex="102"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203164122991.png" alt="image-20230203164122991" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;climits&gt;

using namespace std;

const int N = 100010;

int n, m;
int w[N];

struct Node
{
	int l, r; // 左右边界
	int maxv; // 求和
} tr[4 * N];


void pushup(int u) {
	tr[u].maxv = max(tr[u &lt;&lt; 1].maxv, tr[u &lt;&lt; 1 | 1].maxv);
	// 左儿子 u &lt;&lt; 1， 右儿子 u &lt;&lt; 1 | 1 之和
}

void build(int u, int l, int r) {
	if (l == r) tr[u] = {l, r, w[l]}; // 表示是叶子节点, 注意是w[l] 或w[r]， u 是线段树的下标
	else {
		tr[u] = {l, r}; // /赋左右边界的初值
		int mid = l + r &gt;&gt; 1; // 找到分界点
		build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);// 递归建立左右儿子
		pushup(u);
	}
}

int query(int u, int l, int r) {
	if (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) return tr[u].maxv; // 表示已经完全包含
	// 找到分界点
	int mid = tr[u].l + tr[u].r &gt;&gt; 1;
	int maxv = INT_MIN;
	if (l &lt;= mid) maxv = query(u &lt;&lt; 1, l, r);
	if (r &gt;= mid + 1) maxv = max(maxv, query(u &lt;&lt; 1 | 1, l, r));

	return maxv;
}


int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;w[i]);
	build(1, 1, n); // 初始化线段树

	int a, b;
	while (m --) {
		scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
		printf(&quot;%d\n&quot;, query(1, a, b));
	}

	return 0;
}
</code></pre>
<h3 id="习题-1228-油漆面积">习题 1228. 油漆面积</h3>
<p><a href="https://www.acwing.com/problem/content/1230/">1228. 油漆面积</a></p>
<p>X星球的一批考古机器人正在一片废墟上考古。</p>
<p>该区域的地面坚硬如石、平整如镜。</p>
<p>管理人员为方便，建立了标准的直角坐标系。</p>
<p>每个机器人都各有特长、身怀绝技。</p>
<p>它们感兴趣的内容也不相同。</p>
<p>经过各种测量，每个机器人都会报告一个或多个矩形区域，作为优先考古的区域。</p>
<p>矩形的表示格式为 (x1,y1,x2,y2)，代表矩形的两个对角点坐标。</p>
<p>为了醒目，总部要求对所有机器人选中的矩形区域涂黄色油漆。</p>
<p>小明并不需要当油漆工，只是他需要计算一下，一共要耗费多少油漆。</p>
<p>其实这也不难，只要算出所有矩形覆盖的区域一共有多大面积就可以了。</p>
<p>注意，各个矩形间可能重叠。</p>
<h4 id="输入格式-14">输入格式</h4>
<p>第一行，一个整数 n，表示有多少个矩形。</p>
<p>接下来的 n 行，每行有 4 个整数 x1,y1,x2,y2，空格分开，表示矩形的两个对角顶点坐标。</p>
<h4 id="输出格式-14">输出格式</h4>
<p>一行一个整数，表示矩形覆盖的总面积。</p>
<h4 id="数据范围-14">数据范围</h4>
<p>1≤n≤10000,<br>
0≤x1,x2,y2,y2≤10000<br>
数据保证 x1&lt;x2 且 y1&lt;y2。</p>
<h4 id="输入样例1-3">输入样例1：</h4>
<pre><code>3
1 5 10 10
3 1 20 20
2 7 15 17
</code></pre>
<h4 id="输出样例1-3">输出样例1：</h4>
<pre><code>340
</code></pre>
<h4 id="输入样例2-3">输入样例2：</h4>
<pre><code>3
5 2 10 6
2 7 12 10
8 1 15 15
</code></pre>
<h4 id="输出样例2-3">输出样例2：</h4>
<pre><code>128
</code></pre>
<figure data-type="image" tabindex="103"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203204606583.png" alt="image-20230203204606583" loading="lazy"></figure>
<figure data-type="image" tabindex="104"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203204816163.png" alt="image-20230203204816163" loading="lazy"></figure>
<figure data-type="image" tabindex="105"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203205701119.png" alt="image-20230203205701119" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 10010;

int n;

struct Segment{
	int x, y1, y2; // 定义位置信息
	int k; // k 表示是矩形的开始还是结束
	// 重载比较运算符，用来排序
	bool operator&lt; (const Segment &amp;t) {
		return x &lt; t.x; // 根据x进行排序
	}
} seg[N * 2];

struct Node{
	int l, r;
	int cnt, len; // cnt表示结点区间被覆盖次数，len表示结点区间内被覆盖的长度
} tr[N * 4];

// 线段树核心函数
void pushup(int u) {
	// 结点区间被覆盖过一次以上，那len就等于区间长度
	if (tr[u].cnt &gt; 0) tr[u].len = tr[u].r - tr[u].l + 1; 
	else if (tr[u].l == tr[u].r) tr[u].len = 0;
	else tr[u].len = tr[u &lt;&lt; 1].len + tr[u &lt;&lt; 1 | 1].len;
}


void build(int u, int l, int r) {
	tr[u] = {l, r};
	if (l == r) return ;
	// 递归完成初始化
	int mid = l + r &gt;&gt; 1;
	build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);
}

void modify(int u, int l, int r, int k) {
	// 区间完全包含结点，直接修改结点的cnt,修改完cnt会影响到当前节点区间的覆盖性
	if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) {
		tr[u].cnt += k;
		pushup(u);
	} else {
		int mid = tr[u].l + tr[u].r &gt;&gt; 1;
		if (l &lt;= mid) modify(u &lt;&lt; 1, l, r, k);
		if (r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, k);
		pushup(u);
	}
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	int m = 0; // 线段数量

	for (int i = 0; i &lt; n; i ++) {
		int x1, x2, y1, y2;
		scanf(&quot;%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);
		seg[m ++] = {x1, y1, y2, 1}; // 矩形的开始
		seg[m ++] = {x2, y1, y2, -1}; // 矩形的结束
	}
	sort(seg, seg + m);

	build(1, 0, 10000);

	int res = 0;
	for (int i = 0; i &lt; m; i ++) {
		// 开始扫描线
		if (i &gt; 0) res += tr[1].len * (seg[i].x - seg[i - 1].x); // 扫描线，计算面积
		modify(1, seg[i].y1, seg[i].y2 - 1, seg[i].k);
	}

	printf(&quot;%d\n&quot;, res);

	return 0;
}
</code></pre>
<h3 id="习题-1232-三体攻击">习题 1232. 三体攻击</h3>
<p><a href="https://www.acwing.com/problem/content/1234/">1232. 三体攻击</a></p>
<figure data-type="image" tabindex="106"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203231501573.png" alt="image-20230203231501573" loading="lazy"></figure>
<figure data-type="image" tabindex="107"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203232949019.png" alt="image-20230203232949019" loading="lazy"></figure>
<h4 id="三维前缀和">三维前缀和</h4>
<figure data-type="image" tabindex="108"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203233812519.png" alt="image-20230203233812519" loading="lazy"></figure>
<h4 id="一维差分">一维差分</h4>
<figure data-type="image" tabindex="109"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203235912203.png" alt="image-20230203235912203" loading="lazy"></figure>
<h4 id="二维差分">二维差分</h4>
<figure data-type="image" tabindex="110"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203235924900.png" alt="image-20230203235924900" loading="lazy"></figure>
<h4 id="三维差分">三维差分</h4>
<figure data-type="image" tabindex="111"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203235935896.png" alt="image-20230203235935896" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

typedef long long LL;

const int N = 2000010;

int A, B, C, m;
LL s[N];  // 原数组
LL b[N], bp[N];  // 差分数组
int d[8][4] = {  // 差分数组和原数组 相互转换 使用到的偏移量和系数
    {0, 0, 0, 1},
    {0, 0, 1, -1},
    {0, 1, 0, -1},
    {0, 1, 1, 1},
    {1, 0, 0, -1},
    {1, 0, 1, 1},
    {1, 1, 0, 1},
    {1, 1, 1, -1},
};
int op[N / 2][7];

int get(int i, int j, int k) {
	// 将三维坐标转化为一维
    return (i * B + j) * C + k;
}

bool check(int mid) {

    memcpy(b, bp, sizeof bp);
    for (int i = 1; i &lt;= mid; i++) {
        // 给(x1, y1, z1), (x2, y2, z2)之间加上c
        int x1 = op[i][0], x2 = op[i][1];
        int y1 = op[i][2], y2 = op[i][3];
        int z1 = op[i][4], z2 = op[i][5];
        int c = -op[i][6];
        b[get(x1    , y1    , z1)]      += c;
        b[get(x1    , y1    , z2 + 1)]  -= c;
        b[get(x1    , y2 + 1, z1)]      -= c;
        b[get(x1    , y2 + 1, z2 + 1)]  += c;
        b[get(x2 + 1, y1    , z1)]      -= c;
        b[get(x2 + 1, y1    , z2 + 1)]  += c;
        b[get(x2 + 1, y2 + 1, z1)]      += c;
        b[get(x2 + 1, y2 + 1, z2 + 1)]  -= c;
    }

    // 根据差分数组求解原数组
    memset(s, 0, sizeof s);
    for (int i = 1; i &lt;= A; i++)
        for (int j = 1; j &lt;= B; j++)
            for (int k = 1; k &lt;= C; k++) {
                s[get(i, j, k)] += b[get(i, j, k)];
                for (int u = 1; u &lt; 8; u++) {
                    int x = i - d[u][0], y = j - d[u][1], z = k - d[u][2], t = d[u][3];
                    s[get(i, j, k)] -= s[get(x, y, z)] * t;
                }
                if (s[get(i, j, k)] &lt; 0) return true;
            }

    return false;
}

int main() {

    // 读取原数组
    scanf(&quot;%d%d%d%d&quot;, &amp;A, &amp;B, &amp;C, &amp;m);
    for (int i = 1; i &lt;= A; i++)
        for (int j = 1; j &lt;= B; j++)
            for (int k = 1; k &lt;= C; k++)
                scanf(&quot;%lld&quot;, &amp;s[get(i, j, k)]);

    // 根据原数组s计算差分数组
    for (int i = 1; i &lt;= A; i++)
        for (int j = 1; j &lt;= B; j++)
            for (int k = 1; k &lt;= C; k++)
                for (int u = 0; u &lt; 8; u++) {
                    int x = i - d[u][0], y = j - d[u][1], z = k - d[u][2], t = d[u][3];
                    bp[get(i, j, k)] += s[get(x, y, z)] * t;
                }

    // 读取操作
    for (int i = 1; i &lt;= m; i++)
        for (int j = 0; j &lt; 7; j++)
            scanf(&quot;%d&quot;, &amp;op[i][j]);

    // 二分答案
    int l = 1, r = m;
    while (l &lt; r) {
        int mid = l + r &gt;&gt; 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }

    printf(&quot;%d\n&quot;, r);

    return 0;
}
</code></pre>
<h3 id="习题-1237-螺旋折线">习题 1237. 螺旋折线</h3>
<p><a href="https://www.acwing.com/problem/content/1239/">1237. 螺旋折线</a></p>
<figure data-type="image" tabindex="112"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/19_95e6f22816-p1.png" alt="p1.png" loading="lazy"></figure>
<p>对于整点 (X,Y)，我们定义它到原点的距离 dis(X,Y) 是从原点到 (X,Y)的螺旋折线段的长度。</p>
<p>例如 dis(0,1)=3,dis(−2,−1)=9</p>
<p>给出整点坐标 (X,Y)，你能计算出 dis(X,Y) 吗？</p>
<h4 id="输入格式-15">输入格式</h4>
<p>包含两个整数 X,Y。</p>
<h4 id="输出格式-15">输出格式</h4>
<p>输出一个整数，表示 dis(X,Y)。</p>
<h4 id="数据范围-15">数据范围</h4>
<p>−10<sup>9≤X,Y≤10</sup>9</p>
<h4 id="输入样例-12">输入样例：</h4>
<pre><code>0 1
</code></pre>
<h4 id="输出样例-12">输出样例：</h4>
<pre><code>3
</code></pre>
<h4 id="模拟1">模拟1</h4>
<figure data-type="image" tabindex="113"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230205160616558.png" alt="image-20230205160616558" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

int main()
{
    int x, y;
    cin &gt;&gt; x &gt;&gt; y;

    if (abs(x) &lt;= y)  // 在上方
    {
        int n = y;
        cout &lt;&lt; (LL)(2 * n - 1) * (2 * n) + x - (-n) &lt;&lt; endl;
    }
    else if (abs(y) &lt;= x)  // 在右方
    {
        int n = x;
        cout &lt;&lt; (LL)(2 * n) * (2 * n) + n - y &lt;&lt; endl;
    }
    else if (abs(x) &lt;= abs(y) + 1 &amp;&amp; y &lt; 0)  // 在下方
    {
        int n = abs(y);
        cout &lt;&lt; (LL)(2 * n) * (2 * n + 1) + n - x &lt;&lt; endl;
    }
    else  // 在左方
    {
        int n = abs(x);
        cout &lt;&lt; (LL)(2 * n - 1) * (2 * n - 1) + y - (-n + 1) &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
<h4 id="模拟2">模拟2</h4>
<p>找规律可以发现每层的右上角点所需步数为为4k^2，求任意一个点的dis首先找到这个点所在的层数</p>
<ul>
<li>如果在该层的左或上则减去该点到右上角曼哈顿距离，</li>
<li>如果在该层的右或下则加上该点到右上角曼哈顿距离；</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;

typedef long long LL;

int main() {
    int x, y;
    scanf(&quot;%d%d&quot;, &amp;x, &amp;y);

    LL target = max(abs(x), abs(y));
    LL res = 4 * target * target;
    if (x &lt;= y) {
        // 左层
        res -= abs(x - target) + abs(y - target);
    } else {
        // 右层
        res += abs(x - target) + abs(y - target);
    }

    printf(&quot;%lld\n&quot;, res);

    return 0;
}
</code></pre>
<h2 id="差分">差分</h2>
<figure data-type="image" tabindex="114"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230205165616636.png" alt="image-20230205165616636" loading="lazy"></figure>
<h3 id="核心操作">核心操作</h3>
<ul>
<li>将a[L ~ R] 中的全部数字加上C</li>
<li>等价于的差分数组的操作：让b[L] += C， 让b[R + 1] -= C</li>
</ul>
<h4 id="一维差分-2">一维差分</h4>
<figure data-type="image" tabindex="115"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203235912203.png" alt="image-20230203235912203" loading="lazy"></figure>
<h4 id="二维差分-2">二维差分</h4>
<figure data-type="image" tabindex="116"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203235924900.png" alt="image-20230203235924900" loading="lazy"></figure>
<h4 id="三维差分-2">三维差分</h4>
<figure data-type="image" tabindex="117"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230203235935896.png" alt="image-20230203235935896" loading="lazy"></figure>
<h3 id="例题-797-差分">例题 797. 差分</h3>
<p><a href="https://www.acwing.com/problem/content/799/">797. 差分</a></p>
<figure data-type="image" tabindex="118"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230205170136353.png" alt="image-20230205170136353" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;


const int N = 100010;

int n, m;
int a[N], b[N];

void insert(int l, int r, int c) {
    // 插入操作
    b[l] +=c, b[r + 1] -= c;
}

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);

    for (int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]);

    for (int i = 1; i &lt;= n; i ++) insert(i, i, a[i]);

    while (m --) {
        int l, r, c;
        scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;c);
        insert(l, r, c);
    }

    for (int i = 1; i &lt;= n; i ++) a[i] = a[i - 1] + b[i];

    for (int i = 1; i &lt;= n; i ++) printf(&quot;%d &quot;, a[i]);
    puts(&quot;&quot;);

    return 0;
}
</code></pre>
<h3 id="例题-798-差分矩阵">例题 798. 差分矩阵</h3>
<p><a href="https://www.acwing.com/problem/content/800/">798. 差分矩阵</a></p>
<figure data-type="image" tabindex="119"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230205170853597.png" alt="image-20230205170853597" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;


const int N = 1010;

int n, m, q;
int a[N][N], b[N][N];

void insert(int x1, int y1, int x2, int y2, int c) {
    b[x1][y1] += c;
    b[x1][y2 + 1] -= c;
    b[x2 + 1][y1] -= c;
    b[x2 + 1][y2 + 1] += c;
}

int main() {
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q);

    for (int i = 1; i &lt;= n; i ++) {
        for (int j = 1; j &lt;= m; j ++) {
            scanf(&quot;%d&quot;, &amp;a[i][j]);
        }
    }

    for (int i = 1; i &lt;= n; i ++) {
        for (int j = 1; j &lt;= m; j ++) {
            insert(i, j, i, j, a[i][j]);
        }
    }

    while (q --) {
        int x1, y1, x2, y2, c;
        scanf(&quot;%d%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;c);
        insert(x1, y1, x2, y2, c);
    }

    for (int i = 1; i &lt;= n; i ++) {
        for (int j = 1; j &lt;= m; j ++) {
            b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];
        }
    }

    for (int i = 1; i &lt;= n; i ++) {
        for (int j = 1; j &lt;= m; j ++) {
            printf(&quot;%d &quot;, b[i][j]);
        }
        printf(&quot;\n&quot;);
    }
      

    return 0;
}
</code></pre>
<h1 id="双指针-bfs与图论">双指针、BFS与图论</h1>
<h2 id="双指针">双指针</h2>
<figure data-type="image" tabindex="120"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230205190024515.png" alt="image-20230205190024515" loading="lazy"></figure>
<h3 id="例题-1238-日志统计">例题 1238. 日志统计</h3>
<p><a href="https://www.acwing.com/problem/content/1240/">1238. 日志统计</a></p>
<p>小明维护着一个程序员论坛。现在他收集了一份”点赞”日志，日志共有 N 行。</p>
<p>其中每一行的格式是：</p>
<pre><code>ts id  
</code></pre>
<p>表示在 ts时刻编号 id的帖子收到一个”赞”。</p>
<p>现在小明想统计有哪些帖子曾经是”热帖”。</p>
<p>如果一个帖子曾在任意一个长度为 D 的时间段内收到不少于 K 个赞，小明就认为这个帖子曾是”热帖”。</p>
<p>具体来说，如果存在某个时刻 T 满足该帖在 [T,T+D) 这段时间内(注意是左闭右开区间)收到不少于 K个赞，该帖就曾是”热帖”。</p>
<p>给定日志，请你帮助小明统计出所有曾是”热帖”的帖子编号。</p>
<h4 id="输入格式-16">输入格式</h4>
<p>第一行包含三个整数 N,D,K。</p>
<p>以下 N 行每行一条日志，包含两个整数 ts 和 id。</p>
<h4 id="输出格式-16">输出格式</h4>
<p>按从小到大的顺序输出热帖 id。</p>
<p>每个 id 占一行。</p>
<h4 id="数据范围-16">数据范围</h4>
<p>1≤K≤N≤105<br>
0≤ts,id≤105<br>
1≤D≤10000</p>
<h4 id="输入样例-13">输入样例：</h4>
<pre><code>7 10 2
0 1
0 10
10 10
10 1
9 1
100 3
100 3
</code></pre>
<h4 id="输出样例-13">输出样例：</h4>
<pre><code>1
3
</code></pre>
<h4 id="暴力做法">暴力做法</h4>
<figure data-type="image" tabindex="121"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230205190644292.png" alt="image-20230205190644292" loading="lazy"></figure>
<h4 id="双指针优化">双指针优化</h4>
<figure data-type="image" tabindex="122"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230205190901710.png" alt="image-20230205190901710" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#define x first
#define y second

using namespace std;

typedef pair&lt;int, int&gt; PII;

const int N = 100010;

int n, d, k;
PII logs[N];  // 存储日志条数, x 表示时间，y 表示id
int cnt[N];  // 表示id为i的文章得到的点赞
bool st[N];  // 表示id为i的文章是否曾为热帖

int main() {
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;d, &amp;k);
    // 输入
    for (int i = 0; i &lt; n; i ++) scanf(&quot;%d%d&quot;, &amp;logs[i].x, &amp;logs[i].y);

    sort(logs, logs + n); // 按照时间顺序排好序
    for (int i = 0, j = 0; i &lt; n; i ++) {
        int id = logs[i].y;
        cnt[id] ++;
        while ((logs[i].x - logs[j].x) &gt;= d) {
            cnt[logs[j].y] --; // 超过d区间，即区间滑动后，在左边的日志
            j ++;
        }
        if (cnt[logs[i].y] &gt;= k) st[id] = true; // 是热帖
    }

    for (int i = 0; i &lt;= 100000; i ++) {
        if (st[i]) printf(&quot;%d\n&quot;, i);
    }

    return 0;
}
</code></pre>
<h3 id="习题-1240-完全二叉树的权值">习题 1240. 完全二叉树的权值</h3>
<p><a href="https://www.acwing.com/problem/content/1242/">1240. 完全二叉树的权值</a></p>
<p>给定一棵包含 N 个节点的完全二叉树，树上每个节点都有一个权值，按从上到下、从左到右的顺序依次是 A1,A2,⋅⋅⋅AN，如下图所示：</p>
<figure data-type="image" tabindex="123"><img src="https://cdn.acwing.com/media/article/image/2019/12/05/19_2f0cae5817-QQ%E6%88%AA%E5%9B%BE20191205124611.png" alt="QQ截图20191205124611.png" loading="lazy"></figure>
<p>现在小明要把相同深度的节点的权值加在一起，他想知道哪个深度的节点权值之和最大？</p>
<p>如果有多个深度的权值和同为最大，请你输出其中最小的深度。</p>
<p>注：根的深度是1 。</p>
<h4 id="输入格式-17">输入格式</h4>
<p>第一行包含一个整数 N。</p>
<p>第二行包含 N个整数 A1,A2,⋅⋅⋅AN。</p>
<h4 id="输出格式-17">输出格式</h4>
<p>输出一个整数代表答案。</p>
<h4 id="数据范围-17">数据范围</h4>
<p>1≤N≤10^5<br>
−10<sup>5≤Ai≤10</sup>5</p>
<h4 id="输入样例-14">输入样例：</h4>
<pre><code>7
1 6 5 4 3 2 1
</code></pre>
<h4 id="输出样例-14">输出样例：</h4>
<pre><code>2
</code></pre>
<figure data-type="image" tabindex="124"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206001346782.png" alt="image-20230206001346782" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cmath&gt;

using namespace std;

typedef long long LL;

const int N = 100010;

int n;
int tr[N];

int main() {
    scanf(&quot;%d&quot;, &amp;n);

    for (int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;tr[i]);

    LL maxv = -1e18;
    int index = 0;
    for (int d = 1, i = 1; i &lt;= n; d ++, i *= 2) {
        // d 表示当前为二叉树的第几层，i 表示坐标
        LL cur = 0;
        for (int j = i; j &lt; i + (1 &lt;&lt; (d - 1)) &amp;&amp; j &lt;= n; j ++) {
            // 循环每层, j &lt;= n 是为了可能最后一层无法取完
            cur += tr[j];
        }
        
        if (cur &gt; maxv) {
            maxv = cur;
            index = d;
        }
    }

    printf(&quot;%d\n&quot;, index);
    return 0;
}
</code></pre>
<h2 id="bfs">BFS</h2>
<figure data-type="image" tabindex="125"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230205194904005.png" alt="image-20230205194904005" loading="lazy"></figure>
<figure data-type="image" tabindex="126"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230205195249530.png" alt="image-20230205195249530" loading="lazy"></figure>
<h3 id="bfs-一般框架">BFS 一般框架</h3>
<figure data-type="image" tabindex="127"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230205195619066.png" alt="image-20230205195619066" loading="lazy"></figure>
<pre><code class="language-c++">queue&lt;int&gt; q;
st[1] = true; // 表示1号点已经被遍历过
q.push(1);

while (q.size())
{
    int t = q.front();
    q.pop();

    for (int i = h[t]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true; // 表示点j已经被遍历过
            q.push(j);
        }
    }
}
</code></pre>
<h3 id="例题-1101-献给阿尔吉侬的花束">例题 1101. 献给阿尔吉侬的花束</h3>
<p><a href="https://www.acwing.com/problem/content/description/1103/">1101. 献给阿尔吉侬的花束</a></p>
<p>阿尔吉侬是一只聪明又慵懒的小白鼠，它最擅长的就是走各种各样的迷宫。</p>
<p>今天它要挑战一个非常大的迷宫，研究员们为了鼓励阿尔吉侬尽快到达终点，就在终点放了一块阿尔吉侬最喜欢的奶酪。</p>
<p>现在研究员们想知道，如果阿尔吉侬足够聪明，它最少需要多少时间就能吃到奶酪。</p>
<p>迷宫用一个 R×C的字符矩阵来表示。</p>
<p>字符 S 表示阿尔吉侬所在的位置，字符 E 表示奶酪所在的位置，字符 # 表示墙壁，字符 . 表示可以通行。</p>
<p>阿尔吉侬在 1 个单位时间内可以从当前的位置走到它上下左右四个方向上的任意一个位置，但不能走出地图边界。</p>
<h4 id="输入格式-18">输入格式</h4>
<p>第一行是一个正整数 T，表示一共有 T 组数据。</p>
<p>每一组数据的第一行包含了两个用空格分开的正整数 R 和 C，表示地图是一个 R×C 的矩阵。</p>
<p>接下来的 R 行描述了地图的具体内容，每一行包含了 C 个字符。字符含义如题目描述中所述。保证有且仅有一个 S 和 E。</p>
<h4 id="输出格式-18">输出格式</h4>
<p>对于每一组数据，输出阿尔吉侬吃到奶酪的最少单位时间。</p>
<p>若阿尔吉侬无法吃到奶酪，则输出“oop!”（只输出引号里面的内容，不输出引号）。</p>
<p>每组数据的输出结果占一行。</p>
<h4 id="数据范围-18">数据范围</h4>
<p>1&lt;T≤10<br>
2≤R,C≤200</p>
<h4 id="输入样例-15">输入样例：</h4>
<pre><code>3
3 4
.S..
###.
..E.
3 4
.S..
.E..
....
3 4
.S..
####
..E.
</code></pre>
<h4 id="输出样例-15">输出样例：</h4>
<pre><code>5
1
oop!
</code></pre>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;
#define x first
#define y second

using namespace std;

typedef pair&lt;int, int&gt; PII;

const int N = 210;

int n, m;
char g[N][N];  // 用来存储迷宫
int dist[N][N];  // 用来存储步数
int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};

int bfs(PII start, PII finish) {
    queue&lt;PII&gt; q;
    memset(dist, -1, sizeof dist);
    dist[start.x][start.y] = 0;
    q.push(start);

    // bfs 
    while (q.size()) {
        PII t = q.front();
        q.pop();  // 弹出
        for (int i = 0; i &lt; 4; i ++) {
            // 4个方向遍历
            int x = dx[i] + t.x, y = dy[i] + t.y;
            if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m) continue;  // 出界
            if (g[x][y] == '#') continue;  // 遇到障碍物
            if (dist[x][y] != -1) continue;  // 由于遍历到的为距离，故若不等于-1， 则表示已经遍历过了
            
            dist[x][y] = dist[t.x][t.y] + 1;  // 当前的距离 + 1
            if (finish == make_pair(x, y)) return dist[x][y];
            q.push({x, y});
        }
    }

    return -1;
}

int main() {
    int T;
    scanf(&quot;%d&quot;, &amp;T);
    while (T --) {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        for (int i = 0; i &lt; n; i ++) scanf(&quot;%s&quot;, &amp;g[i]);  // 读入迷宫

        PII start, finish;
        for (int i = 0;i &lt; n; i ++) {
            for (int j = 0; j &lt; m; j ++) {
                if (g[i][j] == 'S') start = {i, j};
                else if (g[i][j] == 'E') finish = {i, j}; // 找到开始结束位置
            }
        }

        int distance = bfs(start, finish);
        if (distance == -1) printf(&quot;oop!\n&quot;);
        else printf(&quot;%d\n&quot;, distance);
    }
    
    return 0;
}
</code></pre>
<h3 id="习题-1096-地牢大师">习题 1096. 地牢大师</h3>
<p><a href="https://www.acwing.com/problem/content/1098/">1096. 地牢大师</a></p>
<p>你现在被困在一个三维地牢中，需要找到最快脱离的出路！</p>
<p>地牢由若干个单位立方体组成，其中部分不含岩石障碍可以直接通过，部分包含岩石障碍无法通过。</p>
<p>向北，向南，向东，向西，向上或向下移动一个单元距离均需要一分钟。</p>
<p>你不能沿对角线移动，迷宫边界都是坚硬的岩石，你不能走出边界范围。</p>
<p>请问，你有可能逃脱吗？</p>
<p>如果可以，需要多长时间？</p>
<h4 id="输入格式-19">输入格式</h4>
<p>输入包含多组测试数据。</p>
<p>每组数据第一行包含三个整数 L,R,C分别表示地牢层数，以及每一层地牢的行数和列数。</p>
<p>接下来是 L 个 R 行 C 列的字符矩阵，用来表示每一层地牢的具体状况。</p>
<p>每个字符用来描述一个地牢单元的具体状况。</p>
<p>其中, 充满岩石障碍的单元格用”#”表示，不含障碍的空单元格用”.”表示，你的起始位置用”S”表示，终点用”E”表示。</p>
<p>每一个字符矩阵后面都会包含一个空行。</p>
<p>当输入一行为”0 0 0”时，表示输入终止。</p>
<h4 id="输出格式-19">输出格式</h4>
<p>每组数据输出一个结果，每个结果占一行。</p>
<p>如果能够逃脱地牢，则输出”Escaped in x minute(s).”，其中X为逃脱所需最短时间。</p>
<p>如果不能逃脱地牢，则输出”Trapped!”。</p>
<h4 id="数据范围-19">数据范围</h4>
<p>1≤L,R,C≤100</p>
<h4 id="输入样例-16">输入样例：</h4>
<pre><code>3 4 5
S....
.###.
.##..
###.#

#####
#####
##.##
##...

#####
#####
#.###
####E

1 3 3
S##
#E#
###

0 0 0
</code></pre>
<h4 id="输出样例-16">输出样例：</h4>
<pre><code>Escaped in 11 minute(s).
Trapped!
</code></pre>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 110;

struct Point
{
    int x, y, z;  // 表示坐标
};

int L, R, C;
char g[N][N][N];  // 表示地牢
int dist[N][N][N];  // 表示距离
Point q[N * N * N];  // 数组模拟队列, 注意要N * N * N
int dx[6] = {-1, 1, 0, 0, 0, 0};
int dy[6] = {0, 0, -1, 1, 0, 0};
int dz[6] = {0, 0, 0, 0, -1, 1};

int bfs(Point start, Point end) {
    int hh = 0, tt = 0;
    q[0] = start;
    memset(dist, -1, sizeof dist);
    dist[start.x][start.y][start.z] = 0;

    while (hh &lt;= tt) {
        // 取出对头元素
        Point t = q[hh ++];
        for (int i = 0; i &lt; 6; i ++) {
            int a = t.x + dx[i], b = t.y + dy[i], c = t.z + dz[i];
            if (a &lt; 0 || a &gt;= L || b &lt; 0 || b &gt;= R || c &lt; 0 || c &gt;= C) continue;  // 出界
            if (dist[a][b][c] != -1) continue;  // 已经到达
            if (g[a][b][c] == '#') continue;  // 障碍物
            dist[a][b][c] = dist[t.x][t.y][t.z] + 1;

            if (a == end.x &amp;&amp; b == end.y &amp;&amp; c == end.z) return dist[a][b][c];
            q[++ tt] = {a, b, c};
        }
    }

    return -1;
}

int main() {
    while (scanf(&quot;%d%d%d&quot;, &amp;L, &amp;R, &amp;C), L || R || C) {
        Point start, end;

        for (int i = 0; i &lt; L; i ++) {
            for (int j = 0; j &lt; R; j ++) {
                scanf(&quot;%s&quot;, g[i][j]);  // 读入面
                for (int k = 0; k &lt; C; k ++) {
                    // 找到起点和终点
                    if (g[i][j][k] == 'S') start = {i, j, k};
                    else if (g[i][j][k] == 'E') end = {i, j, k};
                }
            }
        }

        // 开始bfs 寻找答案
        int distance = bfs(start, end);
        if (distance == -1) printf(&quot;Trapped!\n&quot;);
        else printf(&quot;Escaped in %d minute(s).\n&quot;, distance);
    }

    return 0;
}
</code></pre>
<h2 id="flood-fill">Flood Fill</h2>
<h3 id="例题-1113-红与黑">例题 1113. 红与黑</h3>
<p><a href="https://www.acwing.com/problem/content/description/1115/">1113. 红与黑</a></p>
<p>有一间长方形的房子，地上铺了红色、黑色两种颜色的正方形瓷砖。</p>
<p>你站在其中一块黑色的瓷砖上，只能向相邻（上下左右四个方向）的黑色瓷砖移动。</p>
<p>请写一个程序，计算你总共能够到达多少块黑色的瓷砖。</p>
<h4 id="输入格式-20">输入格式</h4>
<p>输入包括多个数据集合。</p>
<p>每个数据集合的第一行是两个整数 W 和 H，分别表示 x 方向和 y 方向瓷砖的数量。</p>
<p>在接下来的 H 行中，每行包括 W 个字符。每个字符表示一块瓷砖的颜色，规则如下</p>
<p>1）‘.’：黑色的瓷砖；<br>
2）‘#’：红色的瓷砖；<br>
3）‘@’：黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中唯一出现一次。</p>
<p>当在一行中读入的是两个零时，表示输入结束。</p>
<h4 id="输出格式-20">输出格式</h4>
<p>对每个数据集合，分别输出一行，显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)。</p>
<h4 id="数据范围-20">数据范围</h4>
<p>1≤W,H≤20</p>
<h4 id="输入样例-17">输入样例：</h4>
<pre><code>6 9 
....#. 
.....# 
...... 
...... 
...... 
...... 
...... 
#@...# 
.#..#. 
0 0
</code></pre>
<h4 id="输出样例-17">输出样例：</h4>
<pre><code>45
</code></pre>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 25;

int n, m;
char g[N][N];
bool st[N][N];
int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};

int dfs(int x, int y) {
    int cnt = 1;
    st[x][y] = true;

    for (int i = 0; i &lt; 4; i ++) {
        int a = x + dx[i], b = y + dy[i];
        if (a &lt; 0 || a &gt;= m || b &lt; 0 || b &gt;= n) continue;  // 边界问题
        if (st[a][b]) continue;  // 已经遍历
        if (g[a][b] != '.') continue;  // 只走黑色

        cnt += dfs(a, b);
    }

    return cnt;
}

int main() {
    while (true) {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        if (n == 0 &amp;&amp; m == 0) break;
        for (int i = 0; i &lt; m; i ++) scanf(&quot;%s&quot;, &amp;g[i]);  // 读入迷宫

        // for (int i = 0; i &lt; m; i ++) cout &lt;&lt; g[i] &lt;&lt; endl;

        int x, y;
        for (int i = 0; i &lt; m; i ++) {
            for (int j = 0; j &lt; n; j ++) {
                if (g[i][j] == '@') {
                    x = i, y = j;
                }
            }
        }
        // cout &lt;&lt; x &lt;&lt; y &lt;&lt; endl;

        memset(st, 0, sizeof st);

        int res = dfs(x, y);

        printf(&quot;%d\n&quot;, res);
    }

    return 0;
}
</code></pre>
<h3 id="习题-1233-全球变暖">习题 1233. 全球变暖</h3>
<p><a href="https://www.acwing.com/problem/content/1235/">1233. 全球变暖</a></p>
<p>你有一张某海域 N×N像素的照片，”.”表示海洋、”#”表示陆地，如下所示：</p>
<pre><code>.......
.##....
.##....
....##.
..####.
...###.
.......
</code></pre>
<p>其中”上下左右”四个方向上连在一起的一片陆地组成一座岛屿，例如上图就有 2座岛屿。</p>
<p>由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。</p>
<p>具体来说如果一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋)，它就会被淹没。</p>
<p>例如上图中的海域未来会变成如下样子：</p>
<pre><code>.......
.......
.......
.......
....#..
.......
.......
</code></pre>
<p>请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。</p>
<h4 id="输入格式-21">输入格式</h4>
<p>第一行包含一个整数N。</p>
<p>以下 N 行 N列，包含一个由字符”#”和”.”构成的 N×N字符矩阵，代表一张海域照片，”#”表示陆地，”.”表示海洋。</p>
<p>照片保证第 11 行、第 11 列、第 N行、第 N列的像素都是海洋。</p>
<h4 id="输出格式-21">输出格式</h4>
<p>一个整数表示答案。</p>
<h4 id="数据范围-21">数据范围</h4>
<p>1≤N≤1000</p>
<h4 id="输入样例1-4">输入样例1：</h4>
<pre><code>7
.......
.##....
.##....
....##.
..####.
...###.
.......
</code></pre>
<h4 id="输出样例1-4">输出样例1：</h4>
<pre><code>1
</code></pre>
<h4 id="输入样例2-4">输入样例2：</h4>
<pre><code>9
.........
.##.##...
.#####...
.##.##...
.........
.##.#....
.#.###...
.#..#....
.........
</code></pre>
<h4 id="输出样例2-4">输出样例2：</h4>
<pre><code>1
</code></pre>
<h4 id="找到有多少连通块">找到有多少连通块</h4>
<figure data-type="image" tabindex="128"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206135838113.png" alt="image-20230206135838113" loading="lazy"></figure>
<h4 id="统计多少个会被淹没">统计多少个会被淹没</h4>
<figure data-type="image" tabindex="129"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206140105978.png" alt="image-20230206140105978" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#define x first
#define y second

using namespace std;

typedef pair&lt;int, int&gt; PII;

const int N = 1010;

int n;
int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};
char g[N][N];
bool st[N][N];
PII q[N * N];

void bfs(int x, int y, int &amp;total, int &amp;bound) {
    int hh = 0, tt = 0;
    q[0] = {x, y};
    st[x][y] = true;

    while (hh &lt;= tt) {
        auto t = q[hh ++];
        total ++;  // 总数 ++
        bool is_bound = false;   // 从陆地开始，所以is_bound 为 false
        for (int i = 0; i &lt; 4; i ++) {
            int a = t.x + dx[i], b = t.y + dy[i];
            if (a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= n) continue;  // 出界
            if (st[a][b]) continue;  // 已经遍历过
            if (g[a][b] == '.') {
                is_bound = true;
                continue;  
            }
            q[++ tt] = {a, b};
            st[a][b] = true;
        }
        if (is_bound) bound ++;
    }
}

int main() {
    scanf(&quot;%d&quot;, &amp;n);

    for (int i = 0; i &lt; n; i ++) scanf(&quot;%s&quot;, &amp;g[i]);

    int cnt = 0;  // 表示最终被淹没的岛屿的数量
    for (int i = 0; i &lt; n; i ++) {
        for (int j = 0; j &lt; n; j ++) {
            if (g[i][j] == '#' &amp;&amp; !st[i][j]) {
                int total = 0, bound = 0;
                bfs(i, j, total, bound);

                if (total == bound) cnt ++;
            }
        }
    }
    printf(&quot;%d\n&quot;, cnt);

    return 0;
}
</code></pre>
<h2 id="图论">图论</h2>
<h3 id="例题-1224-交换瓶子">例题 1224. 交换瓶子</h3>
<p><a href="https://www.acwing.com/problem/content/1226/">1224. 交换瓶子</a></p>
<p>有 N个瓶子，编号 1∼N，放在架子上。</p>
<p>比如有 5 个瓶子：</p>
<pre><code>2 1 3 5 4
</code></pre>
<p>要求每次拿起 2个瓶子，交换它们的位置。</p>
<p>经过若干次后，使得瓶子的序号为：</p>
<pre><code>1 2 3 4 5
</code></pre>
<p>对于这么简单的情况，显然，至少需要交换 2 次就可以复位。</p>
<p>如果瓶子更多呢？你可以通过编程来解决。</p>
<h4 id="输入格式-22">输入格式</h4>
<p>第一行包含一个整数 N，表示瓶子数量。</p>
<p>第二行包含 N 个整数，表示瓶子目前的排列状况。</p>
<h4 id="输出格式-22">输出格式</h4>
<p>输出一个正整数，表示至少交换多少次，才能完成排序。</p>
<h4 id="数据范围-22">数据范围</h4>
<p>1≤N≤10000</p>
<h4 id="输入样例1-5">输入样例1：</h4>
<pre><code>5
3 1 2 5 4
</code></pre>
<h4 id="输出样例1-5">输出样例1：</h4>
<pre><code>3
</code></pre>
<h4 id="输入样例2-5">输入样例2：</h4>
<pre><code>5
5 4 3 2 1
</code></pre>
<h4 id="输出样例2-5">输出样例2：</h4>
<pre><code>2
</code></pre>
<figure data-type="image" tabindex="130"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230205223305428.png" alt="image-20230205223305428" loading="lazy"></figure>
<figure data-type="image" tabindex="131"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230205223516132.png" alt="image-20230205223516132" loading="lazy"></figure>
<figure data-type="image" tabindex="132"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230205223947914.png" alt="image-20230205223947914" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 10010;

int n;
bool st[N];  // 用来记录每个瓶子是否被用过
int b[N];  // 用来记录瓶子序列

int main() {
    scanf(&quot;%d&quot;, &amp;n);

    for (int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;b[i]);

    int cnt = 0;  // 环的数量
    for (int i = 1; i &lt;= n; i ++) {
        if (!st[i]) {
            // 没有遍历过
            cnt ++;
            for (int j = i; !st[j]; j = b[j]) {  // j = b[j] 表示 第j位的数字是几
                st[j] = true;  // 将这个环上的数全部设置为true
            }
        }
    }
    printf(&quot;%d\n&quot;, n - cnt);

    return 0;
}

</code></pre>
<h3 id="习题-1207-大臣的旅费">习题 1207. 大臣的旅费</h3>
<p><a href="https://www.acwing.com/problem/content/1209/">1207. 大臣的旅费</a></p>
<p>很久以前，T王国空前繁荣。</p>
<p>为了更好地管理国家，王国修建了大量的快速路，用于连接首都和王国内的各大城市。</p>
<p>为节省经费，T国的大臣们经过思考，制定了一套优秀的修建方案，使得任何一个大城市都能从首都直接或者通过其他大城市间接到达。</p>
<p>同时，如果不重复经过大城市，从首都到达每个大城市的方案都是唯一的。</p>
<p>J是T国重要大臣，他巡查于各大城市之间，体察民情。</p>
<p>所以，从一个城市马不停蹄地到另一个城市成了J最常做的事情。</p>
<p>他有一个钱袋，用于存放往来城市间的路费。</p>
<p>聪明的J发现，如果不在某个城市停下来修整，在连续行进过程中，他所花的路费与他已走过的距离有关，在走第x千米到第x+1千米这一千米中（x是整数），他花费的路费是x+10这么多。也就是说走1千米花费11，走2千米要花费23。</p>
<p>J大臣想知道：他从某一个城市出发，中间不休息，到达另一个城市，所有可能花费的路费中最多是多少呢？</p>
<h4 id="输入格式-23">输入格式</h4>
<p>输入的第一行包含一个整数 n，表示包括首都在内的T王国的城市数。</p>
<p>城市从 1开始依次编号，1 号城市为首都。</p>
<p>接下来 n−1行，描述T国的高速路（T国的高速路一定是 n−1条）。</p>
<p>每行三个整数 Pi,Qi,Di，表示城市 Pi 和城市 Qi 之间有一条<strong>双向</strong>高速路，长度为 Di千米。</p>
<h4 id="输出格式-23">输出格式</h4>
<p>输出一个整数，表示大臣J最多花费的路费是多少。</p>
<h4 id="数据范围-23">数据范围</h4>
<p>1≤n≤105,<br>
1≤Pi,Qi≤n<br>
1≤Di≤1000</p>
<h4 id="输入样例-18">输入样例：</h4>
<pre><code>5 
1  2  2 
1  3  1 
2  4  5 
2  5  4 
</code></pre>
<h4 id="输出样例-18">输出样例：</h4>
<pre><code>135
</code></pre>
<figure data-type="image" tabindex="133"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206143656312.png" alt="image-20230206143656312" loading="lazy"></figure>
<figure data-type="image" tabindex="134"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206143912315.png" alt="image-20230206143912315" loading="lazy"></figure>
<figure data-type="image" tabindex="135"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206145135638.png" alt="image-20230206145135638" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

const int N = 1e5 + 10;

struct Edge{
    int id, w;  // 用来记录每条边的结构体
};


int n;
int dist[N];
vector&lt;Edge&gt; h[N];

void dfs(int u, int father, int distance) {
    dist[u] = distance;

    for (auto node : h[u]) {
        // 遍历 与 当前u 连通的节点
        if (node.id != father) {
            dfs(node.id, u, distance + node.w);
        }
    }
}

int main() {
    scanf(&quot;%d&quot;, &amp;n);

    for (int i = 0; i &lt; n; i ++) {
        int a, b, c;
        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
        h[a].push_back({b, c});
        h[b].push_back({a, c});
    }

    dfs(1, -1, 0);  // 任意从一个点开始dfs

    int u = 1;
    for (int i = 1; i &lt;= n; i ++) {
        if (dist[i] &gt; dist[u]) u = i;
    }

    dfs(u, -1, 0);  // 从距离之前选中点最远的点开始遍历

    for (int i = 1; i &lt;= n; i ++) {
        if (dist[i] &gt; dist[u]) u = i;
    }

    int s = dist[u];

    printf(&quot;%lld\n&quot;, s * 10 + (s + 1ll) * s / 2);   // 防止爆int

    return 0;
}
</code></pre>
<h2 id="数组模拟链表">数组模拟链表</h2>
<figure data-type="image" tabindex="136"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206153654109.png" alt="image-20230206153654109" loading="lazy"></figure>
<h3 id="初始化">初始化</h3>
<pre><code class="language-c++">void init() {
    // 初始化，head 指向空集，idx 为0
    head = -1;
    idx = 0;
}
</code></pre>
<h3 id="将x插到头节点">将x插到头节点</h3>
<figure data-type="image" tabindex="137"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206155146082.png" alt="image-20230206155146082" loading="lazy"></figure>
<pre><code class="language-c++">void add_to_head(int x) {
    // 将要插入的点指向head节点的next节点
    // 将head节点指向要插入的节点
    e[idx] = x, ne[idx] = head, head = idx, idx ++;
    // 分步写法
    // e[idx] = x;
    // ne[idx] = head;
    // head = idx;
    // idx ++;  // 当前idx 已经被使用过，故++
}
</code></pre>
<h3 id="将x插到下标为k的节点后">将x插到下标为k的节点后</h3>
<figure data-type="image" tabindex="138"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206155310128.png" alt="image-20230206155310128" loading="lazy"></figure>
<pre><code class="language-c++">void add(int k, int x) {
    // 将x 插入到下标为k的节点后面
    e[idx] = x, ne[idx] = ne[k], ne[k] = idx, idx ++;
}
</code></pre>
<h3 id="将下标是k的后面的节点删掉">将下标是k的后面的节点删掉</h3>
<figure data-type="image" tabindex="139"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206155551910.png" alt="image-20230206155551910" loading="lazy"></figure>
<pre><code class="language-c++">void remove(int k) {
    // 删除下标为k 的节点后的节点
    ne[k] = ne[ne[k]];
}
</code></pre>
<h3 id="例题-826-单链表">例题 826. 单链表</h3>
<p><a href="https://www.acwing.com/problem/content/description/828/">826. 单链表</a></p>
<p>实现一个单链表，链表初始为空，支持三种操作：</p>
<ol>
<li>向链表头插入一个数；</li>
<li>删除第 k 个插入的数后面的数；</li>
<li>在第 k个插入的数后插入一个数。</li>
</ol>
<p>现在要对该链表进行 M 次操作，进行完所有操作后，从头到尾输出整个链表。</p>
<p><strong>注意</strong>:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1个插入的数，第 2 个插入的数，…第 n 个插入的数。</p>
<h4 id="输入格式-24">输入格式</h4>
<p>第一行包含整数 M，表示操作次数。</p>
<p>接下来 M行，每行包含一个操作命令，操作命令可能为以下几种：</p>
<ol>
<li><code>H x</code>，表示向链表头插入一个数 x。</li>
<li><code>D k</code>，表示删除第 k 个插入的数后面的数（当 k 为 0 时，表示删除头结点）。</li>
<li><code>I k x</code>，表示在第 k 个插入的数后面插入一个数 x（此操作中 k 均大于 0）。</li>
</ol>
<h4 id="输出格式-24">输出格式</h4>
<p>共一行，将整个链表从头到尾输出。</p>
<h4 id="数据范围-24">数据范围</h4>
<p>1≤M≤100000<br>
所有操作保证合法。</p>
<h4 id="输入样例-19">输入样例：</h4>
<pre><code>10
H 9
I 1 1
D 1
D 0
H 6
I 3 6
I 4 5
I 4 5
I 3 4
D 6
</code></pre>
<h4 id="输出样例-19">输出样例：</h4>
<pre><code>6 4 6 5
</code></pre>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 100010;

int n;
// head 表示头节点
// e[i] 表示节点i对应的值
// ne[i] 表示节点i对应的next节点
// idx 表示当前用到了多少个指针
int head, e[N], ne[N], idx;

void init() {
    // 初始化，head 指向空集，idx 为0
    head = -1;
    idx = 0;
}

void add_to_head(int x) {
    // 将要插入的点指向head节点的next节点
    // 将head节点指向要插入的节点
    e[idx] = x, ne[idx] = head, head = idx, idx ++;
    // 分步写法
    // e[idx] = x;
    // ne[idx] = head;
    // head = idx;
    // idx ++;  // 当前idx 已经被使用过，故++
}

void insert(int k, int x) {
    // 将x 插入到下标为k的节点后面
    e[idx] = x, ne[idx] = ne[k], ne[k] = idx, idx ++;
}

void remove(int k) {
    // 删除下标为k 的节点后的节点
    ne[k] = ne[ne[k]];
}

int main() {
    scanf(&quot;%d\n&quot;, &amp;n);

    init();
    while (n --) {
        char op;
        int k, x;
        scanf(&quot;%c&quot;, &amp;op);
        if (op == 'H') {
            scanf(&quot;%d\n&quot;, &amp;x);
            add_to_head(x);
        } else if (op == 'I') {
            scanf(&quot;%d%d\n&quot;, &amp;k, &amp;x);
            insert(k - 1, x);
        } else if (op == 'D') {
            scanf(&quot;%d\n&quot;, &amp;k);
            if (!k) head = ne[head];
            else remove(k - 1);
        }
    }

    // 遍历整个链表输出
    for (int i = head; i != -1; i = ne[i]) printf(&quot;%d &quot;, e[i]);
    printf(&quot;\n&quot;);

    return 0;
}
</code></pre>
<h3 id="习题-1243-糖果">习题 1243. 糖果</h3>
<p><a href="https://www.acwing.com/problem/content/1245/">1243. 糖果</a></p>
<p>糖果店的老板一共有 M 种口味的糖果出售。</p>
<p>为了方便描述，我们将 M 种口味编号 1∼M。</p>
<p>小明希望能品尝到所有口味的糖果。</p>
<p>遗憾的是老板并不单独出售糖果，而是 K 颗一包整包出售。</p>
<p>幸好糖果包装上注明了其中 K 颗糖果的口味，所以小明可以在买之前就知道每包内的糖果口味。</p>
<p>给定 N 包糖果，请你计算小明最少买几包，就可以品尝到所有口味的糖果。</p>
<h4 id="输入格式-25">输入格式</h4>
<p>第一行包含三个整数 N,M,K。</p>
<p>接下来 N 行每行 K 个整数 T1,T2,⋅⋅⋅,TK，代表一包糖果的口味。</p>
<h4 id="输出格式-25">输出格式</h4>
<p>一个整数表示答案。</p>
<p>如果小明无法品尝所有口味，输出 −1。</p>
<h4 id="数据范围-25">数据范围</h4>
<p>1≤N≤100,<br>
1≤M,K≤20,<br>
1≤Ti≤M</p>
<h4 id="输入样例-20">输入样例：</h4>
<pre><code>6 5 3
1 1 2
1 2 3
1 1 3
2 3 5
5 4 2
5 1 2
</code></pre>
<h4 id="输出样例-20">输出样例：</h4>
<pre><code>2
</code></pre>
<figure data-type="image" tabindex="140"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230208163636558.png" alt="image-20230208163636558" loading="lazy"></figure>
<figure data-type="image" tabindex="141"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230208164317619.png" alt="image-20230208164317619" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

const int N = 110, M = 1 &lt;&lt; 20;

vector&lt;int&gt; col[N];  // 用来记录col中每一列可选择的行数有哪些
int n, m, k;
int log2[M];  // 预处理，方便计算log2(2的n次方)

int lowbit(int x) {
    return x &amp; -x;
}

int h(int state) {
    // 估价函数，计算此时state最少需要用几行来完成
    int res = 0;
    for (int i = (1 &lt;&lt; m) - 1 - state; i; i -=lowbit(i)) {
        // 选择了某一列， 则表示选择了这一列的所有的方案数
        int c = log2[lowbit(i)];
        res ++;
        for (auto row: col[c]) {
            i &amp;= ~row;  //row表示哪一列有1，每次选择一种方案，等价于将这种方案对应的位变为0
        }
    }

    return res;
}

bool dfs(int depth, int state) {  // depth 表示层数， state 用来表示当前选了哪些糖果
    if (!depth || h(state) &gt; depth) {
        // 若可选择的方案为0或者最小需要选择的方案数都小于当前可选的方案数的话，则判断是否合法
        //判断方法：看state是否全为1
        return state == (1 &lt;&lt; m) - 1;  // (1&lt;&lt;m)-1表示m位全是一， 即2^m-1
    }
    int t = -1;  // 找选择数最少的一列
    for (int i = (1 &lt;&lt; m) - 1 - state; i; i -=lowbit(i)) {
        int c = log2[lowbit(i)];  
        if (t == -1 || col[t].size() &gt; col[c].size()) {
            t = c;
        }
    }
    // 枚举接下来选哪一行
    for (auto row : col[t]) {
        if (dfs(depth - 1, state | row)) return true;
    }

    return false;
}


int main() {
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);

    // 预处理log2数组
    for (int i = 0; i &lt; m; i ++) log2[1 &lt;&lt; i] = i;

    for (int i = 0; i &lt; n; i ++) {
        int state = 0;
        
        for (int j = 0; j &lt; k; j ++) {
            // 将这一包所包含的糖果的位置变成1
            int c;
            scanf(&quot;%d&quot;, &amp;c);
            state |= 1 &lt;&lt; c - 1;  // 位运算
        }

        for (int j = 0; j &lt; m; j ++) {
            // 找出这一包中哪些位置 还可以 填1
            if (state &gt;&gt; j &amp; 1) {
                //  第 j 位有1
                col[j].push_back(state);
            }
        }
    }

    for (int i = 0; i &lt; m; i ++ ) {
        sort(col[i].begin(), col[i].end());
        col[i].erase(unique(col[i].begin(), col[i].end()), col[i].end());
    }

    int depth = 0;
    while (depth &lt;= m &amp;&amp; !dfs(depth, 0)) depth ++;

    if (depth &gt; m) depth = -1;   // 无解
    printf(&quot;%d\n&quot;, depth);

    return 0;
}
</code></pre>
<h1 id="贪心">贪心</h1>
<h3 id="例题-1055-股票买卖-ii">例题 1055. 股票买卖 II</h3>
<p><a href="https://www.acwing.com/problem/content/1057/">1055. 股票买卖 II</a></p>
<p>给定一个长度为 N 的数组，数组中的第 i 个数字表示一个给定股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<h4 id="输入格式-26">输入格式</h4>
<p>第一行包含整数 N，表示数组长度。</p>
<p>第二行包含 N 个不大于 10000的正整数，表示完整的数组。</p>
<h4 id="输出格式-26">输出格式</h4>
<p>输出一个整数，表示最大利润。</p>
<h4 id="数据范围-26">数据范围</h4>
<p>1≤N≤10^5</p>
<h4 id="输入样例1-6">输入样例1：</h4>
<pre><code>6
7 1 5 3 6 4
</code></pre>
<h4 id="输出样例1-6">输出样例1：</h4>
<pre><code>7
</code></pre>
<h4 id="输入样例2-6">输入样例2：</h4>
<pre><code>5
1 2 3 4 5
</code></pre>
<h4 id="输出样例2-6">输出样例2：</h4>
<pre><code>4
</code></pre>
<h4 id="输入样例3">输入样例3：</h4>
<pre><code>5
7 6 4 3 1
</code></pre>
<h4 id="输出样例3">输出样例3：</h4>
<pre><code>0
</code></pre>
<h4 id="样例解释-5">样例解释</h4>
<p>样例1：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。共得利润 4+3 = 7。</p>
<p>样例2：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p>
<p>样例3：在这种情况下, 不进行任何交易, 所以最大利润为 0。</p>
<figure data-type="image" tabindex="142"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206163716435.png" alt="image-20230206163716435" loading="lazy"></figure>
<figure data-type="image" tabindex="143"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206163944673.png" alt="image-20230206163944673" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 1e5 + 10;

int n;
int price[N];

int main() {
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;price[i]);

    int res = 0;
    for (int i = 0; i + 1 &lt; n; i ++) {
        int dt = price[i + 1] - price[i];
        if (dt &gt; 0) res += dt;
    }

    printf(&quot;%d\n&quot;, res);

    return 0;
}
</code></pre>
<h3 id="例题-104-货仓选址">例题 104. 货仓选址</h3>
<p><a href="https://www.acwing.com/problem/content/106/">104. 货仓选址</a></p>
<figure data-type="image" tabindex="144"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206184220685.png" alt="image-20230206184220685" loading="lazy"></figure>
<figure data-type="image" tabindex="145"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206184140873.png" alt="image-20230206184140873" loading="lazy"></figure>
<figure data-type="image" tabindex="146"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206185146859.png" alt="image-20230206185146859" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

const int N = 100010;

int n;
int x[N];

int main() {
    scanf(&quot;%d&quot;, &amp;n);

    for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;x[i]);
    sort(x, x + n);

    int c = x[n &gt;&gt; 1];  // n/2 下取整可同时满足n为奇数与偶数的情况
    LL res = 0;
    for (int i = 0; i &lt; n; i++) res += abs(x[i] - c);

    printf(&quot;%lld\n&quot;, res);

    return 0;
}
</code></pre>
<h3 id="例题-122-糖果传递">例题 122. 糖果传递</h3>
<p><a href="https://www.acwing.com/problem/content/124/">122. 糖果传递</a></p>
<figure data-type="image" tabindex="147"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206190110987.png" alt="image-20230206190110987" loading="lazy"></figure>
<figure data-type="image" tabindex="148"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206192331156.png" alt="image-20230206192331156" loading="lazy"></figure>
<figure data-type="image" tabindex="149"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206192305305.png" alt="image-20230206192305305" loading="lazy"></figure>
<figure data-type="image" tabindex="150"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206191857702.png" alt="image-20230206191857702" loading="lazy"></figure>
<figure data-type="image" tabindex="151"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206192526594.png" alt="image-20230206192526594" loading="lazy"></figure>
<figure data-type="image" tabindex="152"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206193426328.png" alt="image-20230206193426328" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

const int N = 1000010;

int n;
int a[N];
int c[N];

int main() {
    scanf(&quot;%d&quot;, &amp;n);

    LL s = 0;
    for (int i = 1; i &lt;= n; i ++) {
        scanf(&quot;%d&quot;, &amp;a[i]);
        s += a[i];
    }
    LL avg = s / n;

    for (int i = n; i &gt;= 1; i --) {
        c[i] = c[i + 1] + avg - a[i];
    }
    c[1] = 0;
    sort(c + 1, c + n + 1);
    LL cen = c[(n + 1) / 2];
    LL res = 0;
    for (int i = 1; i &lt;= n; i ++) res += abs(c[i] - cen);

    printf(&quot;%lld\n&quot;, res);

    return 0;
}
</code></pre>
<h3 id="例题-112-雷达设备">例题 112. 雷达设备</h3>
<p><a href="https://www.acwing.com/problem/content/114/">112. 雷达设备</a></p>
<p>假设海岸是一条无限长的直线，陆地位于海岸的一侧，海洋位于另外一侧。</p>
<p>每个小岛都位于海洋一侧的某个点上。</p>
<p>雷达装置均位于海岸线上，且雷达的监测范围为 d，当小岛与某雷达的距离不超过 d 时，该小岛可以被雷达覆盖。</p>
<p>我们使用笛卡尔坐标系，定义海岸线为 x 轴，海的一侧在 x 轴上方，陆地一侧在 x 轴下方。</p>
<p>现在给出每个小岛的具体坐标以及雷达的检测范围，请你求出能够使所有小岛都被雷达覆盖所需的最小雷达数目。</p>
<h4 id="输入格式-27">输入格式</h4>
<p>第一行输入两个整数 n 和 d，分别代表小岛数目和雷达检测范围。</p>
<p>接下来 n 行，每行输入两个整数，分别代表小岛的 x，y 轴坐标。</p>
<p>同一行数据之间用空格隔开。</p>
<h4 id="输出格式-27">输出格式</h4>
<p>输出一个整数，代表所需的最小雷达数目，若没有解决方案则所需数目输出 −1−1。</p>
<h4 id="数据范围-27">数据范围</h4>
<p>1≤n≤1000,<br>
−1000≤x,y≤1000</p>
<h4 id="输入样例-21">输入样例：</h4>
<pre><code>3 2
1 2
-3 1
2 1
</code></pre>
<h4 id="输出样例-21">输出样例：</h4>
<pre><code>2
</code></pre>
<figure data-type="image" tabindex="153"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206195750341.png" alt="image-20230206195750341" loading="lazy"></figure>
<figure data-type="image" tabindex="154"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206200401138.png" alt="image-20230206200401138" loading="lazy"></figure>
<figure data-type="image" tabindex="155"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206200810332.png" alt="image-20230206200810332" loading="lazy"></figure>
<figure data-type="image" tabindex="156"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206201032953.png" alt="image-20230206201032953" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;

const int N = 1010;

struct Segment
{
    double l, r;
    bool operator&lt; (const Segment &amp;t) {
        return r &lt; t.r;  // 重载运算符， 按照右端点排序
    }
} segs[N];

int n, r;  // 数量与半径

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;r);

    bool failed = false;  // 如果y坐标大于半径，则
    for (int i = 0; i &lt; n; i ++) {
        int x, y;
        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
        if (y &gt; r) failed = true;
        else {
            double l = sqrt(r * r - y * y);
            segs[i] = {x - l , x + l};
        }
    }

    if (failed) printf(&quot;-1&quot;);
    else {
        int cnt = 0;
        sort(segs, segs + n);  // 先将线段按照右端点排序
        double last = -1e20;
        for (int i = 0; i &lt; n; i ++) {
            if (segs[i].l &gt; last){
                cnt ++;
                last = segs[i].r;
            }
        }
        printf(&quot;%d\n&quot;, cnt);
    }

    return 0;
}
</code></pre>
<h3 id="习题-1235-付账问题">习题 1235. 付账问题</h3>
<p><a href="https://www.acwing.com/problem/content/1237/">1235. 付账问题</a></p>
<p>几个人一起出去吃饭是常有的事。</p>
<p>但在结帐的时候，常常会出现一些争执。</p>
<p>现在有 n个人出去吃饭，他们总共消费了 S元。</p>
<p>其中第 i 个人带了 ai元。</p>
<p>幸运的是，所有人带的钱的总数是足够付账的，但现在问题来了：每个人分别要出多少钱呢？</p>
<p>为了公平起见，我们希望在总付钱量恰好为 S 的前提下，最后每个人付的钱的标准差最小。</p>
<p>这里我们约定，每个人支付的钱数可以是任意非负实数，即可以不是 1 分钱的整数倍。</p>
<p>你需要输出最小的标准差是多少。</p>
<p>标准差的介绍：标准差是多个数与它们平均数差值的平方平均数，一般用于刻画这些数之间的“偏差有多大”。</p>
<p>形式化地说，设第 i 个人付的钱为 bi 元，那么标准差为 :</p>
<figure data-type="image" tabindex="157"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/19_6734517a16-p1.png" alt="p1.png" loading="lazy"></figure>
<h4 id="输入格式-28">输入格式</h4>
<p>第一行包含两个整数 n、S；</p>
<p>第二行包含 n个非负整数 a1, …, an。</p>
<h4 id="输出格式-28">输出格式</h4>
<p>输出最小的标准差，四舍五入保留 44 位小数。</p>
<h4 id="数据范围-28">数据范围</h4>
<p>1≤n≤5×10^5<br>
0≤ai≤10^9<br>
0≤S≤10^15</p>
<h4 id="输入样例1-7">输入样例1：</h4>
<pre><code>5 2333
666 666 666 666 666
</code></pre>
<h4 id="输出样例1-7">输出样例1：</h4>
<pre><code>0.0000
</code></pre>
<h4 id="输入样例2-7">输入样例2：</h4>
<pre><code>10 30
2 1 4 7 4 8 3 6 4 7
</code></pre>
<h4 id="输出样例2-7">输出样例2：</h4>
<pre><code>0.7928
</code></pre>
<figure data-type="image" tabindex="158"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206232123854.png" alt="image-20230206232123854" loading="lazy"></figure>
<figure data-type="image" tabindex="159"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206232418446.png" alt="image-20230206232418446" loading="lazy"></figure>
<figure data-type="image" tabindex="160"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206232821145.png" alt="image-20230206232821145" loading="lazy"></figure>
<figure data-type="image" tabindex="161"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230206233147227.png" alt="image-20230206233147227" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;

const int N = 5e5 + 10;

int n;
int a[N];  // 用来存储 每个同学所携带的钱数

int main() {
    long double s;
    scanf(&quot;%d%Lf&quot;, &amp;n, &amp;s);

    for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;a[i]);

    sort(a, a + n);  // ** 注意一定要排序
    long double res = 0, avg = s / n;
    for (int i = 0; i &lt; n; i ++) {
        double cur = s / (n - i);  // cur 表示当前的同学应该平摊的费用
        if (cur &gt; a[i]) cur = a[i];
        s -= cur;
        res += (cur - avg) * (cur - avg);
    }

    printf(&quot;%.4Lf\n&quot;, sqrt(res / n));

    return 0;
}
</code></pre>
<h3 id="习题-1239-乘积最大">习题 1239. 乘积最大</h3>
<p><a href="https://www.acwing.com/problem/content/1241/">1239. 乘积最大</a></p>
<p>给定 N 个整数 A1,A2,…AN</p>
<p>请你从中选出 K 个数，使其乘积最大。</p>
<p>请你求出最大的乘积，由于乘积可能超出整型范围，你只需输出乘积除以 1000000009的余数。</p>
<p>注意，如果 X&lt;0， 我们定义 X 除以 1000000009的余数是负(−X)除以 1000000009的余数，即：0−((0−x)%1000000009)</p>
<h4 id="输入格式-29">输入格式</h4>
<p>第一行包含两个整数 N 和 K。</p>
<p>以下 N 行每行一个整数 Ai。</p>
<h4 id="输出格式-29">输出格式</h4>
<p>输出一个整数，表示答案。</p>
<h4 id="数据范围-29">数据范围</h4>
<p>1≤K≤N≤10^5<br>
−10<sup>5≤Ai≤10</sup>5</p>
<h4 id="输入样例1-8">输入样例1：</h4>
<pre><code>5 3
-100000
-10000
2
100000
10000
</code></pre>
<h4 id="输出样例1-8">输出样例1：</h4>
<pre><code>999100009
</code></pre>
<h4 id="输入样例2-8">输入样例2：</h4>
<pre><code>5 3
-100000
-100000
-2
-100000
-100000
</code></pre>
<h4 id="输出样例2-8">输出样例2：</h4>
<pre><code>-999999829
</code></pre>
<figure data-type="image" tabindex="162"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207123412429.png" alt="image-20230207123412429" loading="lazy"></figure>
<figure data-type="image" tabindex="163"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207123827239.png" alt="image-20230207123827239" loading="lazy"></figure>
<p>首先我们知道 如果 k == n ,那么就证明所有的数字是全部都选,<br>
如果 k &lt; n , 那么就要思考怎样去选择了:</p>
<ol>
<li>k 如果是偶数的话,选出来的结果一定是非负数 , 原因如下:<br>
(1) # 负数的个数是偶数个的话,负负得正,那么一定是非负数<br>
(2) # 负数的个数如果是奇数个的话,那么我们就只选偶数个绝对值最大的负数</li>
<li>k 如果是奇数个的话,<br>
(1)# 所有的数字如果都是负数,那么选出来的结果也一定都是负数<br>
(2)# 否则的话,则一定至少有 1个非负数, 那么我们将最大的数取出来, 此时要选的个数就是 k--,<br>
则 # k-- 是偶数,那么就又转化为 k-- 是偶数的情况思考</li>
</ol>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;

typedef long long LL;

const int N = 100010, MOD = 1000000009;

int n, k;
int a[N];

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
    for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]);
    sort(a, a + n);

    int l = 0, r = n - 1;  // 双指针初始化
    LL res = 1;
    int sign = 1;

    if (k % 2) {
        // k 是奇数，需要特殊处理符号后，转化为偶数处理方法
        res = a[r];
        r --, k --;
        if (res &lt; 0) sign = -1; 
    } 
    while (k) {
        LL x = (LL)a[l] * a[l + 1] , y = (LL)a[r] * a[r - 1];
        if (x * sign &gt; y *sign) {
            res = x % MOD * res % MOD;
            l += 2;        
        } else {
            res = y % MOD * res % MOD;
            r -= 2;
        }
        k -= 2;
    }
    printf(&quot;%lld\n&quot;, res);

    return 0;
}
</code></pre>
<h3 id="习题-1247-后缀表达式">习题 1247. 后缀表达式</h3>
<p><a href="https://www.acwing.com/problem/content/1249/">1247. 后缀表达式</a></p>
<figure data-type="image" tabindex="164"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207133636934.png" alt="image-20230207133636934" loading="lazy"></figure>
<figure data-type="image" tabindex="165"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207164610743.png" alt="image-20230207164610743" loading="lazy"></figure>
<figure data-type="image" tabindex="166"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207165137652.png" alt="image-20230207165137652" loading="lazy"></figure>
<figure data-type="image" tabindex="167"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207165531264.png" alt="image-20230207165531264" loading="lazy"></figure>
<p>给题意翻译翻译，其实就是有n个加号，m个减号，n+m+1个数，可以加括号，问组成表达式的最大值。</p>
<ul>
<li>特殊情况：m=0，直接输出和</li>
<li>一般情况：把所有数排个序，最大的拿出来，放首项，把最小的数拿出来，给他一个减号，再套一个括号，那么现在还未完成的表达式长这样：</li>
</ul>
<p>可以发现，现在如果我想加一个数的话，给它一个加号，放在括号外面，也可以给它一个减号，放在括号里面；减一个数同理。换句话说，只要用一个减号，一个最大值，一个最小值，其他数我想加就加，想减就减。那么为了使结果最大，我加上正数，减去负数，就是直接加上所有剩下数的绝对值，那么就解决了。</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;

typedef long long LL;

const int N = 200010;

int n, m;
int a[N];

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    int k = n + m + 1;
    for (int i = 0; i &lt; k; i ++) scanf(&quot;%d&quot;, &amp;a[i]);
    sort(a, a + k);
    
    LL res = 0;
    if (!m) {
        for (int i = 0; i &lt; k; i ++) res += a[i]; 
    } else {
        res = a[k - 1] - a[0];
        for (int i = 1; i &lt; k - 1; i ++) res += abs(a[i]);
    }

    printf(&quot;%lld\n&quot;, res);

    return 0;
}
</code></pre>
<h3 id="习题-1248-灵能传输">习题 1248. 灵能传输</h3>
<p><a href="https://www.acwing.com/problem/content/1250/">1248. 灵能传输</a></p>
<p>在游戏《星际争霸 II》中，高阶圣堂武士作为星灵的重要 AOE 单位，在游戏的中后期发挥着重要的作用，其技能”灵能风暴“可以消耗大量的灵能对一片区域内的敌军造成毁灭性的伤害。</p>
<p>经常用于对抗人类的生化部队和虫族的刺蛇飞龙等低血量单位。</p>
<p>你控制着 n 名高阶圣堂武士，方便起见标为 1,2,⋅⋅⋅,n。</p>
<p>每名高阶圣堂武士需要一定的灵能来战斗，每个人有一个灵能值 ai 表示其拥有的灵能的多少（ai 非负表示这名高阶圣堂武士比在最佳状态下多余了 ai点灵能，ai 为负则表示这名高阶圣堂武士还需要 −ai点灵能才能到达最佳战斗状态）。</p>
<p>现在系统赋予了你的高阶圣堂武士一个能力，传递灵能，每次你可以选择一个 i∈[2,n−1]，若 ai≥0则其两旁的高阶圣堂武士，也就是 i−1、i+1 这两名高阶圣堂武士会从 i这名高阶圣堂武士这里各抽取 ai 点灵能；若 ai&lt;0 则其两旁的高阶圣堂武士，也就是 i−1,i+1这两名高阶圣堂武士会给 i 这名高阶圣堂武士 −ai 点灵能。</p>
<p>形式化来讲就是 ai−1+=ai,ai+1+=ai,ai−=2ai。</p>
<p>灵能是非常高效的作战工具，同时也非常危险且不稳定，一位高阶圣堂武士拥有的灵能过多或者过少都不好，定义一组高阶圣堂武士的不稳定度为 maxni=1|ai|，请你通过不限次数的传递灵能操作使得你控制的这一组高阶圣堂武士的不稳定度最小。</p>
<h4 id="输入格式-30">输入格式</h4>
<p>本题包含多组询问。输入的第一行包含一个正整数 T 表示询问组数。</p>
<p>接下来依次输入每一组询问。</p>
<p>每组询问的第一行包含一个正整数 n，表示高阶圣堂武士的数量。</p>
<p>接下来一行包含 n 个数 a1,a2,⋅⋅⋅,an。</p>
<h4 id="输出格式-30">输出格式</h4>
<p>输出 T 行。</p>
<p>每行一个整数依次表示每组询问的答案。</p>
<h4 id="数据范围-30">数据范围</h4>
<p>1≤T≤3,</p>
<p>3≤n≤300000,</p>
<p>|ai|≤10^9</p>
<p>每个评测用例的限制如下：</p>
<figure data-type="image" tabindex="168"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207133848999.png" alt="image-20230207133848999" loading="lazy"></figure>
<h4 id="输入样例1-9">输入样例1：</h4>
<pre><code>3
3
5 -2 3
4
0 0 0 0
3
1 2 3
</code></pre>
<h4 id="输出样例1-9">输出样例1：</h4>
<pre><code>3
0
3
</code></pre>
<h4 id="输入样例2-9">输入样例2：</h4>
<pre><code>3
4
-1 -2 -3 7
4
2 3 4 -8
5
-1 -1 6 -1 -1
</code></pre>
<h4 id="输出样例2-9">输出样例2：</h4>
<pre><code>5
7
4
</code></pre>
<h4 id="样例解释-6">样例解释</h4>
<p>样例一<br>
对于第一组询问：<br>
对 22 号高阶圣堂武士进行传输操作后 a1=3，a2=2，a3=1。答案为 3。<br>
对于第二组询问：<br>
这一组高阶圣堂武士拥有的灵能都正好可以让他们达到最佳战斗状态。</p>
<figure data-type="image" tabindex="169"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207171055995.png" alt="image-20230207171055995" loading="lazy"></figure>
<figure data-type="image" tabindex="170"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207171618554.png" alt="image-20230207171618554" loading="lazy"></figure>
<figure data-type="image" tabindex="171"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207172831680.png" alt="image-20230207172831680" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;

typedef long long LL;

const int N = 300010;

int T, n;
LL a[N], s[N];
bool st[N];

int main() {
    scanf(&quot;%d&quot;, &amp;T);
    while (T --) {
        scanf(&quot;%d&quot;, &amp;n);
        s[0] = 0;

        memset(st, 0, sizeof st);
        for (int i = 1; i &lt;= n; i ++) {
            scanf(&quot;%lld&quot;, &amp;a[i]);
            s[i] = s[i - 1] + a[i];  // 初始化
        }
        LL s0 = s[0], sn = s[n];
        if (s0 &gt; sn) swap(s0, sn);
        sort(s, s + n + 1);

        // 查找下标
        for (int i = 0; i &lt;= n; i ++) {
            if (s0 == s[i]) {
                s0 = i;
                break;
            }
        }
        for (int i = n; i &gt;= 0; i --) {
            if (sn == s[i]) {
                sn = i;
                break;
            }
        }
        
        int l = 0, r = n;
        LL res = 0;  // s0 往左
        for (int i = s0; i &gt;= 0; i -= 2) {
            a[l ++] = s[i];
            st[i] = true;
        }  // sn 往右
        for (int i = sn; i &lt;= n; i += 2) {
            a[r --] = s[i];
            st[i] = true;
        }

        for (int i = 0; i &lt;= n; i++)
            if (!st[i])
                a[l ++] = s[i];

        for (int i = 1; i &lt;= n; i ++) {
            res = max(res, abs(a[i] - a[i - 1]));
        }

        printf(&quot;%lld\n&quot;, res);
    }

    return 0;
}
</code></pre>
<h1 id="数论">数论</h1>
<h2 id="最大公约数-辗转相除法">最大公约数-辗转相除法</h2>
<figure data-type="image" tabindex="172"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207202714414.png" alt="image-20230207202714414" loading="lazy"></figure>
<h3 id="gcd函数">gcd函数</h3>
<pre><code class="language-c++">int gcd(int a, int b) {
    // 求最大公约数
    // 如果b != 0， 则等价于求(b, a % b)的最大公约数
    // 如果b == 0， 则最大公约数为a
    return b ? gcd(b, a % b) : a;
}
</code></pre>
<h3 id="例题-1246-等差数列">例题 1246. 等差数列</h3>
<p><a href="https://www.acwing.com/problem/content/1248/">1246. 等差数列</a></p>
<p>数学老师给小明出了一道等差数列求和的题目。</p>
<p>但是粗心的小明忘记了一部分的数列，只记得其中 N 个整数。</p>
<p>现在给出这 N 个整数，小明想知道包含这 N 个整数的最短的等差数列有几项？</p>
<h4 id="输入格式-31">输入格式</h4>
<p>输入的第一行包含一个整数 N。</p>
<p>第二行包含 N 个整数 A1,A2,⋅⋅⋅,AN。(注意 A1∼AN 并不一定是按等差数<br>
列中的顺序给出)</p>
<h4 id="输出格式-31">输出格式</h4>
<p>输出一个整数表示答案。</p>
<h4 id="数据范围-31">数据范围</h4>
<p>2≤N≤100000,<br>
0≤Ai≤10^9</p>
<h4 id="输入样例-22">输入样例：</h4>
<pre><code>5
2 6 4 10 20
</code></pre>
<h4 id="输出样例-22">输出样例：</h4>
<pre><code>10
</code></pre>
<h4 id="样例解释-7">样例解释</h4>
<p>包含 2、6、4、10、20 的最短的等差数列是 2、4、6、8、10、12、14、16、18、20。</p>
<figure data-type="image" tabindex="173"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207204205206.png" alt="image-20230207204205206" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;

const int N = 100010;

int n;
int a[N], d[N];

int gcd(int a, int b) {
    // 求最大公约数
    // 如果b != 0， 则等价于求(b, a % b)的最大公约数
    // 如果b == 0， 则最大公约数为a
    return b ? gcd(b, a % b) : a;
}

int main() {
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;a[i]);
    sort(a, a + n);
    
    int gd;
    for (int i = 1; i &lt; n; i ++) gd = gcd(gd, a[i] - a[0]);


    // 如果公差为0， 则为常熟列，故长度为n
    if (gd != 0) printf(&quot;%d\n&quot;, ((a[n - 1] - a[0]) / gd) + 1);
    else printf(&quot;%d\n&quot;, n);
    
    return 0;
}
</code></pre>
<h2 id="最大公约数-辗转相减法">最大公约数-辗转相减法</h2>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo><mo>=</mo><mo>(</mo><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mo>−</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a, b) = (b, a - b)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></span></p>
<p>指数相减 = 两个数相除</p>
<pre><code class="language-c++">LL gcd_sub(LL a, LL b) {
    if (a &lt; b) swap(a,b);  //更相减损术总是大减小（它们的底数是一样的）
    if (b == 1) return a;
    return gcd_sub(b, a / b);
}
</code></pre>
<h3 id="习题-1223-最大比例">习题 1223. 最大比例</h3>
<p><a href="https://www.acwing.com/problem/content/1225/">1223. 最大比例</a></p>
<p>X星球的某个大奖赛设了 M 级奖励。</p>
<p>每个级别的奖金是一个正整数。</p>
<p>并且，相邻的两个级别间的比例是个固定值。</p>
<p>也就是说：所有级别的奖金数构成了一个等比数列。</p>
<p>比如：16,24,36,5416,24,36,54，其等比值为：3/23/2。</p>
<p>现在，我们随机调查了一些获奖者的奖金数。</p>
<p>请你据此推算可能的最大的等比值。</p>
<h4 id="输入格式-32">输入格式</h4>
<p>第一行为数字 N ，表示接下的一行包含 N 个正整数。</p>
<p>第二行 N 个正整数 Xi，用空格分开，每个整数表示调查到的某人的奖金数额。</p>
<h4 id="输出格式-32">输出格式</h4>
<p>一个形如 A/B 的分数，要求 A、B 互质，表示可能的最大比例系数。</p>
<h4 id="数据范围-32">数据范围</h4>
<p>0&lt;N&lt;100<br>
0&lt;Xi&lt;10^12<br>
数据保证一定有解。</p>
<h4 id="输入样例1-10">输入样例1：</h4>
<pre><code>3
1250 200 32
</code></pre>
<h4 id="输出样例1-10">输出样例1：</h4>
<pre><code>25/4
</code></pre>
<h4 id="输入样例2-10">输入样例2：</h4>
<pre><code>4
3125 32 32 200
</code></pre>
<h4 id="输出样例2-10">输出样例2：</h4>
<pre><code>5/2
</code></pre>
<h4 id="输入样例3-2">输入样例3：</h4>
<pre><code>3
549755813888 524288 2
</code></pre>
<h4 id="输出样例3-2">输出样例3：</h4>
<pre><code>4/1
</code></pre>
<figure data-type="image" tabindex="174"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230208145106117.png" alt="image-20230208145106117" loading="lazy"></figure>
<figure data-type="image" tabindex="175"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230208145646993.png" alt="image-20230208145646993" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

const int N = 110;

LL x[N], a[N], b[N];
int n, cnt;

LL gcd(LL a, LL b) {
    return b ? gcd(b, a % b) : a; 
}

LL gcd_sub(LL a, LL b) {
    if (a &lt; b) swap(a,b);  //更相减损术总是大减小（它们的底数是一样的）
    if (b == 1) return a;
    return gcd_sub(b, a / b);
}

int main() {
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 0; i &lt; n; i ++) scanf(&quot;%lld&quot;, &amp;x[i]);
    sort(x, x + n);

    for (int i = 1; i &lt; n; i ++) {
        if (x[i] != x[i - 1]) {  // 判重
            LL d = gcd(x[i], x[0]);  // x[i] / x[0]
            a[cnt] = x[i] / d;  // x[i] / d
            b[cnt] = x[0] / d;  // x[0] / d
            cnt ++;
        }
    }

    LL up = a[0], down = b[0];  // 初始化
    for (int i = 1; i &lt; cnt; i ++) {
        up = gcd_sub(up, a[i]);
        down = gcd_sub(down, b[i]);  // 两两求最大公约数
    }

    printf(&quot;%lld/%lld\n&quot;, up, down);

    return 0;
}
</code></pre>
<h2 id="算数基本定理">算数基本定理</h2>
<figure data-type="image" tabindex="176"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207210004353.png" alt="image-20230207210004353" loading="lazy"></figure>
<figure data-type="image" tabindex="177"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207211158309.png" alt="" loading="lazy"></figure>
<h2 id="线性筛质数法">线性筛质数法</h2>
<figure data-type="image" tabindex="178"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207211318536.png" alt="image-20230207211318536" loading="lazy"></figure>
<pre><code class="language-c++">int primes[N], cnt;  // primes 用来存素数， cnt 是素数的数量
bool st[N];  // st 数组用来判断是否被筛选过, 被筛过表示是某个数的倍数

void get_primes(int n) {  // 时间复杂度为O（n）
    for (int i = 2; i &lt;= n; i ++) {
        if (!st[i]) primes[cnt ++] = i;  // 如果没有被筛选过，则是素数并加入
        for (int j = 0; primes[j] * i &lt;= n; j ++) {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
</code></pre>
<h3 id="例题-1295-x的因子链">例题 1295. X的因子链</h3>
<p><a href="https://www.acwing.com/problem/content/1297/">1295. X的因子链</a></p>
<p>输入正整数 X，求 X的大于 11 的因子组成的满足任意前一项都能整除后一项的严格递增序列的最大长度，以及满足最大长度的序列的个数。</p>
<h4 id="输入格式-33">输入格式</h4>
<p>输入包含多组数据，每组数据占一行，包含一个正整数表示 X。</p>
<h4 id="输出格式-33">输出格式</h4>
<p>对于每组数据，输出序列的最大长度以及满足最大长度的序列的个数。</p>
<p>每个结果占一行。</p>
<h4 id="数据范围-33">数据范围</h4>
<p>1≤X≤2^20</p>
<h4 id="输入样例-23">输入样例：</h4>
<pre><code>2
3
4
10
100
</code></pre>
<h4 id="输出样例-23">输出样例：</h4>
<pre><code>1 1
1 1
2 1
2 2
4 6
</code></pre>
<figure data-type="image" tabindex="179"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207211158309.png" alt="image-20230207211158309" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;

typedef long long LL;

const int N = (1 &lt;&lt; 20) + 10;

int primes[N], cnt;  // primes 用来存素数， cnt 是素数的数量
int minp[N];
bool st[N];  // st 数组用来判断是否被筛选过, 被筛过表示是某个数的倍数

void get_primes(int n) {
    for (int i = 2; i &lt;= n; i ++) {
        if (!st[i]) {
            primes[cnt ++] = i;  // 如果没有被筛选过，则是素数并加入
            minp[i] = i;  // 素数的最小质因子是他本身
        }
        for (int j = 0; primes[j] * i &lt;= n; j ++) {
            // 从小到大枚举所有的质数，把这个质数的i倍筛掉
            st[primes[j] * i] = true;  // 筛掉的一定是合数
            minp[primes[j] * i] = primes[j];
            if (i % primes[j] == 0) break;  // 保证primes[j] 一定不大于 i 的最小质因子
        }
    }
}

int main() {
    // 首先将求出有哪些素数
    get_primes(N - 1);
    int x;
    int fact[30], sums[30];  // fact[] 数组存储不同的质因子, sums[i] 存储不用因子的个数
    while (scanf(&quot;%d&quot;, &amp;x) != -1) {
        int k = 0, total = 0;  // ， total 存储分解的总个数
        while (x &gt; 1) {
            int p = minp[x];  // p 为 x 的最小质因子
            fact[k] = p, sums[k] = 0;  // 找到第k个因子为p，初始化次数为0
            while (x % p == 0) {
                x /= p;
                sums[k] ++;
                total ++;
            }
            k ++;  // 开始计算下一个质因子
        }

        LL res = 1;
        for (int i = 1; i &lt;= total; i ++) res *= i;  
        for (int i = 0; i &lt; k; i ++) {
            for (int j = 1; j &lt;= sums[i]; j ++) {
                res /= j;
            }
        } 
        printf(&quot;%d %lld\n&quot;, total, res);
    }

    return 0;
}
</code></pre>
<h2 id="约数个数与约数和">约数个数与约数和</h2>
<figure data-type="image" tabindex="180"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230207235607569.png" alt="image-20230207235607569" loading="lazy"></figure>
<h3 id="例题-1296-聪明的燕姿">例题 1296. 聪明的燕姿</h3>
<p><a href="https://www.acwing.com/problem/content/1298/">1296. 聪明的燕姿</a></p>
<p>城市中人们总是拿着号码牌，不停寻找，不断匹配，可是谁也不知道自己等的那个人是谁。</p>
<p>可是燕姿不一样，燕姿知道自己等的人是谁，因为燕姿数学学得好！</p>
<p>燕姿发现了一个神奇的算法：假设自己的号码牌上写着数字 S，那么自己等的人手上的号码牌数字的所有正约数之和必定等于 S。</p>
<p>所以燕姿总是拿着号码牌在地铁和人海找数字（喂！这样真的靠谱吗）。</p>
<p>可是她忙着唱《绿光》，想拜托你写一个程序能够快速地找到所有自己等的人。</p>
<h4 id="输入格式-34">输入格式</h4>
<p>输入包含 k 组数据。</p>
<p>对于每组数据，输入包含一个号码牌 S。</p>
<h4 id="输出格式-34">输出格式</h4>
<p>对于每组数据，输出有两行。</p>
<p>第一行包含一个整数 m，表示有 m 个等的人。</p>
<p>第二行包含相应的 m 个数，表示所有等的人的号码牌。</p>
<p>注意：你输出的号码牌必须按照升序排列。</p>
<h4 id="数据范围-34">数据范围</h4>
<p>1≤k≤100,<br>
1≤S≤2×10^9</p>
<h4 id="输入样例-24">输入样例：</h4>
<pre><code>42
</code></pre>
<h4 id="输出样例-24">输出样例：</h4>
<pre><code>3
20 26 41
</code></pre>
<figure data-type="image" tabindex="181"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230208001523174.png" alt="image-20230208001523174" loading="lazy"></figure>
<figure data-type="image" tabindex="182"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230208001859309.png" alt="image-20230208001859309" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 50010;

int primes[N], cnt;
int ans[N], len;
bool st[N];

void get_primes(int n) {
    for (int i = 2; i &lt;= n; i ++) {
        if (!st[i]) primes[cnt ++] = i;  // 如果没被筛过
        for (int j = 0; primes[j] * i &lt;= n; j ++) {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}

bool is_primes(int n) {
    if (n &lt; N) return !st[n];  // 如果没被筛选过 说明是质数
    for (int i = 0; primes[i] &lt;= n / primes[i]; i ++) {
        if (n % primes[i] == 0) return false;  // 用质数进行筛选
    }
    return true;
}

void dfs(int last, int prod, int s) {
    // last 表示上一个质数用的下标，prod 表示当前最高次的结果，s 表示每次处理后剩余多少
    if (s == 1) {
        // 表示如果s == 1， 则递归到了最后
        ans[len ++] = prod;  // 即将当前乘积放到最后一个中
        return ;
    }

    if (s - 1 &gt; ((last &lt; 0) ? 0 : primes[last]) &amp;&amp; is_primes(s - 1)) {
        // s - 1 需要大于上一个质数, 并且判断是否为质数
        ans[len ++] = prod * (s - 1);  // 如果为质数，则无法再分，直接加上答案
    }

    for (int i = last + 1; primes[i] &lt;= s / primes[i]; i ++) {
        int p = primes[i];
        for (int j = 1 + p, t = p; j &lt;= s; t *= p, j += t) {
            // 初始化 j = 1 + p, t = p
            // 更新 t =&gt; p * p, j =&gt; 1 + p + p * p
            if (s % j == 0) {
                dfs (i, prod * t, s / j);
            }
        }
    }
}

int main() {
    get_primes(N - 1);

    int s;
    while(scanf(&quot;%d&quot;, &amp;s) != -1) {
        len = 0;
        dfs(-1, 1, s);

        printf(&quot;%d\n&quot;, len);

        sort(ans, ans + len);
        if (len) {
            for (int i = 0; i &lt; len; i ++) printf(&quot;%d &quot;, ans[i]);
        printf(&quot;\n&quot;);
        }
    }

    return 0;
}
</code></pre>
<h2 id="裴蜀定理-扩展欧几里得定理">裴蜀定理-扩展欧几里得定理</h2>
<figure data-type="image" tabindex="183"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230208133324852.png" alt="image-20230208133324852" loading="lazy"></figure>
<figure data-type="image" tabindex="184"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230208134013644.png" alt="image-20230208134013644" loading="lazy"></figure>
<figure data-type="image" tabindex="185"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230208134200366.png" alt="image-20230208134200366" loading="lazy"></figure>
<figure data-type="image" tabindex="186"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230208134341439.png" alt="image-20230208134341439" loading="lazy"></figure>
<h3 id="例题-1299-五指山">例题 1299. 五指山</h3>
<p><a href="https://www.acwing.com/problem/content/1301/">1299. 五指山</a></p>
<p>大圣在佛祖的手掌中。</p>
<p>我们假设佛祖的手掌是一个圆圈，圆圈的长为 n，逆时针记为：0,1,2,…,n−1，而大圣每次飞的距离为 d。</p>
<p>现在大圣所在的位置记为 x，而大圣想去的地方在 y。</p>
<p>要你告诉大圣至少要飞多少次才能到达目的地。</p>
<p><strong>注意</strong>：孙悟空的筋斗云只沿着逆时针方向翻。</p>
<h4 id="输入格式-35">输入格式</h4>
<p>有多组测试数据。</p>
<p>第一行是一个正整数 T，表示测试数据的组数；</p>
<p>每组测试数据包括一行，四个非负整数，分别为如来手掌圆圈的长度 n，筋斗所能飞的距离 d，大圣的初始位置 x 和大圣想去的地方 y。</p>
<h4 id="输出格式-35">输出格式</h4>
<p>对于每组测试数据，输出一行，给出大圣最少要翻多少个筋斗云才能到达目的地。</p>
<p>如果无论翻多少个筋斗云也不能到达，输出 Impossible。</p>
<h4 id="数据范围-35">数据范围</h4>
<p>1≤T≤5<br>
2&lt;n&lt;10^9<br>
0&lt;d&lt;n<br>
0≤x,y&lt;n</p>
<h4 id="输入样例-25">输入样例：</h4>
<pre><code>2
3 2 0 2
3 2 0 1
</code></pre>
<h4 id="输出样例-25">输出样例：</h4>
<pre><code>1
2
</code></pre>
<figure data-type="image" tabindex="187"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230208140512726.png" alt="image-20230208140512726" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

LL exgcd(LL a, LL b, LL &amp;x, LL &amp;y) {
    // ax+by=gcd(a,b)  //x, y为待求整数,返回值为gcd(a,b)
    if (!b) {
        // 当b == 0时，a和b的最大公约数为a.则x = 1
        x = 1, y = 0;
        return a;
    }
    // 当b != 0时，by+(a mod b)x = gcd(a,b)
    LL d = exgcd(b, a % b, y, x);
    // 上式化为by+(a - a/b * b)x = gcd(a,b)  -&gt;  ax+b(y - a/b * x) = gcd(a,b)
    // 由以上变换得：欧几里得定理每递归一次x不用变,y = y-a/b * x
    y -= a / b * x;
    return d;
}

int main() {
    int T;

    scanf(&quot;%d&quot;, &amp;T);
    while (T --) {
        LL n, d, x, y, a, b;
        scanf(&quot;%lld%lld%lld%lld&quot;, &amp;n, &amp;d, &amp;x, &amp;y);
        LL gcd = exgcd(n, d, a, b);  // exgcd 求 an + bd = gcd
        if ((y - x) % gcd != 0)  // 无解
            printf(&quot;Impossible\n&quot;);
        else {
            // 恢复原式子
            b *= (y - x) / gcd;
            n /= gcd;
            b = (b % n + n) % n;
            printf(&quot;%d\n&quot;, b);
        }
    }

    return 0;
}
</code></pre>
<h3 id="习题-1301-c-循环">习题 1301. C 循环</h3>
<p><a href="https://www.acwing.com/problem/content/1303/">1301. C 循环</a></p>
<p>对于 C 语言的循环语句，形如：</p>
<pre><code>for (variable = A; variable != B; variable += C)
  statement;
</code></pre>
<p>请问在 k 位存储系统中循环几次才会结束。</p>
<p>若在有限次内结束，则输出循环次数。否则输出死循环。</p>
<h4 id="输入格式-36">输入格式</h4>
<p>多组数据，每组数据一行四个整数 A,B,C,k</p>
<p>读入以 0 0 0 0 结束。</p>
<h4 id="输出格式-36">输出格式</h4>
<p>若在有限次内结束，则输出循环次数。</p>
<p>否则输出 FOREVER。</p>
<h4 id="数据范围-36">数据范围</h4>
<p>1≤k≤32<br>
0≤A,B,C&lt;2k</p>
<h4 id="输入样例-26">输入样例：</h4>
<pre><code>3 3 2 16
3 7 2 16
7 3 2 16
3 4 2 16
0 0 0 0
</code></pre>
<h4 id="输出样例-26">输出样例：</h4>
<pre><code>0
2
32766
FOREVER
</code></pre>
<figure data-type="image" tabindex="188"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230208152942586.png" alt="image-20230208152942586" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

const int N = 110;

LL a, b, c, k, x, y;

LL exgcd(LL a, LL b, LL &amp;x, LL &amp;y) {
    if (b == 0) {
        x = 1, y = 0;
        return a;
    }
    LL d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}

int main() {
    while (true) {
        scanf(&quot;%lld%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;c, &amp;k);
        if (a == 0 &amp;&amp; b == 0 &amp; c == 0 &amp; k == 0) break;
        LL t = 1ll &lt;&lt; k;
        LL d = exgcd(c, t, x, y);
        if ((b - a) % d) printf(&quot;FOREVER\n&quot;);
        else {
            x *= (b - a) / d;
            t /= d;
            printf(&quot;%lld\n&quot;, (x % t + t) % t);
        }
    }

    return 0;
}
</code></pre>
<h1 id="复杂dp">复杂DP</h1>
<h2 id="线性dp">线性DP</h2>
<h3 id="例题-1050-鸣人的影分身">例题 1050. 鸣人的影分身</h3>
<p><a href="https://www.acwing.com/problem/content/1052/">1050. 鸣人的影分身</a></p>
<p>在火影忍者的世界里，令敌人捉摸不透是非常关键的。</p>
<p>我们的主角漩涡鸣人所拥有的一个招数——多重影分身之术——就是一个很好的例子。</p>
<p>影分身是由鸣人身体的查克拉能量制造的，使用的查克拉越多，制造出的影分身越强。</p>
<p>针对不同的作战情况，鸣人可以选择制造出各种强度的影分身，有的用来佯攻，有的用来发起致命一击。</p>
<p>那么问题来了，假设鸣人的查克拉能量为 M，他影分身的个数最多为 N，那么制造影分身时有多少种不同的分配方法？</p>
<p><strong>注意</strong>：</p>
<ol>
<li>影分身可以分配0点能量。</li>
<li>分配方案不考虑顺序，例如：M=7,N=3，那么 (2,2,3)和 (2,3,2) 被视为同一种方案。</li>
</ol>
<h4 id="输入格式-37">输入格式</h4>
<p>第一行是测试数据的数目 t。</p>
<p>以下每行均包含二个整数 M 和 N，以空格分开。</p>
<h4 id="输出格式-37">输出格式</h4>
<p>对输入的每组数据 M 和 N，用一行输出分配的方法数。</p>
<h4 id="数据范围-37">数据范围</h4>
<p>0≤t≤20<br>
1≤M,N≤10</p>
<h4 id="输入样例-27">输入样例：</h4>
<pre><code>1
7 3
</code></pre>
<h4 id="输出样例-27">输出样例：</h4>
<pre><code>8
</code></pre>
<figure data-type="image" tabindex="189"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230208225414280.png" alt="image-20230208225414280" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 11;
int f[N][N];
int t, n, m;

int main() {
    scanf(&quot;%d&quot;, &amp;t);

    while (t --) {
        scanf(&quot;%d%d&quot;, &amp;m, &amp;n);

        f[0][0] = 1;
        for (int i = 0; i &lt;= m; i ++) {  // f[0][j] 是有意义的，表示取j个0
            for (int j = 1; j &lt;= n; j ++) {  // 由于f[0][0] 已经定义过，故j 从 1 开始
                f[i][j] = f[i][j - 1];
                if (i &gt;= j) f[i][j] += f[i - j][j];
            }
        }
        printf(&quot;%d\n&quot;, f[m][n]);
    }

    return 0;
}
</code></pre>
<h2 id="背包模型">背包模型</h2>
<h3 id="例题-1047-糖果">例题 1047. 糖果</h3>
<p><a href="https://www.acwing.com/problem/content/1049/">1047. 糖果</a></p>
<p>由于在维护世界和平的事务中做出巨大贡献，Dzx被赠予糖果公司2010年5月23日当天无限量糖果免费优惠券。</p>
<p>在这一天，Dzx可以从糖果公司的 N 件产品中任意选择若干件带回家享用。</p>
<p>糖果公司的 N 件产品每件都包含数量不同的糖果。</p>
<p>Dzx希望他选择的产品包含的糖果总数是 K 的整数倍，这样他才能平均地将糖果分给帮助他维护世界和平的伙伴们。</p>
<p>当然，在满足这一条件的基础上，糖果总数越多越好。</p>
<p>Dzx最多能带走多少糖果呢？</p>
<p>注意：Dzx只能将糖果公司的产品整件带走。</p>
<h4 id="输入格式-38">输入格式</h4>
<p>第一行包含两个整数 N和 K。</p>
<p>以下 N 行每行 1 个整数，表示糖果公司该件产品中包含的糖果数目，不超过 1000000。</p>
<h4 id="输出格式-38">输出格式</h4>
<p>符合要求的最多能达到的糖果总数，如果不能达到 K 的倍数这一要求，输出 0。</p>
<h4 id="数据范围-38">数据范围</h4>
<p>1≤N≤100,<br>
1≤K≤100,</p>
<h4 id="输入样例-28">输入样例：</h4>
<pre><code>5 7
1
2
3
4
5
</code></pre>
<h4 id="输出样例-28">输出样例：</h4>
<pre><code>14
</code></pre>
<h4 id="样例解释-8">样例解释</h4>
<p>Dzx的选择是2+3+4+5=14，这样糖果总数是7的倍数，并且是总数最多的选择。</p>
<figure data-type="image" tabindex="190"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230208233331083.png" alt="image-20230208233331083" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 110;

int f[N][N];
int n, k;

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);

    // 由于f[0][1],f[0][2] 均无意义，故需要先初始化
    memset(f, -0x3f, sizeof f);
    f[0][0] = 0;
    for (int i = 1; i &lt;= n; i ++) {
        int w;
        scanf(&quot;%d&quot;, &amp;w);
        for (int j = 0; j &lt; k; j ++) {
            f[i][j] = max(f[i - 1][j], f[i - 1][(j + k - w % k) % k] + w);
        }
    }
    printf(&quot;%d\n&quot;, f[n][0]);

    return 0;
}
</code></pre>
<h3 id="习题-1226-包子凑数">习题 1226. 包子凑数</h3>
<p><a href="https://www.acwing.com/problem/content/1228/">1226. 包子凑数</a></p>
<p>小明几乎每天早晨都会在一家包子铺吃早餐。</p>
<p>他发现这家包子铺有 N 种蒸笼，其中第 i 种蒸笼恰好能放 Ai 个包子。</p>
<p>每种蒸笼都有非常多笼，可以认为是无限笼。</p>
<p>每当有顾客想买 X 个包子，卖包子的大叔就会迅速选出若干笼包子来，使得这若干笼中恰好一共有 X 个包子。</p>
<p>比如一共有 3种蒸笼，分别能放 3、4和 5 个包子。</p>
<p>当顾客想买 11个包子时，大叔就会选 2 笼 3 个的再加 1笼 5 个的（也可能选出 1笼 3个的再加 2 笼 4个的）。</p>
<p>当然有时包子大叔无论如何也凑不出顾客想买的数量。</p>
<p>比如一共有 33种蒸笼，分别能放 4、5和 6个包子。</p>
<p>而顾客想买 7 个包子时，大叔就凑不出来了。</p>
<p>小明想知道一共有多少种数目是包子大叔凑不出来的。</p>
<h4 id="输入格式-39">输入格式</h4>
<p>第一行包含一个整数 N。</p>
<p>接下来 N 行，每行包含一个整数 Ai。</p>
<h4 id="输出格式-39">输出格式</h4>
<p>输出一个整数代表答案。</p>
<p>如果凑不出的数目有无限多个，输出INF。</p>
<h4 id="数据范围-39">数据范围</h4>
<p>1≤N≤100<br>
1≤Ai≤100</p>
<h4 id="输入样例1-11">输入样例1：</h4>
<pre><code>2
4
5
</code></pre>
<h4 id="输出样例1-11">输出样例1：</h4>
<pre><code>6
</code></pre>
<h4 id="输入样例2-11">输入样例2：</h4>
<pre><code>2
4
6
</code></pre>
<h4 id="输出样例2-11">输出样例2：</h4>
<pre><code>INF
</code></pre>
<h4 id="样例解释-9">样例解释</h4>
<p>对于样例1，凑不出的数目包括：1, 2, 3, 6, 7, 11。<br>
对于样例2，所有奇数都凑不出来，所以有无限多个。</p>
<figure data-type="image" tabindex="191"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230209190723768.png" alt="image-20230209190723768" loading="lazy"></figure>
<p>买不到的数目 + 完全背包</p>
<p>根据买不到的数目 可知，体积最大是100，因此不能凑出的最大的数是N = (99 - 1) * (100 - 1) - 1,即最大体积是N</p>
<ol>
<li>
<p>判断给定的所有数最大公约数是否是1，若不是则返回INF</p>
</li>
<li>
<p>若是</p>
<ul>
<li>
<p>状态表示	-</p>
<ul>
<li><code>f[i][j]</code> 表示：是否能从前i个物品中选,且能恰好能凑出体积是j</li>
</ul>
</li>
<li>
<p>状态计算</p>
<ul>
<li><code>f[i][j] = f[i - 1][j] || f[i - 1][j - v] || f[i - 1][j - 2v]...</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<figure data-type="image" tabindex="192"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230209191418490.png" alt="image-20230209191418490" loading="lazy"></figure>
<h4 id="二维代码">二维代码</h4>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 10010;

int n;
int a[110];  // 用来存储Ai
bool f[110][N];  // dp

int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}

int main() {
    scanf(&quot;%d&quot;, &amp;n);
    int d = 0;
    for (int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]);

    for (int i = 1; i &lt;= n; i ++) d = gcd(d, a[i]);

    if (d != 1) printf(&quot;INF&quot;);
    else {
        f[0][0] = true;
        for (int i = 1; i &lt;= n; i ++) {
            for (int j = 0; j &lt; N; j ++) {
                // f[i][j] 表示从前i个中选，凑出j
                f[i][j] = f[i - 1][j];
                if (j &gt;= a[i]) f[i][j] |= f[i][j - a[i]];
            }
        }
        int res = 0;
        for (int i = 0; i &lt; N; i ++) {
            if (!f[n][i]) res ++;
        }
        printf(&quot;%d\n&quot;, res);
    }
    return 0;
}
</code></pre>
<h4 id="优化后的一维代码">优化后的一维代码</h4>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 10010;

int n;
int a[110];  // 用来存储Ai
bool f[N];  // dp

int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}

int main() {
    scanf(&quot;%d&quot;, &amp;n);
    int d = 0;
    for (int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]);

    for (int i = 1; i &lt;= n; i ++) d = gcd(d, a[i]);

    if (d != 1) printf(&quot;INF&quot;);
    else {
        f[0] = true;
        for (int i = 1; i &lt;= n; i ++) {
            for (int j = 0; j &lt; N; j ++) {
                f[j] |= f[j - a[i]];
            }
        }
        int res = 0;
        for (int i = 0; i &lt; N; i ++) {
            if (!f[i]) res ++;
        }
        printf(&quot;%d\n&quot;, res);
    }
    return 0;
}
</code></pre>
<h2 id="区间dp">区间DP</h2>
<h3 id="例题-1222-密码脱落">例题 1222. 密码脱落</h3>
<p><a href="https://www.acwing.com/problem/content/1224/">1222. 密码脱落</a></p>
<figure data-type="image" tabindex="193"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230209142156000.png" alt="image-20230209142156000" loading="lazy"></figure>
<p>从当前样子变成初始状态需要添加叶子的数量 <strong>等价于</strong> 当前样子变成最大的回文串需要剪去的叶子的数量<br>
即至少脱落多少个种子 等价于 <strong>总数量 - 最大回文子序列的长度</strong></p>
<figure data-type="image" tabindex="194"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230209144325271.png" alt="image-20230209144325271" loading="lazy"></figure>
<figure data-type="image" tabindex="195"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230209150654672.png" alt="image-20230209150654672" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &quot;string.h&quot;

using namespace std;

const int N = 1010;

char s[N];
int f[N][N];

int main() {
    scanf(&quot;%s&quot;, s);
    int n = strlen(s);

    // 对于区间dp来说，通常以区间长度进行循环
    for (int len = 1; len &lt;= n; len ++) {
        for (int l = 0; l + len - 1 &lt; n; l ++) {
            // 从区间左端点进行枚举，然后计算右
            int r = l + len - 1;
            if (len == 1) f[l][r] = 1;
            else {
                if (s[l] == s[r]) f[l][r] = f[l + 1][r - 1] + 2;
                if (f[l][r - 1] &gt; f[l][r]) f[l][r] = f[l][r - 1];
                if (f[l + 1][r] &gt; f[l][r]) f[l][r] = f[l + 1][r];
            }
        }
    }
    printf(&quot;%d\n&quot;, n - f[0][n - 1]);

    return 0;
}
</code></pre>
<h3 id="习题-1070-括号配对">习题 1070. 括号配对</h3>
<p><a href="https://www.acwing.com/problem/content/1072/">1070. 括号配对</a></p>
<p>Hecy 又接了个新任务：BE 处理。</p>
<p>BE 中有一类被称为 GBE。</p>
<p>以下是 GBE 的定义：</p>
<ul>
<li>空表达式是 GBE</li>
<li>如果表达式 A 是 GBE，则 [A] 与 (A) 都是 GBE</li>
<li>如果 A 与 B 都是 GBE，那么 AB 是 GBE</li>
</ul>
<p>下面给出一个 BE，求至少添加多少字符能使这个 BE 成为 GBE。</p>
<p>注意：BE 是一个仅由<code>(</code>、<code>)</code>、<code>[</code>、<code>]</code>四种字符中的若干种构成的字符串。</p>
<h4 id="输入格式-40">输入格式</h4>
<p>输入仅一行，为字符串 BE。</p>
<h4 id="输出格式-40">输出格式</h4>
<p>输出仅一个整数，表示增加的最少字符数。</p>
<h4 id="数据范围-40">数据范围</h4>
<p>对于所有输入字符串，其长度小于100。</p>
<h4 id="输入样例-29">输入样例：</h4>
<pre><code>[])
</code></pre>
<h4 id="输出样例-29">输出样例：</h4>
<pre><code>1
</code></pre>
<figure data-type="image" tabindex="196"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230209205347534.png" alt="image-20230209205347534" loading="lazy"></figure>
<h4 id="代码实现">代码实现</h4>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 110, INF = 10000000;

int f[N][N];

bool is_match(char l, char r) {
    if (l == '(' &amp;&amp; r == ')') return true;
    if (l == '[' &amp;&amp; r == ']') return true;
    return false;
}

int main() {
    string s;
    cin &gt;&gt; s;
    int n = s.size();

    for (int len = 1; len &lt;= n; len ++) {
        for (int l = 0; l + len - 1 &lt; n; l ++) {
            int r = l + len - 1;
            f[l][r] = INF;
            if (is_match(s[l], s[r])) f[l][r] = f[l + 1][r - 1];  // 左右匹配，表示不需要加字符
            f[l][r] = min(f[l][r], min(f[l + 1][r], f[l][r - 1]) + 1);

            for (int k = l; k &lt; r; k ++) {
                f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r]);
            }
        }
    }
    printf(&quot;%d\n&quot;, f[0][n - 1]);

    return 0;
}
</code></pre>
<h2 id="树形dp">树形DP</h2>
<h3 id="例题-1220-生命之树">例题 1220. 生命之树</h3>
<p><a href="https://www.acwing.com/problem/content/1222/">1220. 生命之树</a></p>
<p>在X森林里，上帝创建了生命之树。</p>
<p>他给每棵树的每个节点（叶子也称为一个节点）上，都标了一个整数，代表这个点的和谐值。</p>
<p>上帝要在这棵树内选出一个非空节点集 S，使得对于 S 中的任意两个点 a,b，都存在一个点列 {a,v1,v2,…,vk,b} 使得这个点列中的每个点都是 S 里面的元素，且序列中相邻两个点间有一条边相连。</p>
<p>在这个前提下，上帝要使得 S 中的点所对应的整数的和尽量大。</p>
<p>这个最大的和就是上帝给生命之树的评分。</p>
<p>经过 atm 的努力，他已经知道了上帝给每棵树上每个节点上的整数。</p>
<p>但是由于 atm 不擅长计算，他不知道怎样有效的求评分。</p>
<p>他需要你为他写一个程序来计算一棵树的分数。</p>
<h4 id="输入格式-41">输入格式</h4>
<p>第一行一个整数 n 表示这棵树有 n 个节点。</p>
<p>第二行 n 个整数，依次表示每个节点的评分。</p>
<p>接下来 n−1，每行 2 个整数 u,v，表示存在一条 u到 v的边。</p>
<p>由于这是一棵树，所以是不存在环的。</p>
<p>树的节点编号从 1到 n。</p>
<h4 id="输出格式-41">输出格式</h4>
<p>输出一行一个数，表示上帝给这棵树的分数。</p>
<h4 id="数据范围-41">数据范围</h4>
<p>1≤n≤10^5<br>
每个节点的评分的绝对值均不超过 10^6。</p>
<h4 id="输入样例-30">输入样例：</h4>
<pre><code>5
1 -2 -3 4 5
4 2
3 1
1 2
2 5
</code></pre>
<h4 id="输出样例-30">输出样例：</h4>
<pre><code>8
</code></pre>
<p>一般使用f[u]表示树形dp</p>
<ul>
<li>本题中,f[u]表示的是以u为根节点的连通块的sum的最大值</li>
<li>f[u]=w[u]+max(子树的情况，0)</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

const int N = 100010, M = 2 * N;

int n;
int w[N];
int h[N], e[M], ne[M], idx;
LL f[N];

void add(int a, int b) {
    // 数组实现邻接表来存储图
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

void dfs(int u, int father) {
    // u 表示当前节点，father 表示上一个节点
    f[u] = w[u];  // f[u]=w[u]+max(子树的情况，0)
    for (int i = h[u]; i != -1; i = ne[i]) {
        //  以u为头节点，遍历其
        int j = e[i];
        if (j != father) {
            dfs(j, u);  // 继续遍历
            f[u] += max(0ll, f[j]);  // 如果&lt;=0, 则没必要加上
        }
    }
}

int main() {
    scanf(&quot;%d&quot;, &amp;n);
    memset(h, -1, sizeof h);// 记得h数组置-1

    for (int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;w[i]);

    for (int i = 0; i &lt; n - 1; i ++) {
        int a, b;
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        add(a, b);
        add(b, a);
    }

    dfs(1, -1);

    LL res = 0;
    for (int i = 1; i &lt;= n; i ++) res = max(res, f[i]);
    printf(&quot;%lld\n&quot;, res);

    return 0;
}
</code></pre>
<h3 id="习题-1078-旅游规划">习题 1078. 旅游规划</h3>
<p><a href="https://www.acwing.com/problem/content/1080/">1078. 旅游规划</a></p>
<p>W 市的交通规划出现了重大问题，市政府下定决心在全市各大交通路口安排疏导员来疏导密集的车流。</p>
<p>但由于人员不足，W 市市长决定只在最需要安排人员的路口安排人员。</p>
<p>具体来说，W 市的交通网络十分简单，由 n 个交叉路口和 n−1 条街道构成，交叉路口路口编号依次为 0,1,…,n−1 。</p>
<p>任意一条街道连接两个交叉路口，且任意两个交叉路口间都存在一条路径互相连接。</p>
<p>经过长期调查，结果显示，如果一个交叉路口位于 W 市交通网最长路径上，那么这个路口必定拥挤不堪。</p>
<p>所谓最长路径，定义为某条路径 p=(v1,v2,…,vk)，路径经过的路口各不相同，且城市中不存在长度大于 k 的路径（因此最长路径可能不唯一）。</p>
<p>因此 W 市市长想知道哪些路口位于城市交通网的最长路径上。</p>
<h4 id="输入格式-42">输入格式</h4>
<p>第一行包含一个整数 n。</p>
<p>之后 n−1行每行两个整数 u,v，表示编号为 u 和 v 的路口间存在着一条街道。</p>
<h4 id="输出格式-42">输出格式</h4>
<p>输出包括若干行，每行包括一个整数——某个位于最长路径上的路口编号。</p>
<p>为了确保解唯一，请将所有最长路径上的路口编号按编号顺序由小到大依次输出。</p>
<h4 id="数据范围-42">数据范围</h4>
<p>1≤n≤2×10^5</p>
<h4 id="输入样例-31">输入样例：</h4>
<pre><code>10
0 1
0 2
0 4
0 6
0 7
1 3
2 5
4 8
6 9
</code></pre>
<h4 id="输出样例-31">输出样例：</h4>
<pre><code>0
1
2
3
4
5
6
8
9
</code></pre>
<figure data-type="image" tabindex="197"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230209225007447.png" alt="image-20230209225007447" loading="lazy"></figure>
<figure data-type="image" tabindex="198"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230209234928728.png" alt="image-20230209234928728" loading="lazy"></figure>
<img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230209235109290.png" alt="image-20230209235109290" style="zoom:50%;" />
<figure data-type="image" tabindex="199"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230209235205019.png" alt="image-20230209235205019" loading="lazy"></figure>
<h4 id="代码实现-2">代码实现</h4>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 200010, M = N * 2;

int n;
int h[N], e[M], ne[M], idx;
int d1[N], d2[N], p1[N], up[N];
int maxd;  // 直径

void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

void dfs_d(int u, int father) {
    for (int i = h[u]; ~i; i = ne[i]) {
        int j = e[i];
        if (j != father) {
            dfs_d(j, u);
            int distance = d1[j] + 1;
            if (distance &gt; d1[u]) {
                d2[u] = d1[u], d1[u] = distance;  // 更新最大值和次大值
                p1[u] = j;
            } else if (distance &gt; d2[u]) {
                d2[u] = distance;  // 更新次大值
            }
        }
    }
    maxd = max(maxd, d1[u] + d2[u]);
}

void dfs_u(int u, int father) {
    for (int i = h[u]; ~i; i = ne[i]) {
        int j = e[i];
        if (j != father) {
            up[j] = up[u] + 1;
            if (p1[u] == j) {
                up[j] = max(up[j], d2[u] + 1);
            } else {
                up[j] = max(up[j], d1[u] + 1);
            }
            dfs_u(j, u);
        }
    }
}

int main() {
    scanf(&quot;%d&quot;, &amp;n);
    memset(h, -1, sizeof h);  

    for (int i = 0; i &lt; n; i ++) {
        int a, b;
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        add(a, b), add(b, a);
    }

    dfs_d(0, -1);
    dfs_u(0, -1);

    for (int i = 0; i &lt; n; i ++) {
        int d[3] = {d1[i], d2[i], up[i]};
        sort(d, d + 3);
        if (d[1] + d[2] == maxd) printf(&quot;%d\n&quot;, i);  // 如果最大的等于直径，则输出
    }

    return 0;
}
</code></pre>
<h2 id="矩阵快速幂">矩阵快速幂</h2>
<figure data-type="image" tabindex="200"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230209160940486.png" alt="image-20230209160940486" loading="lazy"></figure>
<h3 id="例题-1303-斐波那契前-n-项和">例题 1303. 斐波那契前 n 项和</h3>
<p><a href="https://www.acwing.com/problem/content/1305/">1303. 斐波那契前 n 项和</a></p>
<figure data-type="image" tabindex="201"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230209154925248.png" alt="image-20230209154925248" loading="lazy"></figure>
<figure data-type="image" tabindex="202"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230209160940486.png" alt="image-20230209160940486" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

const int N = 3;

int n, m;

void mul(int c[], int a[], int b[][N]) {
    int tmp[N] = {0};
    for (int i = 0; i &lt; N; i ++) {
        for (int j = 0; j &lt; N; j ++) {
            tmp[i] = (tmp[i] + (LL)a[j] * b[j][i]) % m;
        }
    }

    memcpy(c, tmp, sizeof tmp);
}

void mul(int c[][N], int a[][N], int b[][N]) {
    int tmp[N][N] = {0};
    for (int i = 0; i &lt; N; i ++) {
        for (int j = 0; j &lt; N; j ++) {
            for (int k = 0; k &lt; N; k ++) {
                tmp[i][j] = (tmp[i][j] + (LL)a[i][k] * b[k][j]) % m;
            }
        }
    }
    memcpy(c, tmp, sizeof tmp);
}

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);

    int f1[N] = {1, 1, 1};  // {f1, f2, s1}
    int a[N][N] = {
        {0, 1, 0},
        {1, 1, 1},
        {0, 0, 1}
    };

    n --;  // f1*A^(n - 1) = fn
    for (int i = n; i; i &gt;&gt;= 1) {
        if (i &amp; 1) mul(f1, f1, a);   // res = res * a
        mul(a, a, a);
    }
    printf(&quot;%d\n&quot;, f1[2]);
    return 0;
}
</code></pre>
<h3 id="习题-1217-垒骰子">习题 1217. 垒骰子</h3>
<p><a href="https://www.acwing.com/problem/content/description/1219/">1217. 垒骰子</a></p>
<p>赌圣atm晚年迷恋上了垒骰子，就是把骰子一个垒在另一个上边，不能歪歪扭扭，要垒成方柱体。</p>
<p>经过长期观察，atm 发现了稳定骰子的奥秘：有些数字的面贴着会互相排斥！</p>
<p>我们先来规范一下骰子：1 的对面是 4，2 的对面是 5，3 的对面是 6。</p>
<p>假设有 m 组互斥现象，每组中的那两个数字的面紧贴在一起，骰子就不能稳定的垒起来。</p>
<p>atm想计算一下有多少种不同的可能的垒骰子方式。</p>
<p>两种垒骰子方式相同，当且仅当这两种方式中对应高度的骰子的对应数字的朝向都相同。</p>
<p>由于方案数可能过多，请输出模 10^9+7的结果。</p>
<h4 id="输入格式-43">输入格式</h4>
<p>第一行包含两个整数 n,m，分别表示骰子的数目和排斥的组数。</p>
<p>接下来 m 行，每行两个整数 a,b，表示 a 和 b 数字不能紧贴在一起。</p>
<h4 id="输出格式-43">输出格式</h4>
<p>共一个数，表示答案模 109+7109+7 的结果。</p>
<h4 id="数据范围-43">数据范围</h4>
<p>1≤n≤10^9,<br>
1≤m≤36<br>
1≤a,b≤6</p>
<h4 id="输入样例-32">输入样例：</h4>
<pre><code>2 1
1 2
</code></pre>
<h4 id="输出样例-32">输出样例：</h4>
<pre><code>544
</code></pre>
<figure data-type="image" tabindex="203"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230210003118369.png" alt="image-20230210003118369" loading="lazy"></figure>
<figure data-type="image" tabindex="204"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20230210003325577.png" alt="image-20230210003325577" loading="lazy"></figure>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

const int N = 6, MOD = 1e9 + 7;

int n, m;

int get_op(int x) {
    if (x &gt;= 3) return x -= 3;  // 4 - 1, 5 - 2, 6 - 3, 且坐标从0开始
    else return x += 3;
}

void mul(int c[][N], int a[][N], int b[][N]) {
    int tmp[N][N];
    memset(tmp, 0, sizeof tmp);
    for (int i = 0; i &lt; N; i ++) {
        for (int j = 0; j &lt; N; j ++) {
            for (int k = 0; k &lt; N; k ++) {
                tmp[i][j] = (tmp[i][j] + (LL)a[i][k] * b[k][j]) % MOD;
            }
        }
    }
    memcpy(c, tmp, sizeof tmp);
}

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);

    int a[N][N];
    // A 矩阵初始化
    for (int i = 0; i &lt; N; i ++) {
        for (int j = 0; j &lt; N; j ++) {
            a[i][j] = 4;
        }
    }
    while (m --) {
        // 对立面空集
        int x, y;
        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
        x --, y --;  // 下标从0开始
        a[x][get_op(y)] = 0;
        a[y][get_op(x)] = 0;
    }

    int f1[N][N] = {4, 4, 4, 4, 4, 4};  // F1 
    for (int k = n - 1; k; k &gt;&gt;= 1) {
        if (k &amp; 1) mul(f1, f1, a);  // F = F * A
        mul(a, a, a);  // A = A * A
    }

    int res = 0;
    for (int i = 0; i &lt; N; i ++) {
        res = (res + f1[0][i]) % MOD;
    }
    printf(&quot;%d\n&quot;, res);

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ubuntu 20.04 配置]]></title>
        <id>https://CNZedChou.github.io/post/ubuntu-2004-pei-zhi/</id>
        <link href="https://CNZedChou.github.io/post/ubuntu-2004-pei-zhi/">
        </link>
        <updated>2022-11-15T12:26:58.000Z</updated>
        <summary type="html"><![CDATA[<p>@Description:   用于记录虚拟机 配置Ubuntu20.04的过程<br>
@Author:    Zed Chou<br>
@LastModified:    Tue 15 Nov 2022</p>
]]></summary>
        <content type="html"><![CDATA[<p>@Description:   用于记录虚拟机 配置Ubuntu20.04的过程<br>
@Author:    Zed Chou<br>
@LastModified:    Tue 15 Nov 2022</p>
<!-- more -->
<h1 id="关于配置">关于配置</h1>
<p>VM 配置</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115205723099.png" alt="vm 配置" loading="lazy"></figure>
<h1 id="配置流程">配置流程</h1>
<h2 id="创建虚拟机">创建虚拟机</h2>
<p>【文件】==》【新建虚拟机】</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115205821962.png" alt="选择自定义" loading="lazy"></figure>
<h3 id="稍后安装操作系统">「稍后安装操作系统」</h3>
<p>在 「虚拟机硬件兼容性」 里选择默认的即可，直接下一步。</p>
<p>在 「安装客户机操作系统」 里选择 「稍后安装操作系统」 ，然后点击下一步：</p>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115205938947.png" alt="稍后安装操作系统" loading="lazy"></figure>
<p>依然选择默认（Linux）的，直接下一步：</p>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115210021499.png" alt="选择Linux" loading="lazy"></figure>
<h3 id="磁盘选择">磁盘选择</h3>
<p><strong>在这一步 「命名虚拟机」 里，给自己的虚拟机命个名称，比如U20，再选择要安装的位置。虚拟机所产生的文件比较大，所以选择位置所在的磁盘最好剩余空间大一些。</strong></p>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115210128940.png" alt="image-20221115210128940" loading="lazy"></figure>
<h3 id="处理器选择">处理器选择</h3>
<p><strong>虚拟机处理器数量及内核都选择2，对于开发来说够用了。即使不够用的话，这个参数也是可以修改的。</strong></p>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115210211912.png" alt="处理器参数" loading="lazy"></figure>
<h3 id="虚拟机内存选择">虚拟机内存选择</h3>
<p><strong>虚拟机内存选择2048M，也就是2G，最好选择1G，2G，4G，8G，不要选择3G这样的。这个参数后期也可以修改。</strong></p>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115210248723.png" alt="内存选择" loading="lazy"></figure>
<h3 id="下一步即可">「下一步即可」</h3>
<p><strong>后面这几步都可以直接「下一步即可」 ，磁盘空间20G不够的话可以选择40G，这个是动态的，也就是不是一下子就占用了你磁盘40G，而是用多少占多少。</strong></p>
<figure data-type="image" tabindex="8"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115210737436.png" alt="image-20221115210737436" loading="lazy"></figure>
<h2 id="安装ubuntu">安装Ubuntu</h2>
<p>开机后会弹出欢迎界面，左边窗口向下滑动找到中文，点击install Ubuntu。</p>
<p>键盘布局选择English（US），双击可以进入下一步。</p>
<p>选择正常安装，安装Ubuntu时下载更新。</p>
<figure data-type="image" tabindex="9"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115211500195.png" alt="image-20221115211500195" loading="lazy"></figure>
<figure data-type="image" tabindex="10"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221115211636930.png" alt="设置" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unix Networking Programming]]></title>
        <id>https://CNZedChou.github.io/post/unix-networking-programming/</id>
        <link href="https://CNZedChou.github.io/post/unix-networking-programming/">
        </link>
        <updated>2022-11-14T10:28:00.000Z</updated>
        <summary type="html"><![CDATA[<p>@Description:   用于记录Unix 网络编程 学习过程<br>
@Author:    Zed Chou<br>
@LastModified:    Mon 14 Nov 2022</p>
]]></summary>
        <content type="html"><![CDATA[<p>@Description:   用于记录Unix 网络编程 学习过程<br>
@Author:    Zed Chou<br>
@LastModified:    Mon 14 Nov 2022</p>
<!-- more -->
<h1 id="课程学习内容">课程学习内容</h1>
<ol>
<li>计算机网络概念  七层模型和四层模型 协议(tcp/ip)  mac地址 ip地址 port 子网掩码 ,,,</li>
<li>数据包的一个组包和拆包流程 tcp/udp特点</li>
<li>udp编程 编程准备(字节序 端口,ip大小端转换的函数)  udpAPI  发送接收数据</li>
<li>udp-tftp编程  udp广播</li>
<li>tcp 编程  客户端和服务器编写流程 三次握手和四次挥手</li>
<li>tcp 高并发服务器  多进程多线程服务器 select,poll,epoll实现的tcp服务器    epoll+线程池</li>
<li>网络通信过程(了解)</li>
<li>原始套接字 自己组底层的数据包 收一帧完整的数据包</li>
<li>http协议 web-html 编写web服务器</li>
</ol>
<h1 id="一-计算机网络概述">一、计算机网络概述</h1>
<h2 id="1-计算机网络发展简史">1. 计算机网络发展简史</h2>
<p>在通信双方或多方之间，通过电路交换建立电路连接的网络</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221114194147041.png" alt="电路连接网络" loading="lazy"></figure>
<h3 id="电路交换网特点">电路交换网特点</h3>
<p>1、建立链接-&gt;使用链接-&gt;释放链接</p>
<p>2、物理通路被通信双方独占</p>
<p>计算机数据是突发式出现在数据链路上的,而电路交换网的建立链接、使用链接、释放链接的三个过程使得传输效率太低，故电路交换不适合传输计算机数据。</p>
<h3 id="分组交换">分组交换</h3>
<p>通过标有地址的分组进行路由选择传送数据，使通信通道仅在传送期间被占用的一种交换方式</p>
<p>分组的组成：</p>
<p>每个分组都由首部和数据段组成；为什么？</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221114194342575.png" alt="分组交换" loading="lazy"></figure>
<h3 id="交换方式">交换方式</h3>
<p>交换方式—<strong>存储转发</strong></p>
<p>节点收到分组，先暂时存储下来，再检查其首部，按</p>
<p>照首部中的目的地址，找到合适的节点转发出去</p>
<p>特点：</p>
<ol>
<li>以分组作为传输单位</li>
<li>独立的选择转发路由</li>
<li>逐段占用，动态分配传输带宽</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221114194440514.png" alt="存储转发" loading="lazy"></figure>
<h2 id="2-tcpip协议简介">2. TCP/IP协议简介</h2>
<p>为了使各种不同的计算机之间可以互联,ARPANet指定了一套计算机通信协议，即TCP/IP协议(族)</p>
<p>为了减少协议设计的复杂性，大多数网络模型均采用<strong>分层</strong>的方式来组织</p>
<p>每一层<strong>利用下一层提供的服务</strong>来<strong>为上一层提供服务</strong></p>
<p>本层服务的<strong>实现细节对上层屏蔽</strong></p>
<h3 id="分层结构">分层结构</h3>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/clip_image002.jpg" alt="img" loading="lazy"></figure>
<h4 id="osi-7层模型">OSI 7层模型</h4>
<p>物理层: 各种网络接口(双绞线)的类型,传输速率 等等的一些物理特性</p>
<p>数据链路层: 负责对数据帧的收发</p>
<p>网络层: 使数据包能够最大可能的达到目的主机</p>
<p>传输层: 数据包和程序通信的桥梁</p>
<p>会话层: 保持连接的</p>
<p>表示层: 数据解压缩解码等等</p>
<p>应用层: 应用程序</p>
<h4 id="tcpip的4层模型">tcp/ip的4层模型</h4>
<p>**应用层：**应用程序间沟通的层</p>
<p>例如：FTP、Telnet、HTTP等</p>
<p>**传输层：**提供进程间的数据传送服务</p>
<p>负责传送数据，提供应用程序端到端的逻辑通信 。例如：TCP、UDP</p>
<p>**网络层：**提供基本的数据封包传送功能</p>
<p>最大可能的让每个数据包都能够到达目的主机。例如：IP、ICMP等</p>
<p>**链路层：**负责数据帧的发送和接收</p>
<h5 id="协议">协议:</h5>
<p><strong>应用层协议:</strong></p>
<p>FTP : 文件传输协议</p>
<p>TFTP: 简单文件传输协议</p>
<p>HTTP: 超文本传输协议</p>
<p>SSH:</p>
<p>TELNET:....</p>
<p><strong>传输层协议:</strong></p>
<p>TCP: 传输控制协议</p>
<p>UDP: 用户数据报协议</p>
<p>网络层协议:</p>
<p>IP: 英特网互联协议</p>
<p>ICMP: 特网网控制报文协议</p>
<p>IGMP: 特网网组管理协议</p>
<p><strong>链路层协议:</strong></p>
<p>ARP: 地址解析协议  作用: 通过ip找mac地址</p>
<p>RARP: 反向地址解析协议 作用: 通过mac地址找IP</p>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221114194650410.png" alt="分层结构" loading="lazy"></figure>
<p>每层完成自己的任务，最终通过不同层次的处理完成数据的收发</p>
<h3 id="ip协议简介">IP协议简介</h3>
<p>特指为实现在一个相互连接的网络系统上从源地址到目的地传输数据包（互联网数据包）所提供必要功能的协议</p>
<p><strong>特点：</strong></p>
<p><strong>不可靠</strong>：它不能保证IP数据包能成功地到达它的目的地，仅提供<strong>尽力而为</strong>的传输服务</p>
<p><strong>无连接</strong>：IP并不维护任何关于<strong>后续数据包的状态信息</strong>。每个数据包的处理是相互独立的。IP数据包可以不按发送顺序接收</p>
<p>IP数据包中含有发送它主机的IP地址（源地址）和接收它主机的IP地址（目的地址）</p>
<h3 id="tcp协议简介">TCP协议简介</h3>
<p><strong>TCP</strong> <strong>是一种面向连接的,可靠的传输层通信协议</strong></p>
<p><strong>功能：</strong></p>
<p>提供不同主机上的进程间通信</p>
<p><strong>特点</strong></p>
<p>1、建立链接-&gt;使用链接-&gt;释放链接（虚电路）</p>
<p>2、TCP数据包中包含序号和确认序号</p>
<p>3、对包进行排序并检错，而损坏的包可以被重传</p>
<p><strong>服务对象</strong></p>
<p>需要高度可靠性且面向连接的服务</p>
<p>如HTTP、FTP、SMTP等</p>
<h3 id="udp协议简介">UDP协议简介</h3>
<p><strong>UDP</strong> 是<strong>一种面向无连接的传输层通信协议</strong></p>
<p><strong>功能：</strong></p>
<p>提供不同主机上的进程间通信</p>
<p><strong>特点</strong></p>
<p>1、发送数据之前不需要建立链接</p>
<p>2、不对数据包的顺序进行检查</p>
<p>3、没有错误检测和重传机制</p>
<p><strong>服务对象</strong></p>
<p>主要用于“查询—应答”的服务</p>
<p>如：NFS、NTP、DNS等</p>
<h2 id="3-mac地址-ip地址-netmask-端口">3. MAC地址、IP地址、Netmask、端口</h2>
<h3 id="网卡">网卡</h3>
<p>又称为网络适配器或网络接口卡NIC，但是现在更多的人愿意使用更为简单的名称“网卡”</p>
<p>作用:通过网卡能够使不同的计算机之间连接，从而完成数据通信等功能，用来<strong>发送接收数据</strong>的,将<strong>模拟信号转成数字信号</strong></p>
<h3 id="mac地址">MAC地址</h3>
<p>MAC地址,用于标识网络设备,类似于身份证号，且理论上全球唯一，这个全球唯一的标识id号就是我们所说的mac地址</p>
<p><strong>组成：<strong>以太网内的MAC地址是一个</strong>48bit</strong>（6个字节）的值</p>
<p>mac地址是用来标识网卡的一个物理地址，<strong>物理地址不能改变</strong></p>
<h3 id="ip地址">IP地址</h3>
<p>IP地址是一种Internet上的主机编址方式，也称为网际协议地址。用于屏蔽不同数据链锯介质造成的数据帧差异而抽象的互联网同一地址</p>
<p>用来标识主机或网卡的一个虚拟ip</p>
<p>使用32bit,由{网络ID，主机ID}两部分组成</p>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221114203916696.png" alt="ip地址" loading="lazy"></figure>
<p>子网ID:IP地址中<strong>由子网掩码中1覆盖的连续位</strong></p>
<p>主机ID:IP地址中由子网掩码中0覆盖的连续位</p>
<h4 id="ip地址特点">ip地址特点</h4>
<p>子网ID不同的网络不能直接通信，如果要通信则需要路由器转发</p>
<p>主机ID全为0的IP地址表示网段地址</p>
<p>主机ID全为1的IP地址表示该网段的广播地址</p>
<h4 id="ip地址分类">ip地址分类:</h4>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221114203609391.png" alt="ip地址分类" loading="lazy"></figure>
<p>A类地址：默认8bit子网ID,第一位为0</p>
<p>B类地址：默认16bit子网ID,前两位为10</p>
<p>C类地址：默认24bit子网ID,前三位为110</p>
<p>D类地址：前四位为1110,多播地址</p>
<p>E类地址: 前五位为11110,保留为今后使用</p>
<p>A,B,C三类地址是最常用的</p>
<p><strong>公有IP（可直接连接Internet）</strong>：经由InterNIC所统一规划的IP</p>
<p><strong>私有IP（不可直接连接Internet ）</strong>：主要用于局域网络内的主机联机规划</p>
<h4 id="回环ip地址">回环ip地址</h4>
<p>通常 127.0.0.1 称为回环地址</p>
<p>127.0.0.1~127.255.255.254中的任何地址都将回环到本地主机中，不属于任何一个有类别地址类,它代表设备的本地虚拟接口</p>
<h3 id="子网掩码">子网掩码</h3>
<p>子网掩码（subnet mask）又叫网络掩码、地址掩码是一个32bit由1和0组成的数值，并且1和0分别连续</p>
<p><strong>作用</strong></p>
<p>指明IP地址中<strong>哪些位标识的是主机所在的子网</strong>以及哪些位标识的是<strong>主机号</strong></p>
<p><strong>特点</strong></p>
<p>必须<strong>结合IP地址一起使用</strong>，不能单独存在</p>
<p>IP地址中由子网掩码中1覆盖的连续位为子网ID,其余为主机ID</p>
<h3 id="端口">端口</h3>
<h4 id="端口概述">端口概述</h4>
<p>TCP/IP协议采用端口标识通信的进程</p>
<p>用于区分一个系统里的多个进程</p>
<p><strong>特点</strong></p>
<p>1、对于<strong>同一个端口</strong>，在不同系统中对应着不同的进程</p>
<p>2、对于<strong>同一个系统</strong>，一个端口<strong>只能被一个进程拥有</strong></p>
<p>3、一个进程拥有一个端口后，传输层送到该端口的数据<strong>全部被该进程接收</strong>，同样，进程送交传输层的数据也<strong>通过该端口被送出</strong></p>
<h4 id="端口号">端口号</h4>
<p>类似pid标识一个进程；在网络程序中，用端口号（port）来标识一个<strong>运行的网络程序</strong>，底层用来标识缓冲区</p>
<figure data-type="image" tabindex="8"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221114204733141.png" alt="端口解释" loading="lazy"></figure>
<p><strong>特点</strong></p>
<p>1、端口号是无符号短整型的类型</p>
<p>2、每个端口都拥有一个端口号</p>
<p>3、TCP、UDP维护各自独立的端口号</p>
<p>4、网络应用程序,至少要占用一个端口号,也可以占有多个端口号</p>
<p><strong>知名端口（1~1023）</strong>：由互联网数字分配机构(IANA)根据用户需要进行统一分配</p>
<p>例如：FTP—21，HTTP—80等</p>
<p>服务器通常使用的范围;<strong>若强制使用,须加root特权</strong></p>
<p><strong>动态端口（1024~65535）</strong>：应用程序通常使用的范围</p>
<p><strong>注意</strong>：端口号类似于进程号，<strong>同一时刻只能标志一个进程</strong>；可以重复使用</p>
<h2 id="4-数据包的组装-拆解">4. 数据包的组装、拆解</h2>
<h3 id="数据包在各个层之间的传输">数据包在各个层之间的传输</h3>
<figure data-type="image" tabindex="9"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221114205622235.png" alt="组包拆包" loading="lazy"></figure>
<h3 id="链路层封包格式">链路层封包格式</h3>
<p><strong>注意</strong></p>
<p>1、IEEE802.2/802.3封装常用在无线</p>
<p>2、以太网封装常用在有线局域网</p>
<figure data-type="image" tabindex="10"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221114210458306.png" alt="封包格式" loading="lazy"></figure>
<h3 id="网络层-传输层封包格式">网络层、传输层封包格式</h3>
<figure data-type="image" tabindex="11"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221114210540867.png" alt="网络层、传输层风暴格式" loading="lazy"></figure>
<h2 id="5-网络开发模型-浏览器和服务器">5. 网络开发模型 浏览器和服务器</h2>
<h3 id="bs-browserserver">B/S  browser/server</h3>
<p><strong>特点:</strong></p>
<p>缺点：不能用于对性能要求高的程序</p>
<p>优点:     不容易偷数据,比较安全</p>
<p>​			移植性高,不依赖平台</p>
<p>​			开发周期相对短</p>
<h3 id="cs-clientserver-客户端和服务器">C/S client/server 客户端和服务器</h3>
<p><strong>server</strong></p>
<p>打开一通信通道并告知本地主机,它愿意在一特定端口(如80)上接收客户请求</p>
<p>等待客户请求到达该端口</p>
<p>接收客户请求，并发送应答信号,激活一新的线程处理这个客户请求</p>
<p>服务完成后,关闭新线程与客户的通信链路</p>
<p><strong>client</strong></p>
<p>打开一通信通道并连接到服务器特定端口</p>
<p>向服务器发出服务请求,等待并接收应答</p>
<p>根据需要继续提出请求</p>
<p>请求结束后关闭通信通道并终止</p>
<p><strong>特点</strong>:</p>
<p>缺点: 不是特别安全,依赖平台,开发周期较长</p>
<p>优点: 可运行对性能要求较高的程序</p>
<h4 id="tcp"><strong>tcp</strong>:</h4>
<p><strong>电话系统服务模式的抽象</strong></p>
<p>每一次完整的数据传输都要经过<strong>建立连接、使用连接、终止连接</strong>的过程</p>
<p>本质上,连接是一个管道,收发数据不但顺序一致,而且内容相同，保证数据传输的可靠性</p>
<p><strong>出错重传</strong>,比较<strong>安全可靠</strong>,每次收到数据都会给到<strong>回应ACK</strong>。</p>
<h4 id="udp">UDP</h4>
<p><strong>邮件系统服务模式的抽象</strong></p>
<p>每个分组都携带完整的目的地址，不能保证分组的先后顺序，不进行分组出错的恢复和重传，不保证数据传输的可靠性。</p>
<p>在局域网中效率比较高</p>
<h1 id="二-udp编程">二、UDP编程</h1>
<h2 id="1-字节序-地址转换">1. 字节序、地址转换</h2>
<h3 id="字节序概述">字节序概述</h3>
<p><strong>字节序概念</strong></p>
<p>是指多字节数据的存储顺序</p>
<p><strong>分类</strong></p>
<p>小端格式:将<strong>低位</strong>字节数据存储在<strong>低地址</strong></p>
<p>大端格式:将<strong>高位</strong>字节数据存储在<strong>低地址</strong></p>
<figure data-type="image" tabindex="12"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221114215354539.png" alt="大小端" loading="lazy"></figure>
<p><strong>注意</strong></p>
<p>LSB：低地址</p>
<p>MSB：高地址</p>
<figure data-type="image" tabindex="13"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221114215321018.png" alt="字节序" loading="lazy"></figure>
<h4 id="大小端识别">大小端识别</h4>
<p>代码</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
typedef union  std
{
	unsigned short a; 
	unsigned char b[2];

}STD;
int main(int argc, char *argv[])
{
	STD tmp;
	tmp.a=0x0102;
	if(tmp.b[0]== 0x01){
		printf(&quot;大端\n&quot;);
		
	}
	else{
        printf(&quot;小端\n&quot;);
    }
	return 0;
}
</code></pre>
<figure data-type="image" tabindex="14"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221116184221521.png" alt="大小端识别" loading="lazy"></figure>
<h3 id="字节序转换api">字节序转换API</h3>
<h4 id="htonl函数32位转大端-ip">htonl函数（32位转大端-ip）</h4>
<p>uint32_t htonl(uint32_t hostint32);</p>
<p><strong>功能:</strong></p>
<p>将32位<strong>主机（host）字节序</strong>数据转换成<strong>网络（n-大端）字节序</strong>数据</p>
<p><strong>参数：</strong></p>
<p>hostint32：待转换的32位主机字节序数据</p>
<p><strong>返回值：</strong></p>
<p>成功：返回网络字节序的值</p>
<p><strong>头文件：</strong></p>
<p>#include &lt;arpa/inet.h&gt;</p>
<pre><code class="language-c">/*************************************************************************
        &gt; File Name: htonl_test.c
        &gt; Author: Zhihao Zhou
        &gt; Mail: cnzedchou@gmail.com
        &gt; Created Time: 2022年11月16日 星期三 18时52分04秒
 ************************************************************************/

#include &lt;stdio.h&gt;
#include &lt;arpa/inet.h&gt;
int main(int argc, char *argv[]){
    int num = 0x01020304; // little endian
    int s = htonl(num);
    printf(&quot;%x\n&quot;, s);
    return 0;
}
</code></pre>
<figure data-type="image" tabindex="15"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221116185514621.png" alt="htonl函数" loading="lazy"></figure>
<h4 id="htons函数16位转大端-端口">htons函数（16位转大端-端口）</h4>
<p>uint16_t htons(uint16_t hostint16);</p>
<p><strong>功能：</strong></p>
<p>将16位主机字节序数据转换成网络字节序数据</p>
<p><strong>参数：</strong></p>
<p>uint16_t：unsigned short int</p>
<p>hostint16：待转换的16位主机字节序数据</p>
<p><strong>返回值：</strong></p>
<p>成功：返回网络字节序的值</p>
<p><strong>头文件：</strong></p>
<p>#include &lt;arpa/inet.h&gt;</p>
<pre><code class="language-c">/*************************************************************************
        &gt; File Name: htonl_test.c
        &gt; Author: Zhihao Zhou
        &gt; Mail: cnzedchou@gmail.com
        &gt; Created Time: 2022年11月16日 星期三 18时52分04秒
 ************************************************************************/

#include &lt;stdio.h&gt;
#include &lt;arpa/inet.h&gt;
int main(int argc, char *argv[]){
    int num = 0x0102; // little endian
    int s = htons(num);
    printf(&quot;%x\n&quot;, s);
    return 0;
}
</code></pre>
<figure data-type="image" tabindex="16"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221116185953286.png" alt="16位转大端" loading="lazy"></figure>
<h4 id="ntohl函数">ntohl函数（）</h4>
<p>uint32_t ntohl(uint32_t netint32);</p>
<p><strong>功能：</strong></p>
<p>将32位网络字节序数据转换成主机字节序数据</p>
<p><strong>参数：</strong></p>
<p>uint32_t： unsigned int</p>
<p>netint32：待转换的32位网络字节序数据</p>
<p><strong>返回值：</strong></p>
<p>成功：返回主机字节序的值</p>
<p><strong>头文件：</strong></p>
<p>#include &lt;arpa/inet.h&gt;</p>
<pre><code class="language-c">/*************************************************************************
        &gt; File Name: htonl_test.c
        &gt; Author: Zhihao Zhou
        &gt; Mail: cnzedchou@gmail.com
        &gt; Created Time: 2022年11月16日 星期三 18时52分04秒
 ************************************************************************/

#include &lt;stdio.h&gt;
#include &lt;arpa/inet.h&gt;
int main(int argc, char *argv[]){
    int num = 0x01020304; // little endian
    int s = htonl(num);
    printf(&quot;%x\n&quot;, s);
    int n = ntohl(s);
    printf(&quot;%x\n&quot;, n);
    return 0;
}
</code></pre>
<figure data-type="image" tabindex="17"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221116190353474.png" alt="ntohl函数" loading="lazy"></figure>
<h4 id="ntohs函数">ntohs函数</h4>
<p>uint16_t ntohs(uint16_t netint16);</p>
<p><strong>功能：</strong></p>
<p>将16位网络字节序数据转换成主机字节序数据</p>
<p><strong>参数：</strong></p>
<p>uint16_t： unsigned short int</p>
<p>netint16：待转换的16位网络字节序数据</p>
<p><strong>返回值：</strong></p>
<p>成功：返回主机字节序的值</p>
<p><strong>头文件：</strong></p>
<p>#include &lt;arpa/inet.h&gt;</p>
<pre><code class="language-c">/*************************************************************************
        &gt; File Name: htonl_test.c
        &gt; Author: Zhihao Zhou
        &gt; Mail: cnzedchou@gmail.com
        &gt; Created Time: 2022年11月16日 星期三 18时52分04秒
 ************************************************************************/

#include &lt;stdio.h&gt;
#include &lt;arpa/inet.h&gt;
int main(int argc, char *argv[]){
    int num = 0x0102; // little endian
    int s = htons(num);
    printf(&quot;%x\n&quot;, s);
    int n = ntohs(s);
    printf(&quot;%x\n&quot;, n);
    return 0;
}
</code></pre>
<figure data-type="image" tabindex="18"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221116190525927.png" alt="ntohs函数" loading="lazy"></figure>
<h3 id="地址转换函数">地址转换函数</h3>
<h4 id="inet_pton函数点分十进制转换">inet_pton函数（点分十进制转换）</h4>
<p>#include &lt;arpa/inet.h&gt;</p>
<p>int inet_pton(int af, const char *src, void *dst);</p>
<p>函数功能:  将一个点分十进制串转成一个<strong>32位大端的整数</strong><br>
参数:   <strong>af: AF_INET ipv4写这个</strong><br>
<strong>src:待转换字符串的首元素地址</strong><br>
<strong>dst: 32为整数的地址</strong><br>
返回值:  成功返回1 失败返回其他</p>
<pre><code class="language-c">/*************************************************************************
        &gt; File Name: htonl_test.c
        &gt; Author: Zhihao Zhou
        &gt; Mail: cnzedchou@gmail.com
        &gt; Created Time: 2022年11月16日 星期三 18时52分04秒
 ************************************************************************/

#include &lt;stdio.h&gt;
#include &lt;arpa/inet.h&gt;
int main(int argc, char *argv[]){
    char buf_ip[] = &quot;192.168.1.2&quot;;
    int num = 0;
    inet_pton(AF_INET, buf_ip, &amp;num);
    unsigned char *p = (char *)&amp;num;
    printf(&quot;%d %d %d %d\n&quot;, *p, *(p + 1), *(p + 2), *(p + 3));
    return 0;
}
</code></pre>
<figure data-type="image" tabindex="19"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221116191736337.png" alt="inet_pton" loading="lazy"></figure>
<h4 id="inet_ntop函数">inet_ntop函数</h4>
<p>include &lt;arpa/inet.h&gt;const char *inet_ntop(int af, const void *src,<br>
char *dst, socklen_t size);<br>
功能: 将一个<strong>网络大端的32位数据转成一个点分十进制串</strong></p>
<p>参数:   af: AF_INET</p>
<p>​			src: 32位网络大端的数据地址<br>
dst: 存储点分十进制串数组的地址</p>
<p>​			size: 存储点分十进制串数组的大小</p>
<p>返回值:  成功返回1 失败返回其他</p>
<pre><code class="language-c">/*************************************************************************
        &gt; File Name: htonl_test.c
        &gt; Author: Zhihao Zhou
        &gt; Mail: cnzedchou@gmail.com
        &gt; Created Time: 2022年11月16日 星期三 18时52分04秒
 ************************************************************************/

#include &lt;stdio.h&gt;
#include &lt;arpa/inet.h&gt;
int main(int argc, char *argv[]){
    char buf_ip[] = &quot;192.168.1.2&quot;;
    int num = 0;
    inet_pton(AF_INET, buf_ip, &amp;num);
    unsigned char *p = (char *)&amp;num;
    // printf(&quot;%d %d %d %d\n&quot;, *p, *(p + 1), *(p + 2), *(p + 3));
    char ip[INET_ADDRSTRLEN]; // ip数组，16； 宏 INET_ADDRSTRLEN = 16 
    inet_ntop(AF_INET, &amp;num, ip, INET_ADDRSTRLEN);
    printf(&quot;ip=%s\n&quot;, ip);
    return 0;
}
</code></pre>
<figure data-type="image" tabindex="20"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221116192601398.png" alt="inet_ntop" loading="lazy"></figure>
<h2 id="2-socket介绍">2. socket介绍</h2>
<p>网络通信解决什么问题?</p>
<p>​	为了解决<strong>不同主机的进程间通信</strong>的问题</p>
<p>​	socket套接字用来解决不同主机进程间通信的问题</p>
<p>​	每一台主机必须要有和对方主机成对出现的一个socket</p>
<figure data-type="image" tabindex="21"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221116192928120.png" alt="socket 图示" loading="lazy"></figure>
<h3 id="3-udp-编程">3. UDP 编程</h3>
<p><strong>UDP</strong></p>
<p>面向无连接的用户数据报协议，在传输数据前不需要先建立连接；目地主机的运输层收到UDP报文后，不需要给出任何确认</p>
<p><strong>UDP特点</strong></p>
<p>1、相比TCP速度稍快些</p>
<p>2、简单的请求/应答应用程序可以使用UDP</p>
<p>3、对于海量数据传输不应该使用UDP</p>
<p>4、广播和多播应用必须使用UDP</p>
<p><strong>UDP应用</strong></p>
<p>DNS(域名解析)、NFS(网络文件系统)、RTP(流媒体)等</p>
<h4 id="通信流程">通信流程</h4>
<p>对于udp来讲,可以没有服务器,服务器只是认为规定的一种 主动发送的一方为客户端,被动接受的一方为服务器</p>
<p>如果作为服务器被动等待别人发送数据,这个服务器需要绑定上固定的ip和端口</p>
<p>流程: 创建套接字 -&gt; 绑定(非必须的) -&gt;读写 -&gt; 关闭</p>
<figure data-type="image" tabindex="22"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221116194014544.png" alt="udp通信流程" loading="lazy"></figure>
<h4 id="创建socket套接字">创建socket套接字</h4>
<p>`#include &lt;sys/socket.h&gt;`</p>
<p><code>int socket(int domain, int type, int protocol);</code></p>
<p>功能: 创建一个socket套接字</p>
<p>参数:</p>
<p>​			domain:  AF_INET</p>
<p>​			type:</p>
<p>​					SOCK_STREAM : 流式套接字 用于tcp通信</p>
<p>​					SOCK_DGRAM  : 报式套接字  用于udp通信</p>
<p>​			protocol: 协议 0 自动指定</p>
<p>返回值: 返回一个套接字 (文件描述符)</p>
<h4 id="绑定套接字">绑定套接字</h4>
<p><code>#include &lt;sys/socket.h&gt;</code></p>
<p><code>int bind(int sockfd, const struct sockaddr *addr,        socklen_t addrlen);</code></p>
<p>功能:  给套接字绑定一个固定的ip和端口</p>
<p>参数:</p>
<p>​			sockfd: 套接字</p>
<p>​			addr: ipv4套接字结构体地址 转成 通用套接字结构体地址</p>
<p>​			addrlen: 结构体的大小</p>
<p><strong>网络通信 需要解决三大问题: 协议 ip port协议，ip port封装在一个结构体中</strong></p>
<h4 id="ipv4-结构体">IPV4 结构体</h4>
<pre><code class="language-c">ipv4套接字结构体:

struct sockaddr_in {
    sa_family_t    sin_family; /* address family: AF_INET */
    in_port_t      sin_port;   /* port in network byte order*/
    struct in_addr sin_addr;   /* internet address */
};
/* Internet address. */
struct in_addr {
    uint32_t       s_addr;     /* address in network byte order */
};
</code></pre>
<h4 id="ipv6结构体">IPV6结构体</h4>
<pre><code class="language-c">vipv6套接字结构体:
struct sockaddr_in6 {
    unsigned short int sin6_family;        /* AF_INET6 */
    __be16 sin6_port;                  /* Transport layer port # */
    __be32 sin6_flowinfo;              /* IPv6 flow information */
    struct in6_addr sin6_addr;         /* IPv6 address */
    __u32 sin6_scope_id;               /* scope id (new in RFC2553) */
};
struct in6_addr {
    union {
        __u8 u6_addr8[16];
        __be16 u6_addr16[8];
        __be32 u6_addr32[4];
    } in6_u;
    #define s6_addr        in6_u.u6_addr8
    #define s6_addr16      in6_u.u6_addr16
    #define s6_addr32     in6_u.u6_addr32
};
</code></pre>
<h4 id="本地套接字结构体">本地套接字结构体</h4>
<pre><code class="language-c">本地套接字结构体
#define UNIX_PATH_MAX 108
struct sockaddr_un {
    __kernel_sa_family_t sun_family;   /* AF_UNIX */
    char sun_path[UNIX_PATH_MAX]; /* pathname */
};
</code></pre>
<h4 id="通用套接字结构体">通用套接字结构体</h4>
<pre><code class="language-c">struct sockaddr *
struct sockaddr
{
sa_family_t sa_family; // 2字节
char sa_data[14] //14字节
};
</code></pre>
<h4 id="udp-客户端编写">UDP 客户端编写</h4>
<pre><code class="language-c">ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,const struct sockaddr *dest_addr, socklen_t addrlen);
功能: 发送数据
参数：
    sockfd: 套接字
    buf: 发送的内容地址
    len: 发送内容的大小
    flags: 0 
    dest_addr: ipv4套接字结构体(目的地的地址信息)   
     addrlen: 结构体大小
返回值: 发送的字节数
</code></pre>
<pre><code class="language-c">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                        struct sockaddr *src_addr, socklen_t *addrlen);
功能:收数据
参数:
    sockfd: 套接字
    buf:  存储数据数据区的地址
    len: 存储数据数据区大小
    flags: 0
    src_addr:  ipv4套接字结构体(存储对方的地址信息)
    addrlen:  ipv4套接字结构体大小的地址
返回值L接收数据的字节数
</code></pre>
<p><strong>客户端代码：</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Obsidian 与 Zotero]]></title>
        <id>https://CNZedChou.github.io/post/obsidian-yu-zotero/</id>
        <link href="https://CNZedChou.github.io/post/obsidian-yu-zotero/">
        </link>
        <updated>2022-11-11T13:13:52.000Z</updated>
        <content type="html"><![CDATA[<p>@Description:   用于记录solidity 学习过程<br>
@Author:    Zed Chou<br>
@LastModified:    Fri 11 Nov 2022</p>
<!-- more -->]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Tricks in Linux]]></title>
        <id>https://CNZedChou.github.io/post/tricks-in-linux/</id>
        <link href="https://CNZedChou.github.io/post/tricks-in-linux/">
        </link>
        <updated>2022-10-07T07:37:28.000Z</updated>
        <summary type="html"><![CDATA[<p>@Description:   用于记录在Linux使用过程中遇到的各种问题、配置环境等<br>
@Author:    Zed Chou<br>
@LastModified:    Fri 7 Oct 2022</p>
]]></summary>
        <content type="html"><![CDATA[<p>@Description:   用于记录在Linux使用过程中遇到的各种问题、配置环境等<br>
@Author:    Zed Chou<br>
@LastModified:    Fri 7 Oct 2022</p>
<!-- more -->
<h1 id="mysql-in-linux">MySql in Linux</h1>
<h2 id="安装-mysql">安装 MySQL</h2>
<pre><code class="language-bash"># 更新你的 ubuntu 依赖库索引
sudo apt update
# 查看 mysql-server 的可用版本 (可选)
apt-cache policy mysql-server

# 应该输出类似如下
kala@58baab1b577c:~$ apt-cache policy mysql-server
mysql-server:
  Installed: (none)
  Candidate: 8.0.20-0ubuntu0.20.04.1
  Version table:
     8.0.20-0ubuntu0.20.04.1 500
        500 http://archive.ubuntu.com/ubuntu focal-updates/main amd64 Packages
        500 http://security.ubuntu.com/ubuntu focal-security/main amd64 Packages
     8.0.19-0ubuntu5 500
        500 http://archive.ubuntu.com/ubuntu focal/main amd64 Packages
</code></pre>
<p>开始安装</p>
<pre><code class="language-bash">sudo apt install mysql-server
</code></pre>
<p>输入Y以继续</p>
<pre><code class="language-bash"># 重启 MySQL 服务以保证 MySQL 已经启动
sudo service mysql restart

# 输出为
root@58e152781375:/home/kala# sudo service mysql restart
 * Stopping MySQL database server mysqld                                          [ OK ]
 * Starting MySQL database server mysqld    
</code></pre>
<h2 id="设置mysql">设置mysql</h2>
<p>第一次安装好 MySQL 之后，我们需要运行 MySQL 自带的安全脚本来确保数据库系统的安全。这个脚本会把一些默认选项，比如允许远程 root 登录之类的设置改掉。</p>
<pre><code class="language-bash"># 我们以 root 权限运行以下安全脚本
sudo mysql_secure_installation
</code></pre>
<h2 id="遇到的坑">遇到的坑</h2>
<p>把mysql安装好以后准备连接， 却遇到了这样的问题。</p>
<pre><code class="language-bash">ERROR 1698 (28000): Access denied for user 'root'@'localhost'
</code></pre>
<h2 id="被禁止访问的原因">被禁止访问的原因</h2>
<ol>
<li>mysql默认<code>auth_socket</code>登录鉴权</li>
<li>未初始化数据库、设置默认密码</li>
</ol>
<h2 id="解决办法">解决办法</h2>
<p><strong>1.mysql默认<code>auth_socket</code>登录鉴权</strong></p>
<p><code>auth_socket</code> 是免密码登录的方式。</p>
<p>因此密码登录需要把它改成<code>mysql_native_password</code></p>
<pre><code class="language-bash">$ sudo mysql -u root -p # 需要使用“sudo”，因为是新安装的

mysql&gt; USE mysql;
mysql&gt; SELECT User, Host, plugin FROM `user`;

+------------------+-----------------------+
| User             | plugin                |
+------------------+-----------------------+
| root             | auth_socket           |
| mysql.sys        | mysql_native_password |
| debian-sys-maint | mysql_native_password |
+------------------+-----------------------+


mysql&gt; UPDATE user SET plugin='mysql_native_password' WHERE User='root';
mysql&gt; FLUSH PRIVILEGES;  # 刷新权限
</code></pre>
<p><strong>2.未初始化数据库、设置默认密码</strong></p>
<p>新安装的mysql是没有密码的， 可以通过命令初始化设置密码和配置远程登录等</p>
<pre><code class="language-bash">$ sudo mysql_secure_installation # 需要使用“sudo”，因为是新安装的
</code></pre>
<h1 id="linux-查看mac地址">Linux 查看MAC地址</h1>
<p>打开终端，输入<code>ifconig</code>，ether字符就是MAC地址</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/CNZedChou/ForPicGo/master/image-20221116193728101.png" alt="ifconfig" loading="lazy"></figure>
]]></content>
    </entry>
</feed>